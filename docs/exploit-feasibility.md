# Exploit Feasibility Analysis Guide

This guide explains how to use RAPTOR's exploit feasibility analysis to determine what's actually exploitable before wasting time on impossible approaches.

## The Problem

You find a format string vulnerability. You try:
1. GOT overwrite → blocked by Full RELRO
2. __malloc_hook → removed in glibc 2.34
3. %n writes → blocked by glibc 2.38
4. Multi-gadget ROP → strcpy null bytes break addresses

**Hours wasted.** The feasibility analysis would have told you in seconds that none of these work.

## Quick Start

```python
from packages.exploit_feasibility import analyze_binary, format_analysis_summary

result = analyze_binary('/path/to/binary')
print(format_analysis_summary(result, verbose=True))
```

This runs ~30 checks in a few seconds and tells you:
- What protections exist
- What techniques are blocked (and why)
- What techniques might work
- What would help (environment changes, info leaks, etc.)

## Understanding the Output

### Verdicts

| Verdict | Meaning | Action |
|---------|---------|--------|
| **Likely exploitable** | Good primitives, clear path | Proceed with suggested techniques |
| **Difficult** | Primitives exist but hard to chain | Be honest about challenges, try alternatives |
| **Unlikely** | No known viable path | Suggest environment changes or move on |

### Chain Breaks

These are techniques that **will not work**:

```
CHAIN BREAKS
────────────────────────────────────────
  ✗ GOT overwrite blocked by Full RELRO
  ✗ .fini_array blocked by Full RELRO
  ✗ Hook overwrite blocked (hooks removed in glibc 2.34+)
```

**Do not attempt techniques listed here.** The analysis has determined they are architecturally impossible.

### What Would Help

These are suggestions for making exploitation possible:

```
WHAT WOULD HELP
────────────────────────────────────────
  → Run in older environment (Docker with Ubuntu 20.04, glibc 2.31)
  → Find info leak to defeat ASLR
  → Look for one_gadget with satisfiable constraints
```

## Common Scenarios

### Scenario 1: Format String + Full RELRO + Modern glibc

**Typical blockers:**
- GOT overwrite: Blocked (Full RELRO)
- .fini_array: Blocked (Full RELRO puts it in read-only segment)
- __malloc_hook: Removed (glibc 2.34+)
- %n writes: May be blocked (glibc 2.38+)

**What might work:**
- Overwrite return address on stack (if you can reach it)
- Overwrite function pointers in .data/.bss
- Partial overwrite to redirect within same page

**Recommended action:**
```python
# Check alternative write targets
for target in result.get('alternative_targets', []):
    if target['viable']:
        print(f"Try: {target['name']} @ 0x{target['address']:x}")
```

### Scenario 2: Stack Overflow + strcpy + x86_64

**The problem:** strcpy stops at null bytes. x86_64 addresses look like `0x00007fff12345678` in memory: `78 56 34 12 ff 7f 00 00`. The null bytes at positions 6-7 mean you can only write 6 bytes.

**What's blocked:**
- Multi-gadget ROP chains (can't write multiple addresses)
- ret2libc with arguments (need to write pop_rdi + arg + function)

**What might work:**
- Single gadget redirect (one_gadget if constraints met)
- Partial overwrite (only overwrite low bytes of return address)
- Stack pivot to controlled buffer

**Check one_gadgets:**
```python
for og in result.get('libc', {}).get('one_gadgets_detailed', []):
    print(f"0x{og['offset']:x}: {og['constraints']}")
    if og.get('partial_overwrite_viable'):
        print("  ^ Can use partial overwrite!")
```

### Scenario 3: Heap Overflow + tcache

**Modern heap mitigations (glibc 2.32+):**
- Safe-linking: XORs fd pointers with address
- Alignment checks: Validates chunk alignment
- Double-free detection: Detects obvious double-frees

**The analysis checks:**
```python
heap_info = result.get('heap_mitigations', {})
if heap_info.get('safe_linking'):
    print("Need heap leak to bypass safe-linking")
if heap_info.get('tcache_key'):
    print("Double-free detection active")
```

## Context Persistence

Long exploitation sessions may hit context limits. Save the analysis:

```python
from packages.exploit_feasibility import (
    save_exploit_context,
    load_exploit_context,
    print_exploit_context
)

# Save after initial analysis
context_file = save_exploit_context('/path/to/binary')
print(f"Saved to: {context_file}")

# ... conversation continues, context compacts ...

# Reload
print(print_exploit_context(context_file))

# Or load as dict
ctx = load_exploit_context(context_file)
system_offset = ctx['libc']['system_offset']
```

## Constraint Analysis Functions

### Input Handler Constraints

```python
from packages.exploit_feasibility import analyze_input_constraints

# What can/can't we do with strcpy on x86_64?
analysis = analyze_input_constraints('strcpy', 'x86_64')

print(f"Null byte position: {analysis.null_byte_position}")
print(f"Blocked: {analysis.blocked}")
print(f"Viable: {analysis.viable}")
```

Output:
```
Null byte position: 6
Blocked: ['Multi-gadget ROP chains', 'ret2libc with arguments']
Viable: ['Partial overwrite', 'Single gadget redirect', 'Format string (if available)']
```

### Bad Byte Impact

```python
from packages.exploit_feasibility import analyze_bad_byte_impact

# Can we write to .fini_array with strcpy?
impact = analyze_bad_byte_impact(
    target_name='.fini_array',
    address=0x00007fff12345678,
    bad_bytes=[0x00],
    technique='full_write',
    pointer_size=8
)

if impact.fatal:
    print(f"Cannot write: {impact.reason}")
elif impact.usable_via_partial:
    print(f"Can use partial overwrite ({impact.partial_bytes_needed} bytes)")
```

### Libc Fingerprinting

```python
from packages.exploit_feasibility import assess_libc_fingerprinting

# Can we identify the libc version from available symbols?
potential = assess_libc_fingerprinting(['puts', 'printf', 'malloc', 'free'])

print(f"Fingerprinting: {potential.feasibility}")  # good/limited/poor/none
print(f"Confidence: {potential.confidence}")
print(f"Symbols: {potential.unique_symbols}")
```

## Integration with /exploit Command

The `/exploit` command automatically runs feasibility analysis:

1. Finds vulnerabilities via /scan
2. **Runs feasibility analysis** (this package)
3. Filters techniques based on what's viable
4. Generates exploit using only working approaches

If you skip step 2, you'll waste time on impossible techniques.

## Empirical vs Theoretical

This package emphasizes **empirical verification**:

| Check | Theoretical | Empirical |
|-------|-------------|-----------|
| %n works? | Check glibc version | Actually try printf with %n |
| ASLR entropy | Read /proc/sys/kernel/randomize_va_space | Sample multiple addresses |
| ROP gadgets | Count total gadgets | Filter by bad bytes, count usable |
| Hooks available | Check glibc version | Check if symbols exist in nm output |

The empirical approach catches edge cases:
- Custom glibc builds with different flags
- Kernel configurations that override defaults
- Binary-specific constraints not visible statically

## Target Profiles (Remote, Web, Kernel)

The package supports different exploitation contexts via **target profiles**:

| Context | Use Case | What Changes |
|---------|----------|--------------|
| `LOCAL_BINARY` | CTF, local privesc | Full local detection (default) |
| `REMOTE_BINARY` | CTF remote, network service | Uses provided glibc, skips empirical tests |
| `WEB_APPLICATION` | SQLi, XSS, SSRF | Skips memory mitigations entirely |
| `KERNEL` | Kernel exploits, LPE | Checks SMEP, SMAP, KASLR, KPTI |

### Remote CTF Challenges

Your local system has glibc 2.42 (blocks %n), but the CTF challenge runs on Ubuntu 20.04 (glibc 2.31):

```python
from packages.exploit_feasibility import (
    FeasibilityAnalyzer,
    create_remote_profile,
)

# Create remote profile with known glibc version
profile = create_remote_profile(
    binary_path="./challenge",    # Local copy for checksec
    glibc_version="2.31",         # From challenge description
    host="pwn.ctf.com",
    port=1337,
)

analyzer = FeasibilityAnalyzer(profile=profile)
report = analyzer.full_analysis(vuln_type="format_string")

# Result uses glibc 2.31 constraints (not local 2.42)
# %n is NOT blocked! Format string write is viable.
print(report.glibc_n_disabled)  # False
```

### Unknown Remote glibc

If the remote glibc version is unknown:

```python
profile = create_remote_profile(
    binary_path="./challenge",
    host="pwn.ctf.com",
    port=1337,
    # glibc_version not specified
)

report = analyzer.full_analysis()
# Warning: "glibc version unknown - assuming modern mitigations"
# Suggests: "Leak libc address to fingerprint version"
```

### Web Application Vulnerabilities

For SQLi, XSS, SSRF, and other web vulnerabilities, memory mitigations are irrelevant:

```python
from packages.exploit_feasibility import create_web_profile, FeasibilityAnalyzer

profile = create_web_profile(url="https://target.com/api")
analyzer = FeasibilityAnalyzer(profile=profile)
report = analyzer.full_analysis(vuln_type="sql_injection")

# Skips all memory checks (NX, RELRO, %n, etc.)
# Returns: "Web app - check WAF, CSP, input validation"
print(report.context_notes)
# ['Memory corruption mitigations not applicable for web context.
#   Check: input validation, parameterized queries, CSP, CORS, authentication.']
```

### Kernel Exploitation

For kernel vulnerabilities, different mitigations apply:

```python
from packages.exploit_feasibility import create_kernel_profile, FeasibilityAnalyzer

profile = create_kernel_profile()
analyzer = FeasibilityAnalyzer(profile=profile)
report = analyzer.full_analysis(vuln_type="heap_overflow")

# Checks kernel mitigations
print(report.kernel_mitigations)
# {'kaslr': {'enabled': True, 'confidence': 'detected'},
#  'smep': {'enabled': True, 'cpu_supported': True},
#  'smap': {'enabled': True, 'cpu_supported': True},
#  'kpti': {'enabled': True, 'confidence': 'assumed'}, ...}
```

### Confidence Tracking

Reports track confidence for each finding:

```python
report = analyzer.full_analysis()

# Check confidence of findings
print(report.confidence)
# {'glibc_version': 'provided',       # User provided
#  'glibc_n_disabled': 'inferred',    # Calculated from version
#  'binary_protections': 'detected',  # From checksec
#  'pie': 'provided'}                 # User override
```

## Automatic Context Detection

The API **automatically selects the appropriate profile** based on vulnerability type. Web vulnerabilities skip memory mitigation checks entirely:

```python
from packages.exploit_feasibility import analyze_binary, check_exploit_viability

# Web vulnerability - automatically uses WebApplicationStrategy
# Skips ASLR, NX, RELRO, glibc checks (not applicable)
result = analyze_binary('/path/to/binary', vuln_type='sql_injection')
# Result includes context_notes: "Memory corruption mitigations not applicable..."

# Memory corruption - uses LocalBinaryStrategy (default)
result = analyze_binary('/path/to/binary', vuln_type='format_string_write')
# Result includes full glibc, RELRO, NX analysis
```

**Supported web vulnerability aliases:**
- SQL injection: `sql_injection`, `sqli`, `sql`
- XSS: `xss`, `cross_site_scripting`
- SSRF: `ssrf`, `server_side_request_forgery`
- Path traversal: `path_traversal`, `lfi`, `rfi`, `directory_traversal`
- Command injection: `command_injection`, `rce`, `os_command_injection`
- Others: `xxe`, `ssti`, `idor`, `csrf`, `open_redirect`, `deserialization`

For remote binaries with known glibc or kernel contexts, you still need to create profiles manually (see sections above).

## What This Package Does NOT Do

- Generate exploits (use `/exploit` for that)
- Find vulnerabilities (use `/scan` for that)
- Bypass mitigations (tells you what's blocked, not how to bypass)

It tells you **what's possible** so you don't waste time on **what's impossible**.
