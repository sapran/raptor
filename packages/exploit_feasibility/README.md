# Exploit Feasibility Package

Analyzes system and binary mitigations to determine if exploitation is actually feasible **before** attempting any exploit development. Saves hours of wasted effort on architecturally impossible approaches.

## Why This Exists

Traditional tools like `checksec` and `readelf` show **what protections exist** but not **what's actually possible**. This package answers:

- Can I actually write to that GOT entry? (Full RELRO blocks both GOT AND .fini_array)
- Will my ROP chain work with strcpy? (No - null bytes in x86_64 addresses)
- Does %n even work on this system? (glibc 2.38+ may block it)
- Are there enough usable gadgets? (Bad bytes may filter out most gadgets)

## Quick Start

```python
from packages.exploit_feasibility import analyze_binary, format_analysis_summary

# Full analysis
result = analyze_binary('/path/to/binary')
print(format_analysis_summary(result, verbose=True))

# Quick viability check
from packages.exploit_feasibility import check_exploit_viability
viable, reason = check_exploit_viability('/path/to/binary', 'format_string')
```

## Key Features

### 1. Empirical Verification
- Actually tests if %n works (doesn't just check glibc version)
- Detects input handlers and their bad byte constraints
- Samples address space for ASLR entropy

### 2. Constraint-Aware Analysis
- Null byte position analysis for different architectures
- Bad byte filtering of ROP gadgets
- Input handler impact on technique viability

### 3. Honest Verdicts
- **Likely exploitable**: Good primitives, clear path to code execution
- **Difficult**: Primitives exist but hard to chain
- **Unlikely**: No known viable path with current constraints

### 4. Context Persistence
Saves analysis to JSON file that survives conversation context compaction:

```python
from packages.exploit_feasibility import save_exploit_context, load_exploit_context

# Save (survives context compaction)
context_file = save_exploit_context('/path/to/binary')

# Reload later
ctx = load_exploit_context(context_file)
system_offset = ctx['libc']['system_offset']
```

## Architecture

```
packages/exploit_feasibility/
├── __init__.py          # Public API exports
├── api.py               # Public functions (analyze_binary, etc.)
├── analyzer.py          # FeasibilityAnalyzer, FeasibilityReport
├── context.py           # Dataclasses (BinaryContext, LibcInfo, ROPGadgetInfo)
├── constraints.py       # Input handler and bad byte analysis
├── primitives.py        # Primitive definitions and confidence scoring
├── techniques.py        # Technique requirements and lookups
├── mitigations.py       # Glibc/kernel mitigation tracking
├── graph.py             # Primitive dependency graph
├── targets.py           # Binary-specific target analysis
├── cache.py             # LRU caching for expensive operations
├── exploit_context.py   # Context persistence (save/load/print)
├── constants.py         # Magic numbers and thresholds
├── profiles.py          # Target profiles (local, remote, web, kernel)
├── strategies.py        # Context-aware analysis strategies
├── vuln_types.py        # Vulnerability type mappings
├── schema.py            # JSON schema for serialization
├── errors.py            # Structured error handling
├── config.py            # Runtime configuration
└── tests/               # 275 tests
    ├── test_api_functions.py
    ├── test_api_persistence.py
    ├── test_constraints.py
    ├── test_context.py
    ├── test_graph.py
    ├── test_integration.py
    ├── test_primitives.py
    ├── test_strategies.py
    └── test_techniques.py
```

## Output Example

```
EXPLOIT FEASIBILITY ANALYSIS
════════════════════════════════════════════════════════════════════════════════
Binary: /home/user/vuln
Verdict: Difficult

PROTECTIONS
────────────────────────────────────────
  PIE:        Yes (binary base randomized)
  NX:         Yes (no shellcode on stack)
  Canary:     Yes (stack smashing protection)
  RELRO:      Full (GOT and .fini_array read-only)

GLIBC MITIGATIONS (version 2.38)
────────────────────────────────────────
  __malloc_hook:     Removed (glibc 2.34+)
  __free_hook:       Removed (glibc 2.34+)
  %n specifier:      BLOCKED (tested empirically)

INPUT CONSTRAINTS
────────────────────────────────────────
  Handler:    strcpy
  Bad bytes:  0x00
  Impact:     Cannot write full x86_64 addresses (null at byte 6)

CHAIN BREAKS
────────────────────────────────────────
  ✗ GOT overwrite blocked by Full RELRO
  ✗ .fini_array blocked by Full RELRO
  ✗ Hook overwrite blocked (hooks removed in glibc 2.34+)
  ✗ Format string %n blocked by glibc
  ✗ Multi-gadget ROP blocked by null bytes in addresses

WHAT WOULD HELP
────────────────────────────────────────
  → Run in older environment (Docker with Ubuntu 20.04, glibc 2.31)
  → Find info leak to defeat ASLR
  → Look for one_gadget with satisfiable constraints
```

## Integration with RAPTOR

The package integrates with RAPTOR's workflow:

1. **After /scan**: Run feasibility analysis on identified vulnerabilities
2. **Before /exploit**: Check what techniques are actually viable
3. **Context persistence**: Reload analysis after context compaction

## API Reference

### Public Functions

| Function | Description |
|----------|-------------|
| `analyze_binary(path)` | Full feasibility analysis |
| `check_exploit_viability(path, vuln_type)` | Quick viability check |
| `get_exploit_constraints(arch, handler)` | Get constraints for architecture/handler |
| `format_analysis_summary(result)` | Human-readable summary |
| `save_exploit_context(path)` | Save context to JSON |
| `load_exploit_context(path)` | Load context from JSON |
| `print_exploit_context(path)` | Pretty-print saved context |

### Constraint Analysis

| Function | Description |
|----------|-------------|
| `analyze_input_constraints(handler, arch)` | What's blocked/viable for input handler |
| `analyze_bad_byte_impact(target, addr, bad_bytes)` | Can we write to this address? |
| `assess_libc_fingerprinting(symbols)` | Can we identify the libc version? |

### Profile System (Context-Aware Analysis)

The API auto-selects the appropriate analysis strategy based on vulnerability type:

```python
# Web vulnerabilities - skips memory mitigations (not applicable)
result = analyze_binary('/app', vuln_type='sql_injection')

# Memory corruption - full analysis (default)
result = analyze_binary('/app', vuln_type='format_string_write')
```

For remote targets with known glibc or kernel contexts:

```python
from packages.exploit_feasibility import create_remote_profile, FeasibilityAnalyzer

# Remote CTF with known glibc
profile = create_remote_profile(glibc_version="2.31")
analyzer = FeasibilityAnalyzer(profile=profile)
report = analyzer.full_analysis()
```

See `docs/exploit-feasibility.md` for full profile documentation.

## Testing

```bash
cd packages/exploit_feasibility
python -m pytest tests/ -v
```

All 275 tests should pass.

## Dependencies

- Python 3.9+
- `pwntools` (for binary analysis)
- `ROPgadget` (for gadget enumeration)
- `one_gadget` (optional, for one-gadget detection)
- `checksec` (optional, for binary protection detection)
