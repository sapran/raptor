#!/usr/bin/env python3
"""
JSON Schema validation for exploit context files.

Provides validation for serialized ExploitContext and FeasibilityReport data.
"""

from typing import Any, Dict, List, Tuple
import json


# JSON Schema for ExploitContext/FeasibilityReport context files
CONTEXT_SCHEMA = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "properties": {
        # Libc information
        "libc": {
            "type": "object",
            "properties": {
                "path": {"type": "string"},
                "version": {"type": "string"},
                "version_float": {"type": "number"},
                "hooks_available": {"type": "boolean"},
                "system_offset": {"type": ["integer", "null"]},
                "execve_offset": {"type": ["integer", "null"]},
                "bin_sh_offset": {"type": ["integer", "null"]},
                "malloc_hook_offset": {"type": ["integer", "null"]},
                "free_hook_offset": {"type": ["integer", "null"]},
                "one_gadgets": {
                    "type": "array",
                    "items": {"type": "integer"}
                },
            },
        },
        # Binary protections
        "binary": {
            "type": "object",
            "properties": {
                "path": {"type": "string"},
                "arch": {"type": "string"},
                "protections": {
                    "type": "object",
                    "properties": {
                        "relro": {"type": "boolean"},
                        "full_relro": {"type": "boolean"},
                        "pie": {"type": "boolean"},
                        "nx": {"type": "boolean"},
                        "canary": {"type": "boolean"},
                        "fortify": {"type": "boolean"},
                    },
                },
                "sections": {
                    "type": "object",
                    "properties": {
                        "got_plt_addr": {"type": ["integer", "null"]},
                        "fini_array_addr": {"type": ["integer", "null"]},
                        "bss_addr": {"type": ["integer", "null"]},
                    },
                },
                "got_entries": {
                    "type": "object",
                    "additionalProperties": {"type": "integer"}
                },
                "input_handlers": {
                    "type": "array",
                    "items": {"type": "string"}
                },
            },
        },
        # ROP gadget information
        "rop": {
            "type": "object",
            "properties": {
                "total_gadgets": {"type": "integer", "minimum": 0},
                "usable_gadgets": {"type": "integer", "minimum": 0},
                "filtered_count": {"type": "integer", "minimum": 0},
                "pop_rdi_ret": {"type": ["integer", "null"]},
                "pop_rsi_ret": {"type": ["integer", "null"]},
                "pop_rdx_ret": {"type": ["integer", "null"]},
                "pop_rax_ret": {"type": ["integer", "null"]},
                "syscall_ret": {"type": ["integer", "null"]},
                "ret": {"type": ["integer", "null"]},
            },
        },
        # Kernel information
        "kernel": {
            "type": "object",
            "properties": {
                "aslr": {"type": "integer", "minimum": 0, "maximum": 2},
                "version": {"type": "string"},
            },
        },
        # Payload constraints
        "payload": {
            "type": "object",
            "properties": {
                "bad_bytes": {
                    "type": "array",
                    "items": {"type": "integer", "minimum": 0, "maximum": 255}
                },
                "input_handler": {"type": "string"},
            },
        },
        # Address space sampling
        "address_space": {
            "type": "object",
            "properties": {
                "binary_base": {"type": ["integer", "null"]},
                "libc_base": {"type": ["integer", "null"]},
                "stack_sample": {"type": ["integer", "null"]},
                "heap_sample": {"type": ["integer", "null"]},
            },
        },
        # Write targets
        "write_targets": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "name": {"type": "string"},
                    "address": {"type": "integer"},
                    "priority": {"type": "integer"},
                    "has_bad_bytes": {"type": "boolean"},
                    "blocked_by": {
                        "type": "array",
                        "items": {"type": "string"}
                    },
                },
                "required": ["name", "address"],
            },
        },
        # Verdict and analysis
        "verdict": {"type": "string", "enum": ["exploitable", "likely_exploitable", "difficult", "unlikely", "unknown"]},
        "blockers": {
            "type": "array",
            "items": {"type": "string"}
        },
        "warnings": {
            "type": "array",
            "items": {"type": "string"}
        },
        # Metadata
        "_metadata": {
            "type": "object",
            "properties": {
                "version": {"type": "string"},
                "timestamp": {"type": "string"},
                "sources": {
                    "type": "object",
                    "additionalProperties": {"type": "string"}
                },
            },
        },
    },
}


def validate_context(data: Dict[str, Any]) -> Tuple[bool, List[str]]:
    """
    Validate a context dictionary against the schema.

    Args:
        data: Dictionary to validate

    Returns:
        Tuple of (is_valid, list of error messages)
    """
    errors = []

    # Basic type check
    if not isinstance(data, dict):
        return False, ["Context must be a dictionary"]

    # Validate libc section
    if "libc" in data:
        libc = data["libc"]
        if not isinstance(libc, dict):
            errors.append("libc must be a dictionary")
        else:
            # Check offset types
            for key in ["system_offset", "execve_offset", "bin_sh_offset",
                       "malloc_hook_offset", "free_hook_offset"]:
                if key in libc and libc[key] is not None:
                    if not isinstance(libc[key], int):
                        errors.append(f"libc.{key} must be an integer or null")

            # Check version_float
            if "version_float" in libc:
                if not isinstance(libc["version_float"], (int, float)):
                    errors.append("libc.version_float must be a number")

            # Check one_gadgets array
            if "one_gadgets" in libc:
                if not isinstance(libc["one_gadgets"], list):
                    errors.append("libc.one_gadgets must be an array")
                elif not all(isinstance(x, int) for x in libc["one_gadgets"]):
                    errors.append("libc.one_gadgets must contain only integers")

    # Validate binary section
    if "binary" in data:
        binary = data["binary"]
        if not isinstance(binary, dict):
            errors.append("binary must be a dictionary")
        else:
            # Check protections
            if "protections" in binary:
                prots = binary["protections"]
                if not isinstance(prots, dict):
                    errors.append("binary.protections must be a dictionary")
                else:
                    for key in ["relro", "full_relro", "pie", "nx", "canary", "fortify"]:
                        if key in prots and not isinstance(prots[key], bool):
                            errors.append(f"binary.protections.{key} must be a boolean")

    # Validate rop section
    if "rop" in data:
        rop = data["rop"]
        if not isinstance(rop, dict):
            errors.append("rop must be a dictionary")
        else:
            for key in ["total_gadgets", "usable_gadgets", "filtered_count"]:
                if key in rop:
                    if not isinstance(rop[key], int) or rop[key] < 0:
                        errors.append(f"rop.{key} must be a non-negative integer")

    # Validate payload section
    if "payload" in data:
        payload = data["payload"]
        if not isinstance(payload, dict):
            errors.append("payload must be a dictionary")
        else:
            if "bad_bytes" in payload:
                if not isinstance(payload["bad_bytes"], list):
                    errors.append("payload.bad_bytes must be an array")
                else:
                    for i, byte in enumerate(payload["bad_bytes"]):
                        if not isinstance(byte, int) or byte < 0 or byte > 255:
                            errors.append(f"payload.bad_bytes[{i}] must be 0-255")

    # Validate write_targets
    if "write_targets" in data:
        targets = data["write_targets"]
        if not isinstance(targets, list):
            errors.append("write_targets must be an array")
        else:
            for i, target in enumerate(targets):
                if not isinstance(target, dict):
                    errors.append(f"write_targets[{i}] must be a dictionary")
                else:
                    if "name" not in target:
                        errors.append(f"write_targets[{i}] missing required 'name'")
                    if "address" not in target:
                        errors.append(f"write_targets[{i}] missing required 'address'")
                    elif not isinstance(target["address"], int):
                        errors.append(f"write_targets[{i}].address must be an integer")

    # Validate verdict
    if "verdict" in data:
        valid_verdicts = ["exploitable", "likely_exploitable", "difficult", "unlikely", "unknown"]
        if data["verdict"] not in valid_verdicts:
            errors.append(f"verdict must be one of: {', '.join(valid_verdicts)}")

    return len(errors) == 0, errors


def validate_context_file(path: str) -> Tuple[bool, List[str]]:
    """
    Validate a context JSON file.

    Args:
        path: Path to JSON file

    Returns:
        Tuple of (is_valid, list of error messages)
    """
    try:
        with open(path, 'r') as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        return False, [f"Invalid JSON: {e}"]
    except FileNotFoundError:
        return False, [f"File not found: {path}"]
    except Exception as e:
        return False, [f"Error reading file: {e}"]

    return validate_context(data)


def get_schema() -> Dict[str, Any]:
    """Return the full JSON schema for context files."""
    return CONTEXT_SCHEMA.copy()
