#!/usr/bin/env python3
"""
Exploitation primitives and their dependencies.

Primitives are building blocks that chain together to achieve exploitation goals:
- Vulnerabilities (starting points): stack_overflow_vuln, format_string_vuln
- Capabilities (intermediate): libc_leak, arbitrary_write
- Goals (end states): code_execution, info_disclosure

Example chain: format_string_vuln -> libc_leak -> ret2libc -> code_execution
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set, Tuple

from .constants import Reliability, ConfidenceAdjustment


class PrimitiveID(str, Enum):
    """
    Typed identifiers for all exploitation primitives.

    Using an enum provides:
    - Type safety and IDE autocompletion
    - Prevention of typos in primitive names
    - Clear documentation of available primitives

    Example:
        >>> PrimitiveID.FORMAT_STRING_VULN.value
        'format_string_vuln'
        >>> PrimitiveID.LIBC_LEAK in available_primitives
        True
    """
    # Vulnerabilities (starting points)
    STACK_OVERFLOW_VULN = "stack_overflow_vuln"
    FORMAT_STRING_VULN = "format_string_vuln"
    HEAP_OVERFLOW_VULN = "heap_overflow_vuln"
    USE_AFTER_FREE_VULN = "use_after_free_vuln"
    DOUBLE_FREE_VULN = "double_free_vuln"
    ARBITRARY_READ_VULN = "arbitrary_read_vuln"

    # Information leaks
    FORMAT_STRING_READ = "format_string_read"
    LIBC_LEAK = "libc_leak"
    STACK_LEAK = "stack_leak"
    PIE_LEAK = "pie_leak"
    HEAP_LEAK = "heap_leak"
    CANARY_LEAK = "canary_leak"

    # Write primitives
    FORMAT_STRING_WRITE = "format_string_write"
    ARBITRARY_WRITE = "arbitrary_write"
    TCACHE_POISON = "tcache_poison"

    # Code execution techniques
    RET2LIBC = "ret2libc"
    ROP_CHAIN = "rop_chain"
    GOT_OVERWRITE_TO_EXEC = "got_overwrite_to_exec"
    HOOK_OVERWRITE = "hook_overwrite"
    EXIT_FUNCS_OVERWRITE = "exit_funcs_overwrite"
    FSOP = "fsop"

    # Goals
    CODE_EXECUTION = "code_execution"
    INFO_DISCLOSURE = "info_disclosure"
    DENIAL_OF_SERVICE = "denial_of_service"

    # Kernel exploitation primitives
    KERNEL_ARBITRARY_READ = "kernel_arbitrary_read"
    KERNEL_ARBITRARY_WRITE = "kernel_arbitrary_write"
    KERNEL_ADDR_LEAK = "kernel_addr_leak"
    KERNEL_ROP = "kernel_rop"
    RET2USR = "ret2usr"
    MODPROBE_PATH_OVERWRITE = "modprobe_path_overwrite"
    CRED_OVERWRITE = "cred_overwrite"
    ROOT_PRIVILEGES = "root_privileges"


class PrimitiveType(str, Enum):
    """Type of primitive in the exploitation chain."""
    VULNERABILITY = "vulnerability"  # Starting point
    CAPABILITY = "capability"        # Intermediate step
    GOAL = "goal"                    # End state


class MitigationID(str, Enum):
    """
    Typed identifiers for mitigations.

    Example:
        >>> MitigationID.FULL_RELRO.value
        'full_relro'
    """
    # Binary protections
    FULL_RELRO = "full_relro"
    PARTIAL_RELRO = "partial_relro"
    PIE = "pie"
    NX = "nx"
    STACK_CANARY = "stack_canary"
    FORTIFY_SOURCE = "fortify_source"

    # Glibc mitigations
    GLIBC_N_DISABLED = "glibc_n_disabled"
    GLIBC_HOOKS_REMOVED = "glibc_hooks_removed"
    GLIBC_NO_TCACHE = "glibc_no_tcache"
    SAFE_LINKING = "safe_linking"
    TCACHE_KEY = "tcache_key"
    POINTER_MANGLING = "pointer_mangling"
    VTABLE_VERIFICATION = "vtable_verification"

    # Runtime protections
    ASLR = "aslr"
    ASAN = "asan"
    CET = "cet"
    SAFE_FUNCTIONS = "safe_functions"

    # Kernel mitigations
    KASLR = "kaslr"
    SMEP = "smep"
    SMAP = "smap"
    KPTI = "kpti"
    KERNEL_LOCKDOWN = "kernel_lockdown"
    SELINUX = "selinux"


@dataclass
class Primitive:
    """
    An exploitation primitive - a building block for exploit chains.

    Primitives are either:
    - Vulnerability types (starting points): stack_overflow_vuln, format_string_vuln
    - Capabilities (intermediate): libc_leak, arbitrary_write, pie_leak
    - Goals (end states): code_execution, arbitrary_read, dos

    Example:
        >>> p = Primitive(
        ...     name="libc_leak",
        ...     description="Leaked libc address",
        ...     provides=["libc_base_known", "system_addr"],
        ...     requires_any=["format_string_read", "got_read"],
        ... )
        >>> p.is_achievable({"format_string_read"}, set())
        True
    """
    name: str
    description: str

    # What this primitive provides when achieved
    provides: List[str] = field(default_factory=list)

    # What's needed to achieve this primitive
    requires: List[str] = field(default_factory=list)      # ALL must be satisfied
    requires_any: List[str] = field(default_factory=list)  # At least ONE

    # What completely blocks this primitive
    blocked_by: List[str] = field(default_factory=list)

    # What makes it harder but not impossible
    complicated_by: List[str] = field(default_factory=list)

    # Categorization
    primitive_type: PrimitiveType = PrimitiveType.CAPABILITY

    # Reliability (0-100) - how often this works when conditions are met
    reliability: int = Reliability.HIGH

    # Notes for exploit developer
    notes: str = ""

    def is_achievable(self, available: Set[str], blocked: Set[str]) -> bool:
        """
        Check if this primitive can be achieved given current state.

        Args:
            available: Set of available primitives/capabilities
            blocked: Set of active mitigations that block primitives

        Returns:
            True if primitive can be achieved

        Example:
            >>> p = Primitive("test", "", requires=["a"], blocked_by=["x"])
            >>> p.is_achievable({"a", "b"}, set())
            True
            >>> p.is_achievable({"a"}, {"x"})
            False
        """
        # Check not blocked
        if any(b in blocked for b in self.blocked_by):
            return False
        # Check all requirements met
        if not all(r in available for r in self.requires):
            return False
        # Check at least one alternative requirement met (if any)
        if self.requires_any and not any(r in available for r in self.requires_any):
            return False
        return True

    def get_missing_requirements(self, available: Set[str]) -> List[str]:
        """
        Get list of requirements not yet available.

        Example:
            >>> p = Primitive("test", "", requires=["a", "b"], requires_any=["x", "y"])
            >>> p.get_missing_requirements({"a"})
            ['b', 'one_of(x, y)']
        """
        missing = [r for r in self.requires if r not in available]
        if self.requires_any and not any(r in available for r in self.requires_any):
            missing.append(f"one_of({', '.join(self.requires_any)})")
        return missing


@dataclass
class ConfidenceScore:
    """
    Detailed confidence assessment with reasoning.

    The agent uses this to understand WHY a path has a certain confidence level,
    not just the number. This enables better decision-making.

    Example:
        >>> score = ConfidenceScore.from_reliability(85, ["stack_canary", "aslr"])
        >>> score.level
        'medium'
        >>> len(score.adjustments) > 0
        True
    """
    score: float  # 0-100 percentage
    level: str    # "high", "medium", "low", "very_low"
    reasoning: List[str] = field(default_factory=list)
    adjustments: List[Tuple[str, float]] = field(default_factory=list)
    base_reliability: float = 100.0

    @staticmethod
    def from_reliability(reliability: float, complications: List[str] = None) -> 'ConfidenceScore':
        """
        Create confidence score from raw reliability and complications.

        Args:
            reliability: Base reliability percentage (0-100)
            complications: List of active mitigations that complicate exploitation

        Returns:
            ConfidenceScore with adjusted score and reasoning
        """
        complications = complications or []

        # Determine level
        if reliability >= Reliability.THRESHOLD_HIGH:
            level = "high"
        elif reliability >= Reliability.THRESHOLD_MEDIUM:
            level = "medium"
        elif reliability >= Reliability.THRESHOLD_LOW:
            level = "low"
        else:
            level = "very_low"

        reasoning = []
        adjustments = []

        # Base reasoning
        if reliability >= Reliability.THRESHOLD_HIGH:
            reasoning.append("High base reliability from well-understood primitives")
        elif reliability >= Reliability.THRESHOLD_MEDIUM:
            reasoning.append("Moderate reliability - some steps may need tuning")
        else:
            reasoning.append("Lower reliability - multiple complex/unreliable steps")

        # Adjustments for complications using constants
        adjustment_map = {
            "stack_canary": (ConfidenceAdjustment.STACK_CANARY, "Stack canary requires leak/bypass"),
            "aslr": (ConfidenceAdjustment.ASLR, "ASLR requires address leak"),
            "pie": (ConfidenceAdjustment.PIE, "PIE requires binary base leak"),
            "safe_linking": (ConfidenceAdjustment.SAFE_LINKING, "Safe-linking heap hardening"),
            "tcache_key": (ConfidenceAdjustment.TCACHE_KEY, "tcache_key heap hardening"),
            "fortify_source": (ConfidenceAdjustment.FORTIFY_SOURCE, "FORTIFY_SOURCE may catch overflow"),
            "pointer_mangling": (ConfidenceAdjustment.POINTER_MANGLING, "Pointer mangling needs ptr_guard leak"),
            "vtable_verification": (ConfidenceAdjustment.VTABLE_VERIFICATION, "Vtable checks need FSOP bypass"),
        }

        for comp in complications:
            if comp in adjustment_map:
                delta, reason = adjustment_map[comp]
                adjustments.append((reason, delta))
                reasoning.append(f"{comp.replace('_', ' ').title()} present")

        # Calculate final score
        final_score = reliability
        for reason, delta in adjustments:
            final_score += delta
        final_score = max(0, min(100, final_score))

        return ConfidenceScore(
            score=final_score,
            level=level,
            reasoning=reasoning,
            adjustments=adjustments,
            base_reliability=reliability
        )

    def summary(self) -> str:
        """Human-readable summary."""
        lines = [f"CONFIDENCE: {self.score:.0f}% ({self.level.upper()})"]
        if self.reasoning:
            lines.append("  Reasoning:")
            for r in self.reasoning[:3]:
                lines.append(f"    - {r}")
        if self.adjustments:
            lines.append("  Adjustments:")
            for reason, delta in self.adjustments[:3]:
                sign = "+" if delta > 0 else ""
                lines.append(f"    {sign}{delta:.0f}%: {reason}")
        return "\n".join(lines)


@dataclass
class ExploitPath:
    """
    A viable path from vulnerability to goal.

    The agent uses this to understand what sequence of steps is needed.

    Example:
        >>> path = ExploitPath(
        ...     goal="code_execution",
        ...     steps=["format_string_vuln", "libc_leak", "ret2libc"],
        ...     total_reliability=85.0
        ... )
        >>> path.summary()  # doctest: +ELLIPSIS
        'PATH TO code_execution:...'
    """
    goal: str
    steps: List[str] = field(default_factory=list)
    total_reliability: float = 100.0
    blocked_mitigations: List[str] = field(default_factory=list)
    complicating_mitigations: List[str] = field(default_factory=list)
    notes: List[str] = field(default_factory=list)
    confidence: Optional[ConfidenceScore] = None

    def compute_confidence(self) -> ConfidenceScore:
        """Compute detailed confidence score with reasoning."""
        self.confidence = ConfidenceScore.from_reliability(
            self.total_reliability,
            self.complicating_mitigations
        )
        return self.confidence

    def summary(self) -> str:
        """Human-readable summary of the path."""
        lines = [f"PATH TO {self.goal}:"]
        lines.append(f"  Steps: {' -> '.join(self.steps)}")
        lines.append(f"  Reliability: {self.total_reliability:.0f}%")
        if self.confidence:
            lines.append(f"  Confidence: {self.confidence.score:.0f}% ({self.confidence.level})")
        if self.blocked_mitigations:
            lines.append(f"  Would block: {', '.join(self.blocked_mitigations)}")
        if self.complicating_mitigations:
            lines.append(f"  Complicates: {', '.join(self.complicating_mitigations)}")
        return "\n".join(lines)


# =============================================================================
# PRIMITIVE DEFINITIONS
# =============================================================================

def get_primitive_definitions() -> Dict[str, Primitive]:
    """
    Get all primitive definitions.

    Returns a fresh copy to prevent mutation issues.

    Example:
        >>> primitives = get_primitive_definitions()
        >>> 'format_string_vuln' in primitives
        True
        >>> primitives['libc_leak'].primitive_type
        <PrimitiveType.CAPABILITY: 'capability'>
    """
    return {
        # ─────────────────────────────────────────────────────────────────────
        # STARTING VULNERABILITIES
        # ─────────────────────────────────────────────────────────────────────
        PrimitiveID.STACK_OVERFLOW_VULN.value: Primitive(
            name=PrimitiveID.STACK_OVERFLOW_VULN.value,
            description="Stack buffer overflow allowing overwrite past buffer",
            provides=["stack_control", "can_overwrite_ret_addr"],
            requires=[],
            blocked_by=[MitigationID.SAFE_FUNCTIONS.value],
            complicated_by=[MitigationID.STACK_CANARY.value, MitigationID.FORTIFY_SOURCE.value],
            primitive_type=PrimitiveType.VULNERABILITY,
            reliability=Reliability.VERY_HIGH,
            notes="Foundation for ROP/ret2libc. Canary means need leak first.",
        ),

        PrimitiveID.FORMAT_STRING_VULN.value: Primitive(
            name=PrimitiveID.FORMAT_STRING_VULN.value,
            description="User-controlled format string to printf-family function",
            provides=["format_string_read", "format_string_write_potential"],
            requires=[],
            blocked_by=[],
            complicated_by=[],
            primitive_type=PrimitiveType.VULNERABILITY,
            reliability=Reliability.VERY_HIGH,
            notes="Gives read (%p/%s) always. Write (%n) depends on glibc version.",
        ),

        PrimitiveID.HEAP_OVERFLOW_VULN.value: Primitive(
            name=PrimitiveID.HEAP_OVERFLOW_VULN.value,
            description="Heap buffer overflow allowing metadata/adjacent chunk corruption",
            provides=["heap_write_primitive"],
            requires=[],
            blocked_by=[],
            complicated_by=["heap_hardening"],
            primitive_type=PrimitiveType.VULNERABILITY,
            reliability=Reliability.MEDIUM_HIGH,
            notes="Enables tcache/fastbin attacks. May need heap leak for safe-linking.",
        ),

        PrimitiveID.USE_AFTER_FREE_VULN.value: Primitive(
            name=PrimitiveID.USE_AFTER_FREE_VULN.value,
            description="Access to freed memory chunk",
            provides=["heap_write_primitive", "heap_read_primitive"],
            requires=[],
            blocked_by=[MitigationID.ASAN.value],
            complicated_by=["heap_hardening", MitigationID.SAFE_LINKING.value],
            primitive_type=PrimitiveType.VULNERABILITY,
            reliability=Reliability.MEDIUM_HIGH,
            notes="Type confusion enables both read and write. Very powerful.",
        ),

        PrimitiveID.DOUBLE_FREE_VULN.value: Primitive(
            name=PrimitiveID.DOUBLE_FREE_VULN.value,
            description="Ability to free same chunk twice",
            provides=["tcache_dup_potential", "fastbin_dup_potential"],
            requires=[],
            blocked_by=[MitigationID.TCACHE_KEY.value],
            complicated_by=["heap_hardening"],
            primitive_type=PrimitiveType.VULNERABILITY,
            reliability=Reliability.MEDIUM_LOW,
            notes="Classic double-free mostly patched. Need UAF-based variants.",
        ),

        PrimitiveID.ARBITRARY_READ_VULN.value: Primitive(
            name=PrimitiveID.ARBITRARY_READ_VULN.value,
            description="Direct arbitrary memory read primitive",
            provides=["libc_leak", "pie_leak", "stack_leak", "heap_leak", "canary_leak"],
            requires=[],
            blocked_by=[],
            complicated_by=[MitigationID.ASLR.value],
            primitive_type=PrimitiveType.VULNERABILITY,
            reliability=Reliability.VERY_HIGH,
            notes="Skip the leak step - go straight to exploitation.",
        ),

        # ─────────────────────────────────────────────────────────────────────
        # INFORMATION LEAKS
        # ─────────────────────────────────────────────────────────────────────
        PrimitiveID.FORMAT_STRING_READ.value: Primitive(
            name=PrimitiveID.FORMAT_STRING_READ.value,
            description="Use %p/%s/%x to leak stack/heap/libc addresses",
            provides=["libc_leak", "stack_leak", "pie_leak", "canary_leak"],
            requires=[PrimitiveID.FORMAT_STRING_VULN.value],
            blocked_by=[],
            complicated_by=[],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.VERY_HIGH,
            notes="Use %p to dump stack, find return addresses, leaked pointers.",
        ),

        PrimitiveID.LIBC_LEAK.value: Primitive(
            name=PrimitiveID.LIBC_LEAK.value,
            description="Leaked libc address - can calculate system(), /bin/sh, gadgets",
            provides=["libc_base_known", "system_addr", "binsh_addr", "one_gadget_addr"],
            requires=[],
            requires_any=["format_string_read", "got_read", "heap_leak_to_libc",
                         PrimitiveID.ARBITRARY_READ_VULN.value],
            blocked_by=[],
            complicated_by=[MitigationID.ASLR.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.VERY_HIGH,
            notes="Essential for ret2libc. Leak GOT entry or return address.",
        ),

        PrimitiveID.STACK_LEAK.value: Primitive(
            name=PrimitiveID.STACK_LEAK.value,
            description="Leaked stack address - can calculate return address location",
            provides=["stack_base_known", "ret_addr_location"],
            requires=[],
            requires_any=["format_string_read", PrimitiveID.ARBITRARY_READ_VULN.value],
            blocked_by=[],
            complicated_by=[MitigationID.ASLR.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Needed for format string ret addr overwrite or stack pivot.",
        ),

        PrimitiveID.PIE_LEAK.value: Primitive(
            name=PrimitiveID.PIE_LEAK.value,
            description="Leaked binary base address - can calculate GOT/PLT/gadgets",
            provides=["binary_base_known", "got_addrs", "binary_gadgets"],
            requires=[],
            requires_any=["format_string_read", PrimitiveID.ARBITRARY_READ_VULN.value],
            blocked_by=[],
            complicated_by=[MitigationID.PIE.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Needed for binary ROP gadgets or GOT read/write with PIE.",
        ),

        PrimitiveID.HEAP_LEAK.value: Primitive(
            name=PrimitiveID.HEAP_LEAK.value,
            description="Leaked heap address - can calculate chunk locations, safe-linking",
            provides=["heap_base_known", "safe_linking_bypass"],
            requires=[],
            requires_any=["format_string_read", "uaf_read", PrimitiveID.ARBITRARY_READ_VULN.value],
            blocked_by=[],
            complicated_by=[MitigationID.ASLR.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM_HIGH,
            notes="Essential for safe-linking bypass (XOR key). Also for house techniques.",
        ),

        PrimitiveID.CANARY_LEAK.value: Primitive(
            name=PrimitiveID.CANARY_LEAK.value,
            description="Leaked stack canary value - can bypass stack protector",
            provides=["canary_known"],
            requires=[],
            requires_any=["format_string_read", "byte_by_byte_brute",
                         PrimitiveID.ARBITRARY_READ_VULN.value],
            blocked_by=[],
            complicated_by=[MitigationID.STACK_CANARY.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM_HIGH,
            notes="Format string can leak canary from stack. Enables BOF exploitation.",
        ),

        # ─────────────────────────────────────────────────────────────────────
        # WRITE PRIMITIVES
        # ─────────────────────────────────────────────────────────────────────
        PrimitiveID.FORMAT_STRING_WRITE.value: Primitive(
            name=PrimitiveID.FORMAT_STRING_WRITE.value,
            description="Use %n to write arbitrary values to memory",
            provides=["arbitrary_write_limited"],
            requires=[PrimitiveID.FORMAT_STRING_VULN.value],
            blocked_by=[MitigationID.GLIBC_N_DISABLED.value],
            complicated_by=[MitigationID.FULL_RELRO.value, MitigationID.PIE.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM,
            notes="Powerful but slow. Modern glibc disables %n. Check runtime!",
        ),

        PrimitiveID.ARBITRARY_WRITE.value: Primitive(
            name=PrimitiveID.ARBITRARY_WRITE.value,
            description="Ability to write controlled value to controlled address",
            provides=["can_corrupt_memory"],
            requires=[],
            requires_any=["format_string_write", "tcache_poison", "fastbin_attack",
                         "heap_write_primitive", PrimitiveID.STACK_OVERFLOW_VULN.value],
            blocked_by=[],
            complicated_by=[],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="The holy grail. Many paths lead here. Then pick a target.",
        ),

        PrimitiveID.TCACHE_POISON.value: Primitive(
            name=PrimitiveID.TCACHE_POISON.value,
            description="Corrupt tcache fd pointer for arbitrary allocation",
            provides=["arbitrary_write"],
            requires=["heap_write_primitive"],
            requires_any=[PrimitiveID.HEAP_OVERFLOW_VULN.value, PrimitiveID.USE_AFTER_FREE_VULN.value],
            blocked_by=[MitigationID.GLIBC_NO_TCACHE.value],
            complicated_by=[MitigationID.SAFE_LINKING.value, MitigationID.TCACHE_KEY.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM,
            notes="Safe-linking (2.32+) needs heap leak to XOR. Key check needs bypass.",
        ),

        # ─────────────────────────────────────────────────────────────────────
        # CODE EXECUTION TECHNIQUES
        # ─────────────────────────────────────────────────────────────────────
        PrimitiveID.RET2LIBC.value: Primitive(
            name=PrimitiveID.RET2LIBC.value,
            description="Return to system('/bin/sh') or one_gadget",
            provides=["code_execution"],
            requires=[PrimitiveID.LIBC_LEAK.value],
            requires_any=["stack_control", "arbitrary_write"],
            blocked_by=[],
            complicated_by=[MitigationID.STACK_CANARY.value, MitigationID.ASLR.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Classic technique. Need pop rdi gadget + ret for alignment.",
        ),

        PrimitiveID.ROP_CHAIN.value: Primitive(
            name=PrimitiveID.ROP_CHAIN.value,
            description="Chain gadgets for execve syscall or mprotect+shellcode",
            provides=["code_execution"],
            requires=["stack_control"],
            requires_any=[PrimitiveID.LIBC_LEAK.value, PrimitiveID.PIE_LEAK.value],
            blocked_by=[],
            complicated_by=[MitigationID.STACK_CANARY.value, MitigationID.ASLR.value, MitigationID.CET.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM_HIGH,
            notes="More powerful than ret2libc but needs more gadgets.",
        ),

        PrimitiveID.GOT_OVERWRITE_TO_EXEC.value: Primitive(
            name=PrimitiveID.GOT_OVERWRITE_TO_EXEC.value,
            description="Overwrite GOT entry with system/one_gadget, trigger call",
            provides=["code_execution"],
            requires=["arbitrary_write", PrimitiveID.LIBC_LEAK.value],
            blocked_by=[MitigationID.FULL_RELRO.value],
            complicated_by=[MitigationID.PIE.value, MitigationID.PARTIAL_RELRO.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="High reliability if GOT writable. Partial RELRO still works.",
        ),

        PrimitiveID.HOOK_OVERWRITE.value: Primitive(
            name=PrimitiveID.HOOK_OVERWRITE.value,
            description="Overwrite __malloc_hook/__free_hook with one_gadget",
            provides=["code_execution"],
            requires=["arbitrary_write", PrimitiveID.LIBC_LEAK.value],
            blocked_by=[MitigationID.GLIBC_HOOKS_REMOVED.value],
            complicated_by=[],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.VERY_HIGH,
            notes="Classic and reliable. Removed in modern glibc.",
        ),

        PrimitiveID.EXIT_FUNCS_OVERWRITE.value: Primitive(
            name=PrimitiveID.EXIT_FUNCS_OVERWRITE.value,
            description="Overwrite __exit_funcs for exit handler hijack",
            provides=["code_execution"],
            requires=["arbitrary_write", PrimitiveID.LIBC_LEAK.value],
            blocked_by=[],
            complicated_by=[MitigationID.POINTER_MANGLING.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM,
            notes="Need ptr_guard leak for pointer mangling. Complex but modern.",
        ),

        PrimitiveID.FSOP.value: Primitive(
            name=PrimitiveID.FSOP.value,
            description="File Stream Oriented Programming - corrupt FILE structures",
            provides=["code_execution"],
            requires=["arbitrary_write", PrimitiveID.LIBC_LEAK.value],
            blocked_by=[],
            complicated_by=[MitigationID.VTABLE_VERIFICATION.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM_LOW,
            notes="Powerful technique. Vtable checks (2.24+) need bypass.",
        ),

        # ─────────────────────────────────────────────────────────────────────
        # GOALS
        # ─────────────────────────────────────────────────────────────────────
        PrimitiveID.CODE_EXECUTION.value: Primitive(
            name=PrimitiveID.CODE_EXECUTION.value,
            description="Arbitrary code execution achieved",
            provides=[],
            requires=[],
            requires_any=[PrimitiveID.RET2LIBC.value, PrimitiveID.ROP_CHAIN.value,
                         PrimitiveID.GOT_OVERWRITE_TO_EXEC.value, PrimitiveID.HOOK_OVERWRITE.value,
                         PrimitiveID.EXIT_FUNCS_OVERWRITE.value, PrimitiveID.FSOP.value,
                         "shellcode_exec"],
            blocked_by=[],
            complicated_by=[],
            primitive_type=PrimitiveType.GOAL,
            reliability=100,
            notes="The goal. Many paths lead here.",
        ),

        PrimitiveID.INFO_DISCLOSURE.value: Primitive(
            name=PrimitiveID.INFO_DISCLOSURE.value,
            description="Sensitive information leaked",
            provides=[],
            requires=[],
            requires_any=[PrimitiveID.LIBC_LEAK.value, PrimitiveID.STACK_LEAK.value,
                         PrimitiveID.HEAP_LEAK.value, PrimitiveID.CANARY_LEAK.value,
                         PrimitiveID.ARBITRARY_READ_VULN.value],
            blocked_by=[],
            complicated_by=[],
            primitive_type=PrimitiveType.GOAL,
            reliability=100,
            notes="May be the end goal for some vulnerabilities (not code exec).",
        ),

        PrimitiveID.DENIAL_OF_SERVICE.value: Primitive(
            name=PrimitiveID.DENIAL_OF_SERVICE.value,
            description="Crash or hang the target",
            provides=[],
            requires=[],
            requires_any=[PrimitiveID.STACK_OVERFLOW_VULN.value, PrimitiveID.HEAP_OVERFLOW_VULN.value,
                         PrimitiveID.FORMAT_STRING_VULN.value, PrimitiveID.DOUBLE_FREE_VULN.value,
                         PrimitiveID.USE_AFTER_FREE_VULN.value],
            blocked_by=[],
            complicated_by=[],
            primitive_type=PrimitiveType.GOAL,
            reliability=100,
            notes="Trivial to achieve with any memory corruption. Usually not interesting.",
        ),

        # ─────────────────────────────────────────────────────────────────────
        # KERNEL EXPLOITATION PRIMITIVES
        # ─────────────────────────────────────────────────────────────────────
        PrimitiveID.KERNEL_ARBITRARY_READ.value: Primitive(
            name=PrimitiveID.KERNEL_ARBITRARY_READ.value,
            description="Read arbitrary kernel memory",
            provides=["kernel_addr_leak", "cred_structure_leak", "kernel_heap_leak"],
            requires=[],
            blocked_by=[],
            complicated_by=[MitigationID.SMAP.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Powerful primitive. SMAP complicates if reading via userspace pointer.",
        ),

        PrimitiveID.KERNEL_ARBITRARY_WRITE.value: Primitive(
            name=PrimitiveID.KERNEL_ARBITRARY_WRITE.value,
            description="Write arbitrary value to kernel memory",
            provides=["cred_overwrite", "modprobe_path_overwrite"],
            requires=[],
            blocked_by=[],
            complicated_by=[MitigationID.SMAP.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Game over primitive. Many targets: cred, modprobe_path, selinux_enforcing.",
        ),

        PrimitiveID.KERNEL_ADDR_LEAK.value: Primitive(
            name=PrimitiveID.KERNEL_ADDR_LEAK.value,
            description="Leaked kernel address - can defeat KASLR",
            provides=["kernel_base_known", "kernel_gadgets"],
            requires=[],
            requires_any=[PrimitiveID.KERNEL_ARBITRARY_READ.value, "kernel_info_leak", "dmesg_leak"],
            blocked_by=[],
            complicated_by=[MitigationID.KASLR.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Essential for kernel ROP. Check /proc/kallsyms, dmesg, side channels.",
        ),

        PrimitiveID.KERNEL_ROP.value: Primitive(
            name=PrimitiveID.KERNEL_ROP.value,
            description="ROP chain in kernel space",
            provides=["kernel_code_execution"],
            requires=["kernel_stack_control"],
            requires_any=[PrimitiveID.KERNEL_ADDR_LEAK.value],
            blocked_by=[],
            complicated_by=[MitigationID.KASLR.value, MitigationID.KPTI.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.MEDIUM_HIGH,
            notes="Standard kernel exploitation. Need gadgets and stack control.",
        ),

        PrimitiveID.RET2USR.value: Primitive(
            name=PrimitiveID.RET2USR.value,
            description="Return to userspace code from kernel context",
            provides=["kernel_code_execution"],
            requires=["kernel_stack_control"],
            blocked_by=[MitigationID.SMEP.value, MitigationID.KPTI.value],
            complicated_by=[],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.VERY_HIGH,
            notes="Classic technique - blocked by SMEP on modern kernels.",
        ),

        PrimitiveID.MODPROBE_PATH_OVERWRITE.value: Primitive(
            name=PrimitiveID.MODPROBE_PATH_OVERWRITE.value,
            description="Overwrite modprobe_path to execute arbitrary command",
            provides=[PrimitiveID.ROOT_PRIVILEGES.value],
            requires=[PrimitiveID.KERNEL_ARBITRARY_WRITE.value],
            blocked_by=[],
            complicated_by=[MitigationID.SELINUX.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Write /tmp/x to modprobe_path, trigger unknown binfmt, get root shell.",
        ),

        PrimitiveID.CRED_OVERWRITE.value: Primitive(
            name=PrimitiveID.CRED_OVERWRITE.value,
            description="Overwrite current task's cred structure",
            provides=[PrimitiveID.ROOT_PRIVILEGES.value],
            requires=[PrimitiveID.KERNEL_ARBITRARY_WRITE.value, "cred_structure_leak"],
            blocked_by=[],
            complicated_by=[MitigationID.SELINUX.value],
            primitive_type=PrimitiveType.CAPABILITY,
            reliability=Reliability.HIGH,
            notes="Set uid/gid to 0. Need to find current->cred address first.",
        ),

        PrimitiveID.ROOT_PRIVILEGES.value: Primitive(
            name=PrimitiveID.ROOT_PRIVILEGES.value,
            description="Achieved root/superuser privileges",
            provides=[],
            requires=[],
            requires_any=[
                PrimitiveID.MODPROBE_PATH_OVERWRITE.value,
                PrimitiveID.CRED_OVERWRITE.value,
                "kernel_code_execution",
                "setuid_binary_exploit",
            ],
            blocked_by=[],
            complicated_by=[],
            primitive_type=PrimitiveType.GOAL,
            reliability=100,
            notes="The goal for kernel exploitation.",
        ),
    }
