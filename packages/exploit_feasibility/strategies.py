#!/usr/bin/env python3
"""
Analysis strategies for different target contexts.

The Strategy pattern allows context-aware analysis:
- LOCAL_BINARY: Full local detection (current behavior)
- REMOTE_BINARY: Use provided values, skip local runtime tests
- WEB_APPLICATION: Skip memory mitigations entirely
- KERNEL: Check kernel-specific mitigations (SMEP, SMAP, KASLR, KPTI)

This enables analyzing remote CTF challenges without being blocked by
the local system's glibc version.
"""

import re
import subprocess
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from .profiles import TargetContext, TargetProfile


class AnalysisStrategy(ABC):
    """
    Base class for context-specific analysis strategies.

    Each strategy determines:
    - Whether local detection tools can/should be used
    - How to get glibc version (detect vs use provided)
    - How to get binary protections (detect vs use provided)
    - Whether memory mitigations are relevant at all
    """

    def __init__(self, profile: TargetProfile):
        """Initialize strategy with target profile."""
        self.profile = profile

    @abstractmethod
    def can_detect_locally(self) -> bool:
        """Whether local detection tools can be used."""
        pass

    @abstractmethod
    def should_check_memory_mitigations(self) -> bool:
        """Whether memory corruption mitigations are relevant."""
        pass

    @abstractmethod
    def should_skip_empirical_tests(self) -> bool:
        """Whether to skip empirical runtime tests (like %n verification)."""
        pass

    @abstractmethod
    def get_glibc_version(self) -> Tuple[Optional[str], str]:
        """
        Get glibc version.

        Returns:
            Tuple of (version_string, confidence)
            confidence is one of: "detected", "provided", "inferred", "unknown"
        """
        pass

    @abstractmethod
    def get_format_n_status(self) -> Tuple[bool, str]:
        """
        Get format string %n status.

        Returns:
            Tuple of (is_blocked, reason)
        """
        pass

    def get_binary_protections(self) -> Tuple[Dict[str, bool], str]:
        """
        Get binary protections.

        Default implementation runs checksec on local binary.
        Override for contexts that can't/shouldn't run local tools.

        Returns:
            Tuple of (protections_dict, confidence)
        """
        if not self.profile.binary_path:
            return {}, "no_binary"

        binary_path = Path(self.profile.binary_path)
        if not binary_path.exists():
            return {}, "binary_not_found"

        # Try to detect using pwntools checksec
        protections = self._run_checksec(binary_path)
        return protections, "detected"

    def _run_checksec(self, binary_path: Path) -> Dict[str, bool]:
        """Run checksec on binary and return protections dict."""
        protections = {}

        try:
            # Try pwntools first
            from pwn import ELF
            elf = ELF(str(binary_path), checksec=False)
            protections = {
                'canary': elf.canary,
                'nx': elf.nx,
                'pie': elf.pie,
                'relro': elf.relro != 'No RELRO',
                'full_relro': elf.relro == 'Full',
            }
        except ImportError:
            # Fall back to readelf
            protections = self._checksec_via_readelf(binary_path)
        except Exception:
            protections = self._checksec_via_readelf(binary_path)

        return protections

    def _checksec_via_readelf(self, binary_path: Path) -> Dict[str, bool]:
        """Fallback checksec using readelf."""
        protections = {
            'canary': False,
            'nx': True,  # Assume NX enabled by default
            'pie': False,
            'relro': False,
            'full_relro': False,
        }

        try:
            # Check for stack canary
            result = subprocess.run(
                ['readelf', '-s', str(binary_path)],
                capture_output=True, text=True, timeout=10
            )
            if '__stack_chk_fail' in result.stdout:
                protections['canary'] = True

            # Check for PIE
            result = subprocess.run(
                ['readelf', '-h', str(binary_path)],
                capture_output=True, text=True, timeout=10
            )
            if 'DYN' in result.stdout:
                protections['pie'] = True

            # Check for RELRO
            result = subprocess.run(
                ['readelf', '-l', str(binary_path)],
                capture_output=True, text=True, timeout=10
            )
            if 'GNU_RELRO' in result.stdout:
                protections['relro'] = True
                # Check for BIND_NOW (Full RELRO)
                result2 = subprocess.run(
                    ['readelf', '-d', str(binary_path)],
                    capture_output=True, text=True, timeout=10
                )
                if 'BIND_NOW' in result2.stdout:
                    protections['full_relro'] = True

        except (subprocess.SubprocessError, OSError):
            pass

        return protections

    def get_kernel_mitigations(self) -> Tuple[Dict[str, Any], str]:
        """
        Get kernel mitigations.

        Default implementation returns assumed values.
        Override for kernel context to do actual detection.

        Returns:
            Tuple of (mitigations_dict, confidence)
        """
        return {
            'aslr': True,
            'note': 'Assumed enabled (default on modern systems)'
        }, "assumed"

    def get_context_warnings(self) -> List[str]:
        """Get context-specific warnings for the report."""
        return []


class LocalBinaryStrategy(AnalysisStrategy):
    """
    Full local detection - current default behavior.

    Uses local tools to detect:
    - glibc version from ldd
    - Binary protections from checksec
    - Empirical %n testing
    """

    def can_detect_locally(self) -> bool:
        return True

    def should_check_memory_mitigations(self) -> bool:
        return True

    def should_skip_empirical_tests(self) -> bool:
        return False

    def get_glibc_version(self) -> Tuple[Optional[str], str]:
        """Detect glibc version from local system."""
        try:
            result = subprocess.run(
                ['ldd', '--version'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                match = re.search(r'(\d+\.\d+)', result.stdout)
                if match:
                    return match.group(1), "detected"
        except (subprocess.SubprocessError, OSError):
            pass

        return None, "unknown"

    def get_format_n_status(self) -> Tuple[bool, str]:
        """
        Determine %n status.

        For local targets, this will be verified empirically by the analyzer.
        We just return the version-based expectation here.
        """
        version_str, _ = self.get_glibc_version()
        if version_str:
            try:
                version = float(version_str)
                if version >= 2.38:
                    return True, "blocked_by_version"
            except ValueError:
                pass
        return False, "allowed_by_version"


class RemoteBinaryStrategy(AnalysisStrategy):
    """
    Remote target - use provided values, skip local runtime tests.

    For remote targets (CTF challenges, network services):
    - Use provided glibc version (from challenge description)
    - Skip empirical %n test (can't test on remote)
    - Still run checksec on local copy of binary (structure is same)
    """

    def can_detect_locally(self) -> bool:
        return False

    def should_check_memory_mitigations(self) -> bool:
        return True

    def should_skip_empirical_tests(self) -> bool:
        return True  # Can't test %n on remote target

    def get_glibc_version(self) -> Tuple[Optional[str], str]:
        """Use provided glibc version from profile."""
        if self.profile.glibc_version:
            return self.profile.glibc_version, "provided"
        return None, "unknown"

    def get_format_n_status(self) -> Tuple[bool, str]:
        """Infer %n status from provided glibc version."""
        if not self.profile.glibc_version:
            # Conservative: assume blocked if unknown
            return True, "unknown_glibc_assuming_blocked"

        try:
            # Parse version string (handles "2.31", "2.31-0ubuntu9", etc.)
            match = re.search(r'(\d+)\.(\d+)', self.profile.glibc_version)
            if match:
                major = int(match.group(1))
                minor = int(match.group(2))
                version = major + minor / 100.0

                if version >= 2.38:
                    return True, "blocked_by_version"
                return False, "allowed_by_version"
        except (ValueError, AttributeError):
            pass

        return True, "unknown_glibc_assuming_blocked"

    def get_binary_protections(self) -> Tuple[Dict[str, bool], str]:
        """
        Get binary protections.

        For remote targets:
        1. Run checksec on local copy (binary structure is identical)
        2. Override with any explicitly provided values
        """
        # Start with checksec on local copy if available
        protections, confidence = super().get_binary_protections()

        # Override with explicitly provided values from profile
        overrides = {}
        if self.profile.has_pie is not None:
            overrides['pie'] = self.profile.has_pie
        if self.profile.has_nx is not None:
            overrides['nx'] = self.profile.has_nx
        if self.profile.has_canary is not None:
            overrides['canary'] = self.profile.has_canary
        if self.profile.has_full_relro is not None:
            overrides['full_relro'] = self.profile.has_full_relro
            if self.profile.has_full_relro:
                overrides['relro'] = True

        if overrides:
            protections.update(overrides)
            confidence = "provided" if not protections else "detected_with_overrides"

        return protections, confidence

    def get_kernel_mitigations(self) -> Tuple[Dict[str, Any], str]:
        """Cannot detect remote kernel - return conservative defaults."""
        return {
            'aslr': True,
            'note': 'Remote target - kernel mitigations unknown, assuming enabled'
        }, "assumed"

    def get_context_warnings(self) -> List[str]:
        """Warn about remote-specific concerns."""
        warnings = []
        if not self.profile.glibc_version:
            warnings.append(
                "Remote target: glibc version unknown - assuming modern mitigations. "
                "Provide glibc_version in profile for accurate analysis, or leak libc to fingerprint."
            )
        return warnings


class WebApplicationStrategy(AnalysisStrategy):
    """
    Web application - memory mitigations not applicable.

    For web vulnerabilities (SQLi, XSS, SSRF, etc.):
    - Skip all memory corruption checks
    - Different defenses apply (WAF, CSP, input validation)
    """

    def can_detect_locally(self) -> bool:
        return False  # Not relevant

    def should_check_memory_mitigations(self) -> bool:
        return False  # Key difference!

    def should_skip_empirical_tests(self) -> bool:
        return True

    def get_glibc_version(self) -> Tuple[Optional[str], str]:
        """Not relevant for web applications."""
        return None, "not_applicable"

    def get_format_n_status(self) -> Tuple[bool, str]:
        """Not relevant for web applications."""
        return False, "not_applicable"

    def get_binary_protections(self) -> Tuple[Dict[str, bool], str]:
        """Not relevant for web applications."""
        return {}, "not_applicable"

    def get_kernel_mitigations(self) -> Tuple[Dict[str, Any], str]:
        """Not relevant for web applications."""
        return {}, "not_applicable"

    def get_relevant_checks(self) -> List[str]:
        """What matters for web applications."""
        return [
            "input_validation",
            "parameterized_queries",
            "output_encoding",
            "csp_headers",
            "cors_policy",
            "waf_presence",
            "authentication",
            "authorization",
        ]

    def get_context_warnings(self) -> List[str]:
        """Web-specific guidance."""
        return [
            "Web application context - memory corruption mitigations not applicable. "
            "Check: WAF, CSP, input validation, parameterized queries, authentication/authorization."
        ]


class KernelStrategy(AnalysisStrategy):
    """
    Kernel exploitation - different mitigation set entirely.

    For kernel vulnerabilities:
    - Check kernel-specific mitigations (SMEP, SMAP, KASLR, KPTI)
    - Different primitive/technique set
    - May be local (this kernel) or remote (VM escape target)
    """

    def can_detect_locally(self) -> bool:
        # Can detect if this is the local kernel
        return True

    def should_check_memory_mitigations(self) -> bool:
        return True  # But different mitigations!

    def should_skip_empirical_tests(self) -> bool:
        return True  # Different tests for kernel

    def get_glibc_version(self) -> Tuple[Optional[str], str]:
        """Not directly relevant for kernel exploitation."""
        return None, "not_applicable"

    def get_format_n_status(self) -> Tuple[bool, str]:
        """Not relevant for kernel exploitation."""
        return False, "not_applicable"

    def get_binary_protections(self) -> Tuple[Dict[str, bool], str]:
        """
        Get kernel module protections if analyzing a kernel module.

        For now, return empty - kernel has different protection model.
        """
        return {}, "kernel_context"

    def get_kernel_mitigations(self) -> Tuple[Dict[str, Any], str]:
        """Detect kernel mitigations from /proc and /sys."""
        mitigations = {}
        confidence = "detected"

        # Check KASLR
        mitigations['kaslr'] = self._check_kaslr()

        # Check SMEP
        mitigations['smep'] = self._check_smep()

        # Check SMAP
        mitigations['smap'] = self._check_smap()

        # Check KPTI
        mitigations['kpti'] = self._check_kpti()

        # Check kernel lockdown
        mitigations['lockdown'] = self._check_lockdown()

        # Check SELinux/AppArmor
        mitigations['selinux'] = self._check_selinux()

        return mitigations, confidence

    def _check_kaslr(self) -> Dict[str, Any]:
        """Check Kernel Address Space Layout Randomization."""
        result = {
            'enabled': True,  # Assume enabled by default
            'confidence': 'assumed'
        }

        try:
            # Check cmdline for nokaslr
            cmdline = Path('/proc/cmdline').read_text()
            if 'nokaslr' in cmdline:
                result['enabled'] = False
                result['confidence'] = 'detected'
                return result

            # Check kallsyms accessibility
            try:
                with open('/proc/kallsyms', 'r') as f:
                    line = f.readline()
                    # If addresses are zeroed, KASLR is on and we're non-root
                    if line.startswith('0000000000000000'):
                        result['enabled'] = True
                        result['confidence'] = 'detected'
                        result['note'] = 'kallsyms addresses hidden (non-root)'
                    else:
                        # We can see real addresses - either root or kaslr off
                        result['confidence'] = 'detected'
            except PermissionError:
                result['confidence'] = 'assumed'

        except (OSError, IOError):
            pass

        return result

    def _check_smep(self) -> Dict[str, Any]:
        """Check Supervisor Mode Execution Prevention."""
        result = {
            'enabled': False,
            'cpu_supported': False,
            'confidence': 'detected'
        }

        try:
            cpuinfo = Path('/proc/cpuinfo').read_text()
            result['cpu_supported'] = 'smep' in cpuinfo

            if result['cpu_supported']:
                # Check if disabled via boot param
                cmdline = Path('/proc/cmdline').read_text()
                result['enabled'] = 'nosmep' not in cmdline
            else:
                result['enabled'] = False

        except (OSError, IOError):
            result['confidence'] = 'unknown'

        return result

    def _check_smap(self) -> Dict[str, Any]:
        """Check Supervisor Mode Access Prevention."""
        result = {
            'enabled': False,
            'cpu_supported': False,
            'confidence': 'detected'
        }

        try:
            cpuinfo = Path('/proc/cpuinfo').read_text()
            result['cpu_supported'] = 'smap' in cpuinfo

            if result['cpu_supported']:
                cmdline = Path('/proc/cmdline').read_text()
                result['enabled'] = 'nosmap' not in cmdline
            else:
                result['enabled'] = False

        except (OSError, IOError):
            result['confidence'] = 'unknown'

        return result

    def _check_kpti(self) -> Dict[str, Any]:
        """Check Kernel Page Table Isolation (Meltdown mitigation)."""
        result = {
            'enabled': True,  # Assume enabled on Intel
            'confidence': 'assumed'
        }

        try:
            cmdline = Path('/proc/cmdline').read_text()

            if 'nopti' in cmdline or 'pti=off' in cmdline:
                result['enabled'] = False
                result['confidence'] = 'detected'
            elif 'pti=on' in cmdline:
                result['enabled'] = True
                result['confidence'] = 'detected'

        except (OSError, IOError):
            pass

        return result

    def _check_lockdown(self) -> Dict[str, Any]:
        """Check kernel lockdown status."""
        result = {
            'enabled': False,
            'mode': 'none',
            'confidence': 'detected'
        }

        try:
            lockdown_path = Path('/sys/kernel/security/lockdown')
            if lockdown_path.exists():
                content = lockdown_path.read_text().strip()
                # Format: "[none] integrity confidentiality"
                if '[none]' in content:
                    result['mode'] = 'none'
                elif '[integrity]' in content:
                    result['enabled'] = True
                    result['mode'] = 'integrity'
                elif '[confidentiality]' in content:
                    result['enabled'] = True
                    result['mode'] = 'confidentiality'
        except (OSError, IOError, PermissionError):
            result['confidence'] = 'unknown'

        return result

    def _check_selinux(self) -> Dict[str, Any]:
        """Check SELinux status."""
        result = {
            'enabled': False,
            'mode': 'disabled',
            'confidence': 'detected'
        }

        try:
            # Check SELinux
            selinux_path = Path('/sys/fs/selinux/enforce')
            if selinux_path.exists():
                enforce = selinux_path.read_text().strip()
                result['enabled'] = True
                result['mode'] = 'enforcing' if enforce == '1' else 'permissive'
                return result

            # Check AppArmor as alternative
            apparmor_path = Path('/sys/kernel/security/apparmor/profiles')
            if apparmor_path.exists():
                result['enabled'] = True
                result['mode'] = 'apparmor'
                return result

        except (OSError, IOError, PermissionError):
            result['confidence'] = 'unknown'

        return result

    def get_context_warnings(self) -> List[str]:
        """Kernel-specific guidance."""
        warnings = []

        mitigations, _ = self.get_kernel_mitigations()

        if mitigations.get('smep', {}).get('enabled'):
            warnings.append(
                "SMEP enabled - cannot execute userspace code from kernel mode. "
                "Use kernel ROP or disable SMEP first."
            )

        if mitigations.get('smap', {}).get('enabled'):
            warnings.append(
                "SMAP enabled - cannot access userspace memory from kernel mode. "
                "Need copy_from_user or disable SMAP first."
            )

        if mitigations.get('kaslr', {}).get('enabled'):
            warnings.append(
                "KASLR enabled - kernel addresses randomized. "
                "Need info leak to defeat."
            )

        if mitigations.get('kpti', {}).get('enabled'):
            warnings.append(
                "KPTI enabled - kernel page tables isolated. "
                "ret2usr more difficult."
            )

        return warnings


def get_analysis_strategy(profile: TargetProfile) -> AnalysisStrategy:
    """
    Select appropriate strategy based on target context.

    Args:
        profile: Target profile with context information

    Returns:
        Appropriate AnalysisStrategy instance

    Example:
        >>> from .profiles import create_remote_profile
        >>> profile = create_remote_profile(glibc_version="2.31")
        >>> strategy = get_analysis_strategy(profile)
        >>> isinstance(strategy, RemoteBinaryStrategy)
        True
    """
    strategies = {
        TargetContext.LOCAL_BINARY: LocalBinaryStrategy,
        TargetContext.REMOTE_BINARY: RemoteBinaryStrategy,
        TargetContext.WEB_APPLICATION: WebApplicationStrategy,
        TargetContext.KERNEL: KernelStrategy,
    }

    strategy_class = strategies.get(profile.context, LocalBinaryStrategy)
    return strategy_class(profile)
