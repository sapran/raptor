#!/usr/bin/env python3
"""
Primitive dependency graph for exploit path finding.

Models how exploitation primitives chain together.
Agent uses this to find paths from initial vulnerability to code execution.

Example chain: format_string_vuln -> libc_leak -> ret2libc -> code_execution
"""

import re
from collections import defaultdict
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Tuple

from .constants import GlibcVersion
from .primitives import (
    Primitive,
    PrimitiveType,
    ExploitPath,
    get_primitive_definitions,
)


@dataclass
class PrimitiveNode:
    """A node in the dependency graph with computed path information."""
    primitive: Primitive
    depth: int = 0
    parent: Optional[str] = None
    achievable: bool = False
    blocked_reason: str = ""
    missing_requirements: List[str] = field(default_factory=list)


class PrimitiveDependencyGraph:
    """
    Graph of exploitation primitives and their dependencies.

    The agent uses this to:
    1. Find paths from vulnerability to code execution
    2. Understand what info leaks are needed
    3. Identify which mitigations block which paths
    4. Plan multi-stage exploits

    Example:
        >>> graph = PrimitiveDependencyGraph(["full_relro", "stack_canary"])
        >>> paths = graph.find_paths_to_goal("format_string_vuln", "code_execution")
        >>> len(paths) > 0  # Should find at least one path
        True
    """

    def __init__(self, active_mitigations: Optional[List[str]] = None):
        """
        Initialize graph with active mitigations.

        Args:
            active_mitigations: List of active mitigations that block primitives
                              e.g., ["full_relro", "glibc_n_disabled", "stack_canary"]
        """
        self.primitives = get_primitive_definitions()
        self.active_mitigations = set(active_mitigations or [])
        self._build_graph()

    def _build_graph(self) -> None:
        """Build adjacency lists for graph traversal."""
        # What each primitive enables (forward edges)
        self.enables: Dict[str, List[str]] = defaultdict(list)
        # What each primitive requires (backward edges)
        self.required_by: Dict[str, List[str]] = defaultdict(list)
        # Map capabilities to primitives that provide them
        self.providers: Dict[str, List[str]] = defaultdict(list)

        # First pass: build provider map
        for name, prim in self.primitives.items():
            for provides in prim.provides:
                self.providers[provides].append(name)

        # Second pass: build edges
        for name, prim in self.primitives.items():
            # Forward: what this primitive's outputs enable
            for provides in prim.provides:
                for other_name, other in self.primitives.items():
                    if other_name == name:
                        continue
                    if provides in other.requires or provides in other.requires_any:
                        if other_name not in self.enables[name]:
                            self.enables[name].append(other_name)

            # Also add direct edges for "provides" that match primitive names
            for provides in prim.provides:
                if provides in self.primitives and provides not in self.enables[name]:
                    self.enables[name].append(provides)

            # Backward: what requires this primitive
            for req in prim.requires:
                self.required_by[req].append(name)
            for req in prim.requires_any:
                self.required_by[req].append(name)

        # Third pass: add edges from primitives to those that require them
        for name, prim in self.primitives.items():
            for req in prim.requires:
                if req in self.primitives and name not in self.enables[req]:
                    self.enables[req].append(name)
            for req in prim.requires_any:
                if req in self.primitives and name not in self.enables[req]:
                    self.enables[req].append(name)

    def is_blocked(self, primitive_name: str) -> Tuple[bool, str]:
        """
        Check if a primitive is blocked by active mitigations.

        Example:
            >>> graph = PrimitiveDependencyGraph(["glibc_n_disabled"])
            >>> blocked, reason = graph.is_blocked("format_string_write")
            >>> blocked
            True
        """
        prim = self.primitives.get(primitive_name)
        if not prim:
            return False, ""

        for blocker in prim.blocked_by:
            if blocker in self.active_mitigations:
                return True, blocker
        return False, ""

    def get_available_primitives(self, starting_primitives: List[str]) -> Set[str]:
        """
        Get all primitives achievable from starting points.

        Uses BFS to find all reachable primitives given starting vulnerabilities.

        Args:
            starting_primitives: Initial vulnerabilities/capabilities

        Returns:
            Set of all achievable primitive names

        Example:
            >>> graph = PrimitiveDependencyGraph([])
            >>> available = graph.get_available_primitives(["format_string_vuln"])
            >>> "libc_leak" in available
            True
        """
        available = set(starting_primitives)
        queue = list(starting_primitives)
        visited = set()

        while queue:
            current = queue.pop(0)
            if current in visited:
                continue
            visited.add(current)

            prim = self.primitives.get(current)
            if not prim:
                continue

            # Add what this primitive provides
            for provides in prim.provides:
                if provides not in available:
                    available.add(provides)
                    for name, p in self.primitives.items():
                        if name not in available and p.is_achievable(available, self.active_mitigations):
                            available.add(name)
                            queue.append(name)

        return available

    def find_paths_to_goal(
        self,
        start: str,
        goal: str = "code_execution",
        max_depth: int = 10
    ) -> List[ExploitPath]:
        """
        Find all exploitation paths from start to goal.

        Uses DFS to enumerate possible exploitation chains.

        Args:
            start: Starting vulnerability (e.g., "format_string_vuln")
            goal: Target goal (default: "code_execution")
            max_depth: Maximum chain length

        Returns:
            List of ExploitPath objects, sorted by reliability

        Example:
            >>> graph = PrimitiveDependencyGraph([])
            >>> paths = graph.find_paths_to_goal("format_string_vuln", "code_execution")
            >>> all(p.goal == "code_execution" for p in paths)
            True
        """
        paths = []
        self._dfs_paths(start, goal, [start], set([start]), paths, max_depth)
        paths.sort(key=lambda p: p.total_reliability, reverse=True)
        return paths

    def _dfs_paths(
        self,
        current: str,
        goal: str,
        path: List[str],
        visited: Set[str],
        paths: List[ExploitPath],
        max_depth: int,
        accumulated_capabilities: Optional[Set[str]] = None
    ):
        """DFS helper for path finding."""
        if len(path) > max_depth:
            return

        prim = self.primitives.get(current)
        if not prim:
            return

        blocked, blocker = self.is_blocked(current)
        if blocked:
            return

        if accumulated_capabilities is None:
            accumulated_capabilities = set()

        capabilities = accumulated_capabilities.copy()
        capabilities.add(current)
        for provided in prim.provides:
            capabilities.add(provided)

        # Check if goal reached
        if current == goal or goal in prim.provides:
            exploit_path = self._build_exploit_path(path, goal)
            paths.append(exploit_path)
            return

        # Check if we can reach the goal with current capabilities
        goal_prim = self.primitives.get(goal, Primitive(goal, ""))

        if goal_prim.requires_any:
            for req in goal_prim.requires_any:
                if req in capabilities:
                    req_prim = self.primitives.get(req)
                    if req_prim:
                        req_satisfied = all(r in capabilities for r in req_prim.requires)
                        req_any_satisfied = not req_prim.requires_any or any(
                            r in capabilities for r in req_prim.requires_any
                        )
                        if req_satisfied and req_any_satisfied:
                            can_satisfy_requires = all(r in capabilities for r in goal_prim.requires)
                            if can_satisfy_requires:
                                final_path = path + [goal]
                                exploit_path = self._build_exploit_path(final_path, goal)
                                paths.append(exploit_path)
                                break
                    else:
                        can_satisfy_requires = all(r in capabilities for r in goal_prim.requires)
                        if can_satisfy_requires:
                            final_path = path + [goal]
                            exploit_path = self._build_exploit_path(final_path, goal)
                            paths.append(exploit_path)
                            break

        # Continue exploring
        for next_prim_name in self.enables.get(current, []):
            if next_prim_name not in visited:
                next_prim = self.primitives.get(next_prim_name)
                if next_prim:
                    can_proceed = self._can_proceed_to_primitive(
                        next_prim, current, capabilities, visited
                    )
                    if can_proceed:
                        visited.add(next_prim_name)
                        self._dfs_paths(
                            next_prim_name, goal, path + [next_prim_name],
                            visited, paths, max_depth, capabilities
                        )
                        visited.remove(next_prim_name)

    def _can_proceed_to_primitive(
        self,
        next_prim: Primitive,
        current: str,
        capabilities: Set[str],
        visited: Set[str]
    ) -> bool:
        """Check if we can proceed to the next primitive."""
        # Check requires (must have ALL)
        for req in next_prim.requires:
            if req not in capabilities:
                can_get_req = False
                if req in self.primitives:
                    blocked, _ = self.is_blocked(req)
                    if not blocked and req in self.enables.get(current, []):
                        can_get_req = True

                if not can_get_req:
                    for pname in self.enables.get(current, []):
                        pprim = self.primitives.get(pname)
                        if pprim and req in pprim.provides:
                            blocked, _ = self.is_blocked(pname)
                            if not blocked and pname not in visited:
                                can_get_req = True
                                break

                if not can_get_req:
                    return False

        # Check requires_any (must have AT LEAST ONE)
        if next_prim.requires_any:
            has_any = any(req in capabilities for req in next_prim.requires_any)
            if not has_any:
                can_acquire = False
                for req in next_prim.requires_any:
                    for pname, pprim in self.primitives.items():
                        if req in pprim.provides and pname not in visited:
                            blocked, _ = self.is_blocked(pname)
                            if not blocked and pname in self.enables.get(current, []):
                                can_acquire = True
                                break
                    if can_acquire:
                        break
                if not can_acquire:
                    return False

        return True

    def _build_exploit_path(self, steps: List[str], goal: str) -> ExploitPath:
        """Build ExploitPath object from list of steps."""
        path = ExploitPath(goal=goal, steps=steps)

        reliability = 1.0
        for step in steps:
            prim = self.primitives.get(step)
            if prim:
                reliability *= (prim.reliability / 100.0)
                path.blocked_mitigations.extend(prim.blocked_by)
                path.complicating_mitigations.extend(prim.complicated_by)
                if prim.notes:
                    path.notes.append(f"{step}: {prim.notes}")

        path.total_reliability = reliability * 100
        path.blocked_mitigations = list(set(path.blocked_mitigations))
        path.complicating_mitigations = list(set(path.complicating_mitigations))

        # Add active mitigations that affect this path
        active_complications = []
        if 'stack_canary' in self.active_mitigations:
            if any(s in steps for s in ['stack_overflow_vuln', 'can_overwrite_ret_addr', 'rop_chain']):
                active_complications.append('stack_canary')
        if 'pie' in self.active_mitigations:
            if any(s in steps for s in ['rop_chain', 'ret2plt']):
                active_complications.append('pie')
        if 'aslr' in self.active_mitigations:
            if any(s in steps for s in ['ret2libc', 'hook_overwrite', 'exit_funcs_overwrite']):
                active_complications.append('aslr')

        all_complications = list(set(path.complicating_mitigations + active_complications))
        path.complicating_mitigations = all_complications
        path.compute_confidence()

        return path

    def get_shortest_path(self, start: str, goal: str = "code_execution") -> Optional[ExploitPath]:
        """Get the shortest viable path to the goal."""
        paths = self.find_paths_to_goal(start, goal)
        if not paths:
            return None
        return min(paths, key=lambda p: len(p.steps))

    def get_most_reliable_path(self, start: str, goal: str = "code_execution") -> Optional[ExploitPath]:
        """Get the most reliable path to the goal."""
        paths = self.find_paths_to_goal(start, goal)
        if not paths:
            return None
        return paths[0]  # Already sorted by reliability

    def get_primitive_info(self, name: str) -> Optional[PrimitiveNode]:
        """Get detailed info about a primitive."""
        prim = self.primitives.get(name)
        if not prim:
            return None

        node = PrimitiveNode(primitive=prim)
        blocked, reason = self.is_blocked(name)
        node.achievable = not blocked
        node.blocked_reason = reason
        node.missing_requirements = prim.get_missing_requirements(self.active_mitigations)

        return node

    def summary(self) -> str:
        """Generate summary of graph state."""
        lines = ["PRIMITIVE DEPENDENCY GRAPH:"]
        lines.append(f"  Active mitigations: {', '.join(self.active_mitigations) or 'None'}")

        vulns = [n for n, p in self.primitives.items() if p.primitive_type == PrimitiveType.VULNERABILITY]
        caps = [n for n, p in self.primitives.items() if p.primitive_type == PrimitiveType.CAPABILITY]
        goals = [n for n, p in self.primitives.items() if p.primitive_type == PrimitiveType.GOAL]

        lines.append(f"  Vulnerabilities: {len(vulns)}")
        lines.append(f"  Capabilities: {len(caps)}")
        lines.append(f"  Goals: {len(goals)}")

        blocked_count = sum(1 for n in self.primitives if self.is_blocked(n)[0])
        lines.append(f"  Blocked primitives: {blocked_count}")

        return "\n".join(lines)


def create_dependency_graph(
    binary_protections: Optional[Dict[str, bool]] = None,
    glibc_version: Optional[str] = None,
    additional_mitigations: Optional[List[str]] = None
) -> PrimitiveDependencyGraph:
    """
    Create a dependency graph with mitigations inferred from binary/system.

    This is the main entry point for graph-based analysis.

    Args:
        binary_protections: Dict with relro, pie, nx, canary status
        glibc_version: glibc version string (e.g., "2.38")
        additional_mitigations: Extra mitigations to consider

    Returns:
        Configured PrimitiveDependencyGraph

    Example:
        >>> graph = create_dependency_graph(
        ...     binary_protections={'full_relro': True, 'pie': True},
        ...     glibc_version="2.38"
        ... )
        >>> 'full_relro' in graph.active_mitigations
        True
        >>> 'glibc_n_disabled' in graph.active_mitigations
        True
    """
    mitigations = []

    if binary_protections:
        if binary_protections.get('full_relro'):
            mitigations.append('full_relro')
        elif binary_protections.get('relro'):
            mitigations.append('partial_relro')
        if binary_protections.get('canary'):
            mitigations.append('stack_canary')
        if binary_protections.get('pie'):
            mitigations.append('pie')
        if binary_protections.get('nx'):
            mitigations.append('nx')

    if glibc_version:
        try:
            match = re.search(r'(\d+)\.(\d+)', glibc_version)
            if match:
                major = int(match.group(1))
                minor = int(match.group(2))
            else:
                parts = glibc_version.split('.')
                major = int(parts[0])
                minor = int(parts[1]) if len(parts) > 1 else 0

            version = major + minor / 100.0

            if version >= GlibcVersion.HOOKS_REMOVED:
                mitigations.append('glibc_hooks_removed')
            if version >= GlibcVersion.FORMAT_N_DISABLED:
                mitigations.append('glibc_n_disabled')
            if version >= GlibcVersion.SAFE_LINKING:
                mitigations.append('safe_linking')
            if version >= GlibcVersion.TCACHE_KEY:
                mitigations.append('tcache_key')

        except (ValueError, IndexError):
            pass

    if additional_mitigations:
        mitigations.extend(additional_mitigations)

    return PrimitiveDependencyGraph(mitigations)
