#!/usr/bin/env python3
"""
Exploitation techniques and their requirements.

This module maps techniques to their prerequisites and blockers.
The agent consults this when planning: "I want to use tcache poison - what do I need?"
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional

from .primitives import MitigationID


@dataclass
class TechniqueRequirements:
    """
    What a technique needs to work, and what blocks it.

    Example:
        >>> req = TechniqueRequirements(
        ...     technique="got_overwrite",
        ...     description="Overwrite GOT entry to hijack function call",
        ...     blocked_by=["full_relro"],
        ...     requires_primitives=["arbitrary_write", "pie_leak"],
        ...     provides=["code_execution"],
        ... )
        >>> "full_relro" in req.blocked_by
        True
    """
    technique: str
    description: str

    # Hard blockers - if any of these are true, technique won't work
    blocked_by: List[str] = field(default_factory=list)

    # Primitives needed - must obtain these first
    requires_primitives: List[str] = field(default_factory=list)

    # Mitigations that complicate but don't block
    complicated_by: List[str] = field(default_factory=list)

    # What this technique achieves (for chaining)
    provides: List[str] = field(default_factory=list)

    # Alternative techniques if this one is blocked
    alternatives: List[str] = field(default_factory=list)


def get_technique_requirements() -> Dict[str, TechniqueRequirements]:
    """
    Get all technique requirements.

    Returns a fresh copy to prevent mutation issues.

    Example:
        >>> techniques = get_technique_requirements()
        >>> 'format_string_read' in techniques
        True
        >>> techniques['tcache_poison'].blocked_by
        ['glibc_no_tcache']
    """
    return {
        # ─────────────────────────────────────────────────────────────────────
        # INFORMATION LEAKS (usually the first step)
        # ─────────────────────────────────────────────────────────────────────
        "format_string_read": TechniqueRequirements(
            technique="format_string_read",
            description="Use %p/%s/%x to leak stack/heap/libc addresses",
            blocked_by=[],  # Always works if format string vuln exists
            requires_primitives=["format_string_vuln"],
            complicated_by=[],
            provides=["stack_leak", "libc_leak", "heap_leak", "canary_leak", "pie_leak"],
            alternatives=["oob_read", "uninitialized_memory_read"],
        ),

        "oob_read": TechniqueRequirements(
            technique="oob_read",
            description="Out-of-bounds read to leak adjacent memory",
            blocked_by=[],
            requires_primitives=["oob_read_vuln"],
            complicated_by=[MitigationID.ASAN.value],
            provides=["stack_leak", "heap_leak", "canary_leak"],
            alternatives=["format_string_read"],
        ),

        # ─────────────────────────────────────────────────────────────────────
        # STACK EXPLOITATION
        # ─────────────────────────────────────────────────────────────────────
        "stack_buffer_overflow_shellcode": TechniqueRequirements(
            technique="stack_buffer_overflow_shellcode",
            description="Overflow buffer, overwrite return address, jump to shellcode on stack",
            blocked_by=[MitigationID.NX.value],
            requires_primitives=["stack_overflow_vuln"],
            complicated_by=[MitigationID.STACK_CANARY.value, MitigationID.ASLR.value],
            provides=["code_execution"],
            alternatives=["stack_buffer_overflow_rop", "stack_buffer_overflow_ret2libc"],
        ),

        "stack_buffer_overflow_rop": TechniqueRequirements(
            technique="stack_buffer_overflow_rop",
            description="Overflow buffer, build ROP chain for code execution",
            blocked_by=[],
            requires_primitives=["stack_overflow_vuln", "rop_gadgets"],
            complicated_by=[MitigationID.STACK_CANARY.value, MitigationID.ASLR.value, MitigationID.PIE.value],
            provides=["code_execution", "arbitrary_syscall"],
            alternatives=["stack_buffer_overflow_ret2libc"],
        ),

        "stack_buffer_overflow_ret2libc": TechniqueRequirements(
            technique="stack_buffer_overflow_ret2libc",
            description="Overflow buffer, return to system('/bin/sh')",
            blocked_by=[],
            requires_primitives=["stack_overflow_vuln", "libc_leak"],
            complicated_by=[MitigationID.STACK_CANARY.value, MitigationID.ASLR.value],
            provides=["code_execution"],
            alternatives=["stack_buffer_overflow_rop"],
        ),

        # ─────────────────────────────────────────────────────────────────────
        # FORMAT STRING WRITE
        # ─────────────────────────────────────────────────────────────────────
        "format_string_got_overwrite": TechniqueRequirements(
            technique="format_string_got_overwrite",
            description="Use %n to overwrite GOT entry with system/one_gadget",
            blocked_by=[MitigationID.GLIBC_N_DISABLED.value, MitigationID.FULL_RELRO.value],
            requires_primitives=["format_string_vuln", "libc_leak"],
            complicated_by=[MitigationID.PIE.value],
            provides=["code_execution"],
            alternatives=["format_string_retaddr_overwrite", "format_string_fini_array"],
        ),

        "format_string_retaddr_overwrite": TechniqueRequirements(
            technique="format_string_retaddr_overwrite",
            description="Use %n to overwrite return address on stack",
            blocked_by=[MitigationID.GLIBC_N_DISABLED.value],
            requires_primitives=["format_string_vuln", "stack_leak"],
            complicated_by=[MitigationID.ASLR.value, MitigationID.PIE.value],
            provides=["code_execution"],
            alternatives=["format_string_got_overwrite"],
        ),

        "format_string_fini_array": TechniqueRequirements(
            technique="format_string_fini_array",
            description="Use %n to overwrite .fini_array for exit handler hijack",
            blocked_by=[MitigationID.GLIBC_N_DISABLED.value, MitigationID.FULL_RELRO.value],
            requires_primitives=["format_string_vuln", "pie_leak"],
            complicated_by=[MitigationID.PIE.value],
            provides=["code_execution"],
            alternatives=["format_string_retaddr_overwrite"],
        ),

        # ─────────────────────────────────────────────────────────────────────
        # HEAP EXPLOITATION
        # ─────────────────────────────────────────────────────────────────────
        "tcache_poison": TechniqueRequirements(
            technique="tcache_poison",
            description="Corrupt tcache fd pointer to get arbitrary allocation",
            blocked_by=[MitigationID.GLIBC_NO_TCACHE.value],
            requires_primitives=["heap_write_primitive"],
            complicated_by=[MitigationID.SAFE_LINKING.value, MitigationID.TCACHE_KEY.value],
            provides=["arbitrary_write"],
            alternatives=["fastbin_dup", "house_of_force"],
        ),

        "tcache_poison_safe_linking": TechniqueRequirements(
            technique="tcache_poison_safe_linking",
            description="Tcache poison with safe-linking bypass (XOR with heap base)",
            blocked_by=[MitigationID.GLIBC_NO_TCACHE.value],
            requires_primitives=["heap_write_primitive", "heap_leak"],
            complicated_by=[MitigationID.TCACHE_KEY.value],
            provides=["arbitrary_write"],
            alternatives=["fastbin_dup"],
        ),

        "fastbin_dup": TechniqueRequirements(
            technique="fastbin_dup",
            description="Double-free in fastbin for arbitrary allocation",
            blocked_by=["tcache_enabled"],  # tcache intercepts small allocs
            requires_primitives=["double_free_vuln"],
            complicated_by=[MitigationID.ASLR.value],
            provides=["arbitrary_write"],
            alternatives=["tcache_poison"],
        ),

        "house_of_force": TechniqueRequirements(
            technique="house_of_force",
            description="Overflow top chunk size for arbitrary allocation",
            blocked_by=["glibc_top_chunk_check"],  # glibc 2.29+
            requires_primitives=["heap_overflow_into_top"],
            complicated_by=[MitigationID.ASLR.value],
            provides=["arbitrary_write"],
            alternatives=["house_of_orange"],
        ),

        "__malloc_hook_overwrite": TechniqueRequirements(
            technique="__malloc_hook_overwrite",
            description="Overwrite __malloc_hook with one_gadget/system",
            blocked_by=[MitigationID.GLIBC_HOOKS_REMOVED.value],
            requires_primitives=["arbitrary_write", "libc_leak"],
            complicated_by=[],
            provides=["code_execution"],
            alternatives=["__exit_funcs_overwrite", "fsop"],
        ),

        "__free_hook_overwrite": TechniqueRequirements(
            technique="__free_hook_overwrite",
            description="Overwrite __free_hook with system, free('/bin/sh')",
            blocked_by=[MitigationID.GLIBC_HOOKS_REMOVED.value],
            requires_primitives=["arbitrary_write", "libc_leak"],
            complicated_by=[],
            provides=["code_execution"],
            alternatives=["__exit_funcs_overwrite", "fsop"],
        ),

        "__exit_funcs_overwrite": TechniqueRequirements(
            technique="__exit_funcs_overwrite",
            description="Overwrite __exit_funcs for exit handler hijack",
            blocked_by=[],
            requires_primitives=["arbitrary_write", "libc_leak", "ptr_guard_leak"],
            complicated_by=[MitigationID.POINTER_MANGLING.value],
            provides=["code_execution"],
            alternatives=["fsop"],
        ),

        "fsop": TechniqueRequirements(
            technique="fsop",
            description="File Stream Oriented Programming - corrupt _IO_list_all",
            blocked_by=[],
            requires_primitives=["arbitrary_write", "libc_leak"],
            complicated_by=[MitigationID.VTABLE_VERIFICATION.value],
            provides=["code_execution"],
            alternatives=["__exit_funcs_overwrite"],
        ),

        # ─────────────────────────────────────────────────────────────────────
        # ARBITRARY WRITE TARGETS (convert arbitrary_write -> code_execution)
        # ─────────────────────────────────────────────────────────────────────
        "got_overwrite": TechniqueRequirements(
            technique="got_overwrite",
            description="Overwrite GOT entry to hijack function call",
            blocked_by=[MitigationID.FULL_RELRO.value],
            requires_primitives=["arbitrary_write", "pie_leak"],
            complicated_by=[MitigationID.PARTIAL_RELRO.value],
            provides=["code_execution"],
            alternatives=["fini_array_overwrite", "stack_return_overwrite"],
        ),

        "fini_array_overwrite": TechniqueRequirements(
            technique="fini_array_overwrite",
            description="Overwrite .fini_array for exit-time code execution",
            blocked_by=[MitigationID.FULL_RELRO.value],
            requires_primitives=["arbitrary_write", "pie_leak"],
            complicated_by=[],
            provides=["code_execution"],
            alternatives=["got_overwrite", "stack_return_overwrite"],
        ),

        "stack_return_overwrite": TechniqueRequirements(
            technique="stack_return_overwrite",
            description="Overwrite return address on stack",
            blocked_by=[],
            requires_primitives=["arbitrary_write", "stack_leak"],
            complicated_by=[MitigationID.STACK_CANARY.value],
            provides=["code_execution"],
            alternatives=["got_overwrite"],
        ),
    }


def get_technique(technique: str) -> Optional[TechniqueRequirements]:
    """
    Look up what a technique needs.

    Example:
        >>> req = get_technique("tcache_poison")
        >>> req.description
        'Corrupt tcache fd pointer to get arbitrary allocation'
    """
    return get_technique_requirements().get(technique)


def get_techniques_for_goal(goal: str) -> List[TechniqueRequirements]:
    """
    Find all techniques that provide a given capability.

    Example:
        >>> techniques = get_techniques_for_goal("code_execution")
        >>> len(techniques) > 5
        True
    """
    return [t for t in get_technique_requirements().values() if goal in t.provides]


def get_viable_techniques(
    blocked_mitigations: List[str],
    available_primitives: List[str]
) -> List[TechniqueRequirements]:
    """
    Given current mitigations and primitives, which techniques are viable?

    Args:
        blocked_mitigations: Active mitigations (e.g., ["full_relro", "glibc_hooks_removed"])
        available_primitives: Primitives we have (e.g., ["stack_overflow_vuln", "libc_leak"])

    Returns:
        List of techniques that aren't blocked and have required primitives

    Example:
        >>> viable = get_viable_techniques(["full_relro"], ["format_string_vuln", "libc_leak"])
        >>> # GOT overwrite should not be in viable list due to full_relro
        >>> any(t.technique == "got_overwrite" for t in viable)
        False
    """
    viable = []
    for tech in get_technique_requirements().values():
        # Check not blocked
        if any(b in blocked_mitigations for b in tech.blocked_by):
            continue
        # Check has required primitives
        if all(p in available_primitives for p in tech.requires_primitives):
            viable.append(tech)
    return viable


def get_missing_primitives(
    technique: str,
    available_primitives: List[str]
) -> List[str]:
    """
    What primitives do we still need for this technique?

    Example:
        >>> missing = get_missing_primitives("stack_buffer_overflow_ret2libc", ["stack_overflow_vuln"])
        >>> "libc_leak" in missing
        True
    """
    tech = get_technique(technique)
    if not tech:
        return []
    return [p for p in tech.requires_primitives if p not in available_primitives]
