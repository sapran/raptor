#!/usr/bin/env python3
"""
Constants for exploit feasibility analysis.

Centralizes magic numbers and thresholds with explanations.
"""

import subprocess


# =============================================================================
# ARCHITECTURE DETECTION
# =============================================================================

class Architecture:
    """Supported architectures and their properties."""
    X86_64 = "x86_64"
    I386 = "i386"
    AARCH64 = "aarch64"
    ARM = "arm"
    MIPS = "mips"
    MIPS64 = "mips64"
    POWERPC = "powerpc"
    POWERPC64 = "powerpc64"
    RISCV64 = "riscv64"

    # ELF machine type to architecture mapping
    ELF_MACHINE_MAP = {
        "Advanced Micro Devices X86-64": X86_64,
        "Intel 80386": I386,
        "AArch64": AARCH64,
        "ARM": ARM,
        "MIPS R3000": MIPS,
        "MIPS RS3 LE": MIPS,  # Little-endian MIPS
        "PowerPC": POWERPC,
        "PowerPC64": POWERPC64,
        "RISC-V": RISCV64,
    }

    # pwntools arch names to our canonical names
    PWNTOOLS_MAP = {
        "amd64": X86_64,
        "i386": I386,
        "aarch64": AARCH64,
        "arm": ARM,
        "mips": MIPS,
        "mips64": MIPS64,
        "powerpc": POWERPC,
        "powerpc64": POWERPC64,
    }


def detect_architecture(binary_path: str) -> str:
    """
    Detect binary architecture from ELF header.

    Uses pwntools if available, falls back to readelf.

    Args:
        binary_path: Path to ELF binary

    Returns:
        Architecture string (e.g., "x86_64", "aarch64", "arm")

    Example:
        >>> arch = detect_architecture("/bin/ls")
        >>> arch in ["x86_64", "i386", "aarch64", "arm"]
        True
    """
    # Try pwntools first (fast and reliable)
    try:
        from pwn import ELF
        import pwnlib.context as pwn_context
        pwn_context.context.log_level = 'error'

        elf = ELF(binary_path, checksec=False)
        arch = elf.arch

        # Map pwntools arch to our canonical names
        return Architecture.PWNTOOLS_MAP.get(arch, arch)
    except ImportError:
        pass
    except Exception:
        pass

    # Fallback to readelf
    try:
        result = subprocess.run(
            ['readelf', '-h', binary_path],
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                if 'Machine:' in line:
                    machine = line.split(':', 1)[1].strip()

                    # Check our mapping
                    for key, arch in Architecture.ELF_MACHINE_MAP.items():
                        if key in machine:
                            return arch

                    # Handle variations
                    machine_lower = machine.lower()
                    if 'x86-64' in machine_lower or 'amd64' in machine_lower:
                        return Architecture.X86_64
                    elif '386' in machine_lower or 'i386' in machine_lower:
                        return Architecture.I386
                    elif 'aarch64' in machine_lower or 'arm64' in machine_lower:
                        return Architecture.AARCH64
                    elif 'arm' in machine_lower:
                        return Architecture.ARM
                    elif 'mips' in machine_lower:
                        if '64' in machine_lower:
                            return Architecture.MIPS64
                        return Architecture.MIPS
                    elif 'powerpc' in machine_lower or 'ppc' in machine_lower:
                        if '64' in machine_lower:
                            return Architecture.POWERPC64
                        return Architecture.POWERPC
                    elif 'riscv' in machine_lower:
                        return Architecture.RISCV64

    except (subprocess.SubprocessError, OSError):
        pass

    # Default to x86_64 if detection fails
    return Architecture.X86_64


def get_pointer_size(arch: str) -> int:
    """
    Get pointer size in bytes for architecture.

    Example:
        >>> get_pointer_size("x86_64")
        8
        >>> get_pointer_size("i386")
        4
    """
    if arch in [Architecture.X86_64, Architecture.AARCH64, Architecture.MIPS64,
                Architecture.POWERPC64, Architecture.RISCV64]:
        return 8
    return 4


def get_endianness(arch: str) -> str:
    """
    Get default endianness for architecture.

    Returns:
        "little" or "big"

    Example:
        >>> get_endianness("x86_64")
        'little'
        >>> get_endianness("powerpc")
        'big'
    """
    # Big-endian architectures
    if arch in [Architecture.POWERPC, Architecture.POWERPC64]:
        return "big"
    # MIPS can be either, but we default to little
    return "little"

# =============================================================================
# GLIBC VERSION THRESHOLDS
# =============================================================================

class GlibcVersion:
    """Glibc versions where mitigations were introduced."""
    POINTER_MANGLING = 2.3      # PTR_MANGLE introduced
    TCACHE_INTRODUCED = 2.26    # tcache for thread-local caching
    TCACHE_KEY = 2.29           # Double-free detection via key
    SAFE_LINKING = 2.32         # fd pointer XOR (some distros 2.31)
    HOOKS_REMOVED = 2.34        # __malloc_hook/__free_hook removed
    VTABLE_VERIFICATION = 2.34  # Stricter _IO_vtable checks
    IO_FILE_HARDENED = 2.35     # Additional IO file checks
    FORMAT_N_DISABLED = 2.38    # %n disabled by default


# =============================================================================
# SUBPROCESS TIMEOUTS (milliseconds)
# =============================================================================

class Timeout:
    """Standardized subprocess timeouts in seconds."""
    FAST = 5          # Quick commands (ldd --version, cat)
    NORMAL = 10       # Standard tools (readelf, nm)
    MEDIUM = 30       # Slower tools (strings, objdump)
    SLOW = 60         # Heavy tools (one_gadget)
    VERY_SLOW = 120   # Very heavy tools (ROPgadget on large binaries)
    MAX = 300         # Maximum allowed (5 minutes)


# =============================================================================
# TARGET PRIORITY SCORES
# =============================================================================

class TargetPriority:
    """Priority scores for write targets (higher = better)."""
    GOT_COMMON_FUNC = 90     # GOT entry for commonly-called functions
    GOT_STANDARD = 80        # Standard GOT entry
    FINI_ARRAY = 70          # .fini_array[0]
    MALLOC_HOOK = 85         # __malloc_hook (if available)
    FREE_HOOK = 85           # __free_hook (if available)
    EXIT_FUNCS = 60          # __exit_funcs (needs PTR_DEMANGLE)
    RETURN_ADDR = 50         # Stack return address
    BSS_DATA = 30            # Writable data sections

    # Priority modifiers
    BAD_BYTES_PENALTY = -20  # Reduce if address has bad bytes
    COMMON_FUNC_BONUS = 10   # Bonus for commonly-called functions


# =============================================================================
# ADDRESS SPACE CONSTANTS (x86_64)
# =============================================================================

class AddressSpace:
    """x86_64 address space constants."""
    # Userland canonical address format: 0x0000000000000000 - 0x00007FFFFFFFFFFF
    # This means bytes 6-7 are ALWAYS 0x00 for userland addresses
    NULL_BYTE_POSITION_X86_64 = 6
    MAX_STRCPY_BYTES_X86_64 = 6  # Can write 6 bytes before hitting null

    # i386: 32-bit addresses may be fully non-null depending on ASLR
    NULL_BYTE_POSITION_I386 = 4
    MAX_STRCPY_BYTES_I386 = 4

    # Typical address prefixes
    PIE_PREFIX_X86_64 = 0x55     # PIE binaries often at 0x55xxxxxxxxxx
    LIBC_PREFIX_X86_64 = 0x7f   # libc usually at 0x7fxxxxxxxxxx
    STACK_PREFIX_X86_64 = 0x7f  # Stack usually at 0x7fffxxxxxxxx


# =============================================================================
# GADGET SEARCH RANGE
# =============================================================================

class GadgetSearch:
    """Constants for gadget searching."""
    # Maximum offset from base for 2-byte partial overwrite
    # Allows changing low 2 bytes while keeping high bytes same
    TWO_BYTE_RANGE = 0x10000  # 64KB - addressable with 2 bytes

    # Extended range for 3-byte partial overwrite
    THREE_BYTE_RANGE = 0x1000000  # 16MB

    # Maximum gadgets to analyze (performance limit)
    MAX_GADGETS_TO_ANALYZE = 10000

    # Minimum useful gadgets for ROP chain
    MIN_GADGETS_FOR_ROP = 10


# =============================================================================
# RELIABILITY SCORES
# =============================================================================

class Reliability:
    """Base reliability scores for primitives (0-100)."""
    VERY_HIGH = 95    # Almost always works
    HIGH = 90         # Usually works
    MEDIUM_HIGH = 85  # Works most of the time
    MEDIUM = 75       # Needs some tuning
    MEDIUM_LOW = 65   # May need multiple attempts
    LOW = 50          # Unreliable, needs luck
    VERY_LOW = 30     # Rarely works

    # Threshold for confidence levels
    THRESHOLD_HIGH = 85
    THRESHOLD_MEDIUM = 65
    THRESHOLD_LOW = 40


# =============================================================================
# CONFIDENCE ADJUSTMENTS
# =============================================================================

class ConfidenceAdjustment:
    """Confidence score adjustments for complications."""
    STACK_CANARY = -10      # Need to leak/bypass canary
    ASLR = -5               # Need address leak
    PIE = -5                # Need binary base leak
    SAFE_LINKING = -10      # Need heap leak for XOR
    TCACHE_KEY = -5         # Need to bypass key check
    FORTIFY_SOURCE = -5     # Some overflows detected
    POINTER_MANGLING = -15  # Need ptr_guard leak
    VTABLE_VERIFICATION = -10  # Need FSOP bypass


# =============================================================================
# COMMON FUNCTIONS (for prioritizing targets)
# =============================================================================

# Functions commonly called in programs - good hijack targets
COMMON_FUNCTIONS = frozenset({
    'puts', 'printf', 'fprintf', 'sprintf', 'snprintf',
    'exit', '_exit', 'abort',
    'free', 'malloc', 'calloc', 'realloc',
    'read', 'write', 'fread', 'fwrite',
    'fopen', 'fclose', 'fgets', 'fputs',
    'strlen', 'strcpy', 'strncpy', 'strcmp', 'strcat',
    'memcpy', 'memmove', 'memset', 'memcmp',
    '__stack_chk_fail',  # Triggered on stack smash - hijack for bypass
})

# Input functions that affect payload constraints
INPUT_FUNCTIONS = frozenset({
    # String functions (NUL terminates)
    'strcpy', 'strncpy', 'strcat', 'strncat', 'sprintf', 'snprintf', 'vsprintf',
    # Line-based (newline terminates)
    'gets', 'fgets', 'getline',
    # Format-based (whitespace terminates for %s)
    'scanf', 'fscanf', 'sscanf',
    # Binary-safe (length-limited)
    'read', 'fread', 'recv', 'recvfrom', 'recvmsg',
    # Format output (format string vulns)
    'printf', 'fprintf', 'vprintf', 'vfprintf',
    # Binary copy
    'memcpy', 'memmove',
})

# Functions that block techniques when string-based
STRING_TERMINATING_FUNCTIONS = frozenset({
    'strcpy', 'strcat', 'sprintf', 'gets', 'scanf',
})


# =============================================================================
# FORMAT STRING WRITE LIMITS
# =============================================================================

class FormatWriteLimits:
    """Practical limits for format string writes."""
    # Maximum practical character count for %n (4 bytes)
    # Writing 0xDEADBEEF via %n would need 3,735,928,559 characters - impractical
    MAX_PRACTICAL_N_CHARS = 100000  # ~100KB output

    # Maximum practical for %hn (2 bytes)
    # Writing 0xFFFF needs 65535 characters - usually acceptable
    MAX_HN_VALUE = 0xFFFF

    # Maximum for %hhn (1 byte) - always practical
    MAX_HHN_VALUE = 0xFF


# =============================================================================
# CACHE SETTINGS
# =============================================================================

class CacheSettings:
    """Settings for analysis caching."""
    ROP_CACHE_SIZE = 32      # Number of binaries to cache ROP results for
    ONE_GADGET_CACHE_SIZE = 16  # Number of libcs to cache one_gadget results for
    LIBC_INFO_CACHE_SIZE = 8    # Number of libc info results to cache
