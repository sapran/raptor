#!/usr/bin/env python3
"""
Vulnerability type classification and exploitability verdicts.

Provides structured enums for categorizing vulnerabilities and analysis results.
"""

from enum import Enum


class ExploitabilityVerdict(Enum):
    """Final verdict on whether exploitation is feasible."""
    EXPLOITABLE = "exploitable"
    LIKELY_EXPLOITABLE = "likely_exploitable"
    DIFFICULT = "difficult"  # Primitives exist but practical exploitation is hard
    UNLIKELY = "unlikely"  # No known viable path (but doesn't claim impossible)
    UNKNOWN = "unknown"

    def human_readable(self) -> str:
        """Return human-readable verdict string (no underscores)."""
        return VERDICT_DISPLAY[self][0]

    def description(self) -> str:
        """Return brief description of what the verdict means."""
        return VERDICT_DISPLAY[self][1]


# Human-readable display strings for verdicts
# Format: (display_name, description)
VERDICT_DISPLAY = {
    ExploitabilityVerdict.EXPLOITABLE: (
        "Exploitable",
        "Standard techniques should work"
    ),
    ExploitabilityVerdict.LIKELY_EXPLOITABLE: (
        "Likely exploitable",
        "Viable paths exist with some constraints"
    ),
    ExploitabilityVerdict.DIFFICULT: (
        "Difficult",
        "Possible but requires advanced techniques or specific conditions"
    ),
    ExploitabilityVerdict.UNLIKELY: (
        "Unlikely",
        "No known viable path given current mitigations"
    ),
    ExploitabilityVerdict.UNKNOWN: (
        "Unknown",
        "Insufficient information to assess"
    ),
}


def verdict_to_human(verdict: str) -> str:
    """
    Convert verdict string to human-readable form.

    Handles both enum values and raw strings.

    Examples:
        >>> verdict_to_human("likely_exploitable")
        'Likely exploitable'
        >>> verdict_to_human("DIFFICULT")
        'Difficult'
        >>> verdict_to_human("NOT_EXPLOITABLE")
        'Unlikely'
    """
    # Normalize input
    v = verdict.lower().strip()

    # Map various forms to canonical
    mapping = {
        'exploitable': 'Exploitable',
        'likely_exploitable': 'Likely exploitable',
        'difficult': 'Difficult',
        'unlikely': 'Unlikely',
        'not_exploitable': 'Unlikely',  # Alias
        'unknown': 'Unknown',
        'error': 'Error',
        'blocked': 'Blocked',
    }

    return mapping.get(v, v.replace('_', ' ').title())


class VulnerabilityType(Enum):
    """
    Vulnerability types for targeted mitigation checks.

    ===============================================================================
    LOCAL MEMORY CORRUPTION (specific mitigations apply per class)
    ===============================================================================

    FORMAT STRING has THREE distinct exploitation modes:

    FORMAT_STRING_WRITE (%n):
        - glibc %n disabled (2.38+): BLOCKS this entirely
        - Full RELRO: blocks GOT/.fini_array overwrite (use ret addr on stack)
        - ASLR/PIE: need info leak for target addresses
        - NX: need ROP if executing code
        - Stack canary: NOT relevant (format string skips over it)

    FORMAT_STRING_READ (%p, %s, %x):
        - ALWAYS WORKS - no glibc mitigation
        - This is an ENABLING vulnerability (info disclosure)
        - Enables: ASLR bypass, canary leak, heap pointer leak
        - Not directly exploitable for code execution

    SPRINTF_OVERFLOW (sprintf(buf, user_input)):
        - NOT blocked by %n mitigation!
        - This is a BUFFER OVERFLOW via format expansion
        - User controls format -> many %x -> output overflows buf
        - Check BUFFER OVERFLOW mitigations (canary, NX, ASLR)

    STACK_BUFFER_OVERFLOW:
        - Stack canary: BLOCKS sequential overwrite (need leak or bypass)
        - NX: blocks shellcode execution (need ROP)
        - ASLR/PIE: need info leak for ROP gadgets
        - Full RELRO: NOT directly relevant (stack-based)
        - FORTIFY_SOURCE: may catch known-size overflows

    HEAP_BUFFER_OVERFLOW:
        - glibc hooks removed (2.34+): blocks __free_hook/__malloc_hook
        - tcache hardening (2.29+): double-free detection, key checks
        - Full RELRO: blocks GOT overwrite
        - ASLR/PIE: need heap address leak
        - NX: blocks shellcode on heap
        - Stack canary: NOT relevant (heap-based)

    USE_AFTER_FREE:
        - Same as HEAP_BUFFER_OVERFLOW (heap metadata attacks)
        - Plus: ASAN detects at runtime (if compiled with)

    DOUBLE_FREE:
        - tcache hardening (2.29+): key-based detection
        - glibc fastbin checks
        - Otherwise same as heap overflow

    ===============================================================================
    ENABLING VULNERABILITIES (not directly exploitable - check CONSEQUENCE)
    ===============================================================================

    INTEGER_OVERFLOW:
        -> NOT always memory corruption! Can lead to:
          - Memory corruption (buffer overflow, heap overflow) - check those mitigations
          - Logic bugs (wrong branch, incorrect comparison results)
          - Resource issues (wrong loop bounds, allocation sizes)
          - Array OOB (not necessarily overflow - wrong index)
        -> Consequence determines which mitigations matter

    INFO_LEAK / OOB_READ:
        -> Enables: ASLR bypass, stack canary leak, heap address leak
        -> Not directly exploitable for code exec
        -> Check what the leaked info enables

    UNINITIALIZED_MEMORY:
        -> Enables: info disclosure (stack/heap contents)
        -> Similar to INFO_LEAK - check what it reveals

    NULL_DEREF:
        -> Userland: Usually just crash (SIGSEGV)
        -> Kernel: Exploitable if mmap_min_addr=0 (rare modern systems)
        -> Can enable arbitrary R/W if null page mappable

    RACE_CONDITION:
        -> Enables: depends on what's being raced
        -> File race (TOCTOU) -> privilege escalation
        -> Memory race -> UAF, double-free, corrupted state
        -> Check mitigations for the CONSEQUENCE

    SIGNEDNESS_ERROR:
        -> NOT just size calculations! Can lead to:
          - Comparison bugs (signed vs unsigned, wrong branch taken)
          - Loop issues (negative counter -> huge positive iteration count)
          - Array indexing (negative index treated as large positive)
          - Truncation issues (large value -> small type)
        -> Consequence determines which mitigations matter

    ===============================================================================
    REMOTE/WEB VULNERABILITIES (local mitigations do NOT apply)
    ===============================================================================

    SQL_INJECTION: Database-level. Defenses: parameterized queries, WAF
    XSS: Browser-side. Defenses: CSP, HttpOnly, output encoding
    SSRF: Network-level. Defenses: allowlists, network segmentation
    PATH_TRAVERSAL: File-level. Defenses: chroot, path validation, permissions
    COMMAND_INJECTION: App privileges. Defenses: seccomp, AppArmor, sandboxing
    """
    # Local memory corruption - specific mitigations per class
    # Format string has THREE distinct exploitation modes:
    FORMAT_STRING_WRITE = "format_string_write"  # %n arbitrary write - blocked by glibc 2.38+
    FORMAT_STRING_READ = "format_string_read"    # %p/%s/%x info leak - ALWAYS works (enabling)
    SPRINTF_OVERFLOW = "sprintf_overflow"        # sprintf(buf, input) overflow - buffer overflow!

    STACK_BUFFER_OVERFLOW = "stack_buffer_overflow"
    HEAP_BUFFER_OVERFLOW = "heap_buffer_overflow"
    USE_AFTER_FREE = "use_after_free"
    DOUBLE_FREE = "double_free"
    TYPE_CONFUSION = "type_confusion"

    # Enabling vulnerabilities - check consequence mitigations
    INTEGER_OVERFLOW = "integer_overflow"
    INFO_LEAK = "info_leak"              # OOB read, format string %p/%s
    UNINITIALIZED_MEMORY = "uninitialized_memory"
    NULL_DEREF = "null_dereference"
    RACE_CONDITION = "race_condition"    # TOCTOU, memory races
    SIGNEDNESS_ERROR = "signedness_error"

    # Remote/web - local mitigations do NOT apply
    COMMAND_INJECTION = "command_injection"
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    SSRF = "ssrf"
    PATH_TRAVERSAL = "path_traversal"

    UNKNOWN = "unknown"

    @classmethod
    def is_memory_corruption(cls, vuln_type: 'VulnerabilityType') -> bool:
        """Check if vulnerability type is memory corruption."""
        return vuln_type in {
            cls.FORMAT_STRING_WRITE,
            cls.SPRINTF_OVERFLOW,
            cls.STACK_BUFFER_OVERFLOW,
            cls.HEAP_BUFFER_OVERFLOW,
            cls.USE_AFTER_FREE,
            cls.DOUBLE_FREE,
            cls.TYPE_CONFUSION,
        }

    @classmethod
    def is_enabling(cls, vuln_type: 'VulnerabilityType') -> bool:
        """Check if vulnerability type is an enabling vulnerability."""
        return vuln_type in {
            cls.FORMAT_STRING_READ,
            cls.INTEGER_OVERFLOW,
            cls.INFO_LEAK,
            cls.UNINITIALIZED_MEMORY,
            cls.SIGNEDNESS_ERROR,
        }

    @classmethod
    def is_web(cls, vuln_type: 'VulnerabilityType') -> bool:
        """Check if vulnerability type is web/remote (memory mitigations don't apply)."""
        return vuln_type in {
            cls.COMMAND_INJECTION,
            cls.SQL_INJECTION,
            cls.XSS,
            cls.SSRF,
            cls.PATH_TRAVERSAL,
        }

    @classmethod
    def needs_heap_analysis(cls, vuln_type: 'VulnerabilityType') -> bool:
        """Check if vulnerability type needs heap mitigation analysis."""
        return vuln_type in {
            cls.HEAP_BUFFER_OVERFLOW,
            cls.USE_AFTER_FREE,
            cls.DOUBLE_FREE,
        }

    @classmethod
    def needs_stack_analysis(cls, vuln_type: 'VulnerabilityType') -> bool:
        """Check if vulnerability type needs stack mitigation analysis."""
        return vuln_type in {
            cls.STACK_BUFFER_OVERFLOW,
            cls.SPRINTF_OVERFLOW,
        }

    @classmethod
    def needs_format_string_analysis(cls, vuln_type: 'VulnerabilityType') -> bool:
        """Check if vulnerability type needs format string mitigation analysis."""
        return vuln_type in {
            cls.FORMAT_STRING_WRITE,
            cls.FORMAT_STRING_READ,
        }
