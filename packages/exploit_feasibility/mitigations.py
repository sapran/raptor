#!/usr/bin/env python3
"""
Mitigation classes for glibc and kernel security features.

Tracks system-level mitigations and their impact on exploitation.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import List


class MitigationImpact(Enum):
    """
    How a mitigation affects exploitation strategy.

    This classification guides exploit developers on what to do next:

    BLOCKS_TECHNIQUE:
        The mitigation completely removes a specific technique from consideration.
        Action: Use a DIFFERENT technique entirely.
        Example: __malloc_hook removed in glibc 2.34 -> can't overwrite hooks,
                 must use __exit_funcs, FSOP, or other write targets.

    REQUIRES_PRIMITIVE:
        The technique still works but needs an additional capability first.
        Action: Obtain the required primitive (usually an info leak), then proceed.
        Example: ASLR enabled -> need info leak to get addresses, then ROP works.
        Example: Safe-linking -> need heap leak to XOR fd pointers, then tcache works.

    COMPLICATES:
        Makes exploitation harder but doesn't require a specific new primitive.
        May reduce reliability, require more attempts, or need careful crafting.
        Action: Account for it in exploit, may need multiple runs or precision.
        Example: Stack canary with no leak -> may need brute force or bypass.
    """
    BLOCKS_TECHNIQUE = "blocks_technique"    # Must use different approach
    REQUIRES_PRIMITIVE = "requires_primitive"  # Need additional capability (leak, write, etc.)
    COMPLICATES = "complicates"              # Harder but no specific new requirement


@dataclass
class GlibcMitigation:
    """
    A single glibc mitigation with its impact on exploitation.

    The `impact` field determines what action the exploit developer should take:
    - BLOCKS_TECHNIQUE: Use a different technique entirely
    - REQUIRES_PRIMITIVE: Get the required primitive first, then this technique works
    - COMPLICATES: Be aware, may need adjustments
    """
    name: str
    version_introduced: float
    impact: MitigationImpact
    affected_vuln_classes: List[str]
    description: str
    blocked_techniques: List[str] = field(default_factory=list)
    required_primitive: str = ""
    bypass_requirements: List[str] = field(default_factory=list)
    alternatives: List[str] = field(default_factory=list)

    def __post_init__(self):
        """Validate mitigation properties."""
        if not self.name:
            raise ValueError("GlibcMitigation.name cannot be empty")
        if self.version_introduced < 2.0 or self.version_introduced > 3.0:
            raise ValueError(f"GlibcMitigation.version_introduced must be 2.0-3.0, got {self.version_introduced}")
        if not isinstance(self.impact, MitigationImpact):
            raise ValueError(f"GlibcMitigation.impact must be MitigationImpact, got {type(self.impact)}")

    def __repr__(self) -> str:
        return f"GlibcMitigation({self.name!r}, v{self.version_introduced}, {self.impact.name})"


@dataclass
class GlibcMitigations:
    """
    Comprehensive glibc mitigation tracking.

    Maps glibc version to security mitigations and their impact on exploitation.
    """
    version: float = 0.0
    version_string: str = ""

    # Individual mitigation status
    pointer_mangling: bool = False          # 2.3+
    tcache_enabled: bool = False            # 2.26+
    tcache_key: bool = False                # 2.29+ (double-free detection)
    safe_linking: bool = False              # 2.31+ (fd pointer XOR)
    hooks_removed: bool = False             # 2.34+ (__malloc_hook, __free_hook)
    vtable_verification: bool = False       # 2.34+ (stricter _IO_vtable checks)
    io_file_jumps_hardened: bool = False    # 2.35+
    format_n_disabled: bool = False         # 2.38+ (verified at runtime)
    format_n_verified: bool = False         # Whether we actually tested %n

    # Detailed mitigation info
    active_mitigations: List[GlibcMitigation] = field(default_factory=list)

    def __repr__(self) -> str:
        blockers = len(self.get_blockers()) if self.active_mitigations else 0
        return f"GlibcMitigations(v{self.version}, mitigations={len(self.active_mitigations)}, blockers={blockers})"

    def __post_init__(self):
        """Populate mitigations based on version."""
        if self.version <= 0:
            return

        self.active_mitigations = []

        # 2.3+: Pointer mangling
        if self.version >= 2.3:
            self.pointer_mangling = True
            self.active_mitigations.append(GlibcMitigation(
                name="Pointer Mangling (PTR_MANGLE)",
                version_introduced=2.3,
                impact=MitigationImpact.REQUIRES_PRIMITIVE,
                affected_vuln_classes=["heap", "stack", "arbitrary_write"],
                description="Function pointers in TLS are XORed with secret value",
                required_primitive="TLS pointer guard leak",
                bypass_requirements=["Leak pointer guard from TLS", "Known plaintext attack"],
                alternatives=["Target non-mangled pointers", "Overwrite GOT (if not Full RELRO)"]
            ))

        # 2.26+: tcache introduced
        if self.version >= 2.26:
            self.tcache_enabled = True
            self.active_mitigations.append(GlibcMitigation(
                name="tcache",
                version_introduced=2.26,
                impact=MitigationImpact.COMPLICATES,
                affected_vuln_classes=["heap", "double_free", "use_after_free"],
                description="Thread-local cache for small allocations - changes heap behavior",
                bypass_requirements=[],
                alternatives=["tcache poisoning (easier than fastbin)", "Fill tcache to use fastbin"]
            ))

        # 2.29+: tcache double-free detection
        if self.version >= 2.29:
            self.tcache_key = True
            self.active_mitigations.append(GlibcMitigation(
                name="tcache Key (Double-Free Detection)",
                version_introduced=2.29,
                impact=MitigationImpact.REQUIRES_PRIMITIVE,
                affected_vuln_classes=["double_free", "use_after_free"],
                description="tcache chunks contain key to detect double-free",
                required_primitive="Heap leak or UAF write to clear/forge key",
                bypass_requirements=["Heap leak to forge valid key", "Overwrite key field before free"],
                alternatives=["Use fastbin instead (fill tcache first)", "UAF write to clear key"]
            ))

        # 2.31+: Safe-linking
        if self.version >= 2.31:
            self.safe_linking = True
            self.active_mitigations.append(GlibcMitigation(
                name="Safe-Linking",
                version_introduced=2.31,
                impact=MitigationImpact.REQUIRES_PRIMITIVE,
                affected_vuln_classes=["heap", "double_free", "use_after_free", "tcache_poison"],
                description="fd pointers in tcache/fastbin XORed with (address >> 12)",
                required_primitive="Heap address leak to XOR fd pointers",
                bypass_requirements=["Heap address leak to deobfuscate/forge fd pointers"],
                alternatives=["Partial overwrite (doesn't change obfuscation)", "Unsorted bin attack (no safe-linking)"]
            ))

        # 2.34+: Hooks removed
        if self.version >= 2.34:
            self.hooks_removed = True
            self.active_mitigations.append(GlibcMitigation(
                name="__malloc_hook/__free_hook Removed",
                version_introduced=2.34,
                impact=MitigationImpact.BLOCKS_TECHNIQUE,
                affected_vuln_classes=["heap", "arbitrary_write", "format_string_write"],
                description="Hook function pointers completely removed from glibc",
                blocked_techniques=["__malloc_hook overwrite", "__free_hook overwrite", "__realloc_hook overwrite"],
                bypass_requirements=["Cannot bypass - hooks don't exist"],
                alternatives=["__exit_funcs (needs PTR_DEMANGLE)", "FSOP via _IO_list_all",
                             "Application function pointers", "Return address on stack"]
            ))

        # 2.34+: vtable verification
        if self.version >= 2.34:
            self.vtable_verification = True
            self.active_mitigations.append(GlibcMitigation(
                name="IO vtable Verification",
                version_introduced=2.34,
                impact=MitigationImpact.REQUIRES_PRIMITIVE,
                affected_vuln_classes=["file_struct", "fsop"],
                description="FILE vtables must point within __libc_IO_vtables section",
                required_primitive="Knowledge of valid vtable gadget addresses",
                bypass_requirements=["Use existing vtable gadgets within valid section",
                                   "Find vtable with useful function pointer layout"],
                alternatives=["_IO_str_overflow technique", "_IO_wfile_overflow chain",
                            "Target _wide_data pointers"]
            ))

        # 2.35+: IO file jumps hardening
        if self.version >= 2.35:
            self.io_file_jumps_hardened = True
            self.active_mitigations.append(GlibcMitigation(
                name="IO File Jumps Hardening",
                version_introduced=2.35,
                impact=MitigationImpact.COMPLICATES,
                affected_vuln_classes=["file_struct", "fsop"],
                description="Additional checks on _IO_file_jumps operations",
                bypass_requirements=["Careful FILE struct crafting", "Meet all validity checks"],
                alternatives=["House of Apple techniques", "_IO_wfile_* chains"]
            ))

        # 2.38+: %n disabled (but we verify at runtime)
        if self.version >= 2.38:
            if not self.format_n_verified:
                self.format_n_disabled = True
            self.active_mitigations.append(GlibcMitigation(
                name="%n Format Specifier Disabled",
                version_introduced=2.38,
                impact=MitigationImpact.BLOCKS_TECHNIQUE if self.format_n_disabled else MitigationImpact.COMPLICATES,
                affected_vuln_classes=["format_string_write"],
                description="%n disabled by default via FORTIFY or environment",
                blocked_techniques=["Format string arbitrary write via %n"] if self.format_n_disabled else [],
                bypass_requirements=["Cannot bypass in most configurations"],
                alternatives=["Use %s for arbitrary read", "Stack-based format string for leak only",
                            "Target older glibc via container/chroot"]
            ))

    def get_mitigations_for_vuln(self, vuln_class: str) -> List[GlibcMitigation]:
        """Get all mitigations affecting a vulnerability class."""
        return [m for m in self.active_mitigations
                if vuln_class in m.affected_vuln_classes]

    def get_blockers(self) -> List[GlibcMitigation]:
        """Get mitigations that block specific techniques entirely."""
        return [m for m in self.active_mitigations if m.impact == MitigationImpact.BLOCKS_TECHNIQUE]

    def get_primitive_requirements(self) -> List[GlibcMitigation]:
        """Get mitigations that require additional primitives."""
        return [m for m in self.active_mitigations if m.impact == MitigationImpact.REQUIRES_PRIMITIVE]

    def get_complications(self) -> List[GlibcMitigation]:
        """Get mitigations that complicate exploitation."""
        return [m for m in self.active_mitigations if m.impact == MitigationImpact.COMPLICATES]

    def summary(self) -> str:
        """Generate human-readable summary with clear action guidance."""
        lines = [f"GLIBC MITIGATIONS (version {self.version}):"]

        blockers = self.get_blockers()
        primitive_reqs = self.get_primitive_requirements()
        complications = self.get_complications()

        if blockers:
            lines.append("\n  BLOCKED TECHNIQUES (use different approach):")
            for m in blockers:
                lines.append(f"    x {m.name}")
                if m.blocked_techniques:
                    lines.append(f"      Blocks: {', '.join(m.blocked_techniques[:2])}")
                if m.alternatives:
                    lines.append(f"      Instead use: {', '.join(m.alternatives[:2])}")

        if primitive_reqs:
            lines.append("\n  REQUIRES PRIMITIVE FIRST (get this, then technique works):")
            for m in primitive_reqs:
                lines.append(f"    -> {m.name}")
                if m.required_primitive:
                    lines.append(f"      Need: {m.required_primitive}")
                elif m.bypass_requirements:
                    lines.append(f"      Need: {m.bypass_requirements[0]}")

        if complications:
            lines.append("\n  COMPLICATES (be aware, may need adjustments):")
            for m in complications:
                lines.append(f"    ~ {m.name}: {m.description}")

        return "\n".join(lines)


@dataclass
class KernelMitigation:
    """
    A single kernel mitigation with its impact on exploitation.

    The `impact` field determines what action the exploit developer should take:
    - BLOCKS_TECHNIQUE: Use a different technique entirely
    - REQUIRES_PRIMITIVE: Get the required primitive first, then this technique works
    - COMPLICATES: Be aware, may need adjustments
    """
    name: str
    sysctl_path: str
    current_value: str
    impact: MitigationImpact
    affected_vuln_classes: List[str]
    description: str
    blocked_techniques: List[str] = field(default_factory=list)
    required_primitive: str = ""
    bypass_requirements: List[str] = field(default_factory=list)
    alternatives: List[str] = field(default_factory=list)

    def __post_init__(self):
        """Validate mitigation properties."""
        if not self.name:
            raise ValueError("KernelMitigation.name cannot be empty")
        if not self.sysctl_path:
            raise ValueError("KernelMitigation.sysctl_path cannot be empty")
        if not isinstance(self.impact, MitigationImpact):
            raise ValueError(f"KernelMitigation.impact must be MitigationImpact, got {type(self.impact)}")

    def __repr__(self) -> str:
        return f"KernelMitigation({self.name!r}, {self.sysctl_path}={self.current_value}, {self.impact.name})"


@dataclass
class KernelMitigations:
    """
    Comprehensive kernel mitigation tracking via sysctl.

    Reads /proc/sys values to determine kernel hardening state.
    """
    kernel_version: str = ""

    # ASLR
    aslr_level: int = 0  # 0=off, 1=partial, 2=full
    mmap_min_addr: int = 0

    # Pointer/info restrictions
    kptr_restrict: int = 0  # 0=off, 1=hide from non-root, 2=hide from all
    dmesg_restrict: int = 0
    perf_event_paranoid: int = 0

    # Privilege restrictions
    ptrace_scope: int = 0  # YAMA: 0=classic, 1=restricted, 2=admin-only, 3=disabled
    unprivileged_bpf_disabled: int = 0
    unprivileged_userns_clone: int = 1  # 1=allowed, 0=disabled

    # Module/kexec
    modules_disabled: int = 0
    kexec_load_disabled: int = 0

    # Filesystem protections
    protected_symlinks: int = 0
    protected_hardlinks: int = 0
    protected_fifos: int = 0
    protected_regular: int = 0
    suid_dumpable: int = 0

    # Exec protections
    exec_shield: int = 0  # Older systems

    # Detailed mitigation info
    active_mitigations: List[KernelMitigation] = field(default_factory=list)

    def __repr__(self) -> str:
        blockers = len(self.get_blockers()) if self.active_mitigations else 0
        return f"KernelMitigations(aslr={self.aslr_level}, mitigations={len(self.active_mitigations)}, blockers={blockers})"

    def __post_init__(self):
        """Populate mitigations based on sysctl values."""
        self.active_mitigations = []

        # ASLR
        if self.aslr_level >= 2:
            self.active_mitigations.append(KernelMitigation(
                name="ASLR Full",
                sysctl_path="kernel.randomize_va_space",
                current_value=str(self.aslr_level),
                impact=MitigationImpact.REQUIRES_PRIMITIVE,
                affected_vuln_classes=["stack", "heap", "format_string", "rop"],
                description="Full ASLR - stack, heap, mmap, and PIE randomized",
                required_primitive="info leak (stack, libc, or heap address)",
                bypass_requirements=["Info leak to disclose addresses", "Brute force (32-bit only practical)"],
                alternatives=["Partial overwrite (low bytes predictable)", "Return-to-PLT (no PIE leak needed)"]
            ))
        elif self.aslr_level == 1:
            self.active_mitigations.append(KernelMitigation(
                name="ASLR Partial",
                sysctl_path="kernel.randomize_va_space",
                current_value=str(self.aslr_level),
                impact=MitigationImpact.REQUIRES_PRIMITIVE,
                affected_vuln_classes=["stack", "heap"],
                description="Partial ASLR - stack and libraries randomized, heap may be predictable",
                required_primitive="info leak for stack/libc addresses",
                bypass_requirements=["Info leak for stack/libc addresses"],
                alternatives=["Target non-randomized regions"]
            ))

        # mmap_min_addr
        if self.mmap_min_addr > 0:
            self.active_mitigations.append(KernelMitigation(
                name="mmap_min_addr Protection",
                sysctl_path="vm.mmap_min_addr",
                current_value=str(self.mmap_min_addr),
                impact=MitigationImpact.BLOCKS_TECHNIQUE if self.mmap_min_addr >= 65536 else MitigationImpact.COMPLICATES,
                affected_vuln_classes=["null_deref", "kernel"],
                description=f"Cannot mmap below {self.mmap_min_addr} - blocks NULL pointer exploits",
                blocked_techniques=["NULL page mapping", "NULL pointer dereference exploitation"],
                bypass_requirements=["Cannot map NULL page from userspace"],
                alternatives=["Find different exploit primitive", "Kernel exploit if kernel NULL deref"]
            ))

        # Pointer restrictions (kernel info leaks)
        if self.kptr_restrict >= 1:
            self.active_mitigations.append(KernelMitigation(
                name="Kernel Pointer Restriction",
                sysctl_path="kernel.kptr_restrict",
                current_value=str(self.kptr_restrict),
                impact=MitigationImpact.REQUIRES_PRIMITIVE,
                affected_vuln_classes=["kernel", "privilege_escalation"],
                description=f"/proc/kallsyms hidden (level {self.kptr_restrict})",
                required_primitive="kernel address leak (side-channel or vuln)",
                bypass_requirements=["Side-channel leak", "Kernel info leak vulnerability"],
                alternatives=["Exploit without knowing kernel addresses (rare)"]
            ))

        if self.dmesg_restrict >= 1:
            self.active_mitigations.append(KernelMitigation(
                name="dmesg Restriction",
                sysctl_path="kernel.dmesg_restrict",
                current_value=str(self.dmesg_restrict),
                impact=MitigationImpact.COMPLICATES,
                affected_vuln_classes=["kernel", "info_leak"],
                description="dmesg requires CAP_SYSLOG - can't leak kernel info via dmesg",
                bypass_requirements=["Root or CAP_SYSLOG"],
                alternatives=["Other info leak sources"]
            ))

        # ptrace restrictions (YAMA)
        if self.ptrace_scope >= 1:
            if self.ptrace_scope >= 2:
                impact = MitigationImpact.BLOCKS_TECHNIQUE
                blocked = ["ptrace-based process injection", "ptrace debugging of non-descendants"]
            else:
                impact = MitigationImpact.COMPLICATES
                blocked = []
            self.active_mitigations.append(KernelMitigation(
                name="YAMA ptrace Restriction",
                sysctl_path="kernel.yama.ptrace_scope",
                current_value=str(self.ptrace_scope),
                impact=impact,
                affected_vuln_classes=["process_injection", "debugging", "credential_theft"],
                description=f"ptrace scope {self.ptrace_scope}: " + {
                    1: "Can only ptrace descendants",
                    2: "Only CAP_SYS_PTRACE can ptrace",
                    3: "ptrace completely disabled"
                }.get(self.ptrace_scope, "restricted"),
                blocked_techniques=blocked,
                bypass_requirements=["CAP_SYS_PTRACE capability"] if self.ptrace_scope < 3 else ["Cannot bypass"],
                alternatives=["LD_PRELOAD injection", "Exploit target directly"]
            ))

        # BPF restrictions
        if self.unprivileged_bpf_disabled >= 1:
            self.active_mitigations.append(KernelMitigation(
                name="Unprivileged BPF Disabled",
                sysctl_path="kernel.unprivileged_bpf_disabled",
                current_value=str(self.unprivileged_bpf_disabled),
                impact=MitigationImpact.BLOCKS_TECHNIQUE,
                affected_vuln_classes=["bpf", "kernel", "container_escape"],
                description="Unprivileged users cannot load BPF programs",
                blocked_techniques=["unprivileged BPF program loading", "BPF-based kernel exploits"],
                bypass_requirements=["CAP_BPF or CAP_SYS_ADMIN"],
                alternatives=["Non-BPF kernel exploit", "Target BPF-capable process"]
            ))

        # User namespaces
        if self.unprivileged_userns_clone == 0:
            self.active_mitigations.append(KernelMitigation(
                name="Unprivileged User Namespaces Disabled",
                sysctl_path="kernel.unprivileged_userns_clone",
                current_value=str(self.unprivileged_userns_clone),
                impact=MitigationImpact.BLOCKS_TECHNIQUE,
                affected_vuln_classes=["container_escape", "privilege_escalation", "sandbox_escape"],
                description="Cannot create user namespaces without privileges",
                blocked_techniques=["user namespace creation", "userns-based privilege escalation"],
                bypass_requirements=["CAP_SYS_ADMIN"],
                alternatives=["Exploit that doesn't require userns"]
            ))

        # Module loading
        if self.modules_disabled >= 1:
            self.active_mitigations.append(KernelMitigation(
                name="Module Loading Disabled",
                sysctl_path="kernel.modules_disabled",
                current_value=str(self.modules_disabled),
                impact=MitigationImpact.BLOCKS_TECHNIQUE,
                affected_vuln_classes=["kernel", "rootkit", "privilege_escalation"],
                description="Cannot load kernel modules (even as root)",
                blocked_techniques=["kernel module loading", "rootkit installation via module"],
                bypass_requirements=["Reboot required to re-enable"],
                alternatives=["Exploit existing kernel code"]
            ))

        if self.kexec_load_disabled >= 1:
            self.active_mitigations.append(KernelMitigation(
                name="kexec Disabled",
                sysctl_path="kernel.kexec_load_disabled",
                current_value=str(self.kexec_load_disabled),
                impact=MitigationImpact.BLOCKS_TECHNIQUE,
                affected_vuln_classes=["kernel", "secure_boot_bypass"],
                description="Cannot load new kernel via kexec",
                blocked_techniques=["kexec kernel loading", "secure boot bypass via kexec"],
                bypass_requirements=["Reboot required"],
                alternatives=["Standard kernel exploit"]
            ))

        # Filesystem protections
        if self.protected_symlinks >= 1:
            self.active_mitigations.append(KernelMitigation(
                name="Symlink Protection",
                sysctl_path="fs.protected_symlinks",
                current_value=str(self.protected_symlinks),
                impact=MitigationImpact.COMPLICATES,
                affected_vuln_classes=["race_condition", "symlink_attack", "privilege_escalation"],
                description="Symlinks in sticky dirs only followed if owner matches",
                bypass_requirements=["Own the symlink or target"],
                alternatives=["Different race condition vector", "Hardlink attack"]
            ))

        if self.protected_hardlinks >= 1:
            self.active_mitigations.append(KernelMitigation(
                name="Hardlink Protection",
                sysctl_path="fs.protected_hardlinks",
                current_value=str(self.protected_hardlinks),
                impact=MitigationImpact.COMPLICATES,
                affected_vuln_classes=["race_condition", "hardlink_attack", "privilege_escalation"],
                description="Cannot hardlink files you don't own/can't read",
                bypass_requirements=["Own the file or have read access"],
                alternatives=["Symlink attack (if not protected)", "Different vector"]
            ))

        # Core dump restrictions
        if self.suid_dumpable == 0:
            self.active_mitigations.append(KernelMitigation(
                name="SUID Core Dump Disabled",
                sysctl_path="fs.suid_dumpable",
                current_value=str(self.suid_dumpable),
                impact=MitigationImpact.COMPLICATES,
                affected_vuln_classes=["credential_theft", "info_leak"],
                description="SUID processes don't dump core - can't extract credentials",
                bypass_requirements=["Exploit the SUID binary directly"],
                alternatives=["Memory disclosure via other means"]
            ))

        # Perf restrictions
        if self.perf_event_paranoid >= 2:
            impact = MitigationImpact.BLOCKS_TECHNIQUE if self.perf_event_paranoid >= 3 else MitigationImpact.COMPLICATES
            blocked = ["perf_event-based side channels"] if self.perf_event_paranoid >= 3 else []
            self.active_mitigations.append(KernelMitigation(
                name="Perf Event Restriction",
                sysctl_path="kernel.perf_event_paranoid",
                current_value=str(self.perf_event_paranoid),
                impact=impact,
                affected_vuln_classes=["side_channel", "kernel", "info_leak"],
                description=f"perf_event_paranoid={self.perf_event_paranoid}: " + {
                    2: "No kernel profiling",
                    3: "No perf_event access at all"
                }.get(self.perf_event_paranoid, "restricted"),
                blocked_techniques=blocked,
                bypass_requirements=["CAP_SYS_ADMIN for kernel profiling"],
                alternatives=["Other side-channel techniques"]
            ))

    def get_mitigations_for_vuln(self, vuln_class: str) -> List[KernelMitigation]:
        """Get all mitigations affecting a vulnerability class."""
        return [m for m in self.active_mitigations
                if vuln_class in m.affected_vuln_classes]

    def get_blockers(self) -> List[KernelMitigation]:
        """Get mitigations that block specific techniques entirely."""
        return [m for m in self.active_mitigations if m.impact == MitigationImpact.BLOCKS_TECHNIQUE]

    def get_primitive_requirements(self) -> List[KernelMitigation]:
        """Get mitigations that require additional primitives."""
        return [m for m in self.active_mitigations if m.impact == MitigationImpact.REQUIRES_PRIMITIVE]

    def get_complications(self) -> List[KernelMitigation]:
        """Get mitigations that complicate exploitation."""
        return [m for m in self.active_mitigations if m.impact == MitigationImpact.COMPLICATES]

    def summary(self) -> str:
        """Generate human-readable summary with clear action guidance."""
        lines = ["KERNEL MITIGATIONS:"]

        blockers = self.get_blockers()
        primitive_reqs = self.get_primitive_requirements()
        complications = self.get_complications()

        if blockers:
            lines.append("\n  BLOCKED TECHNIQUES (use different approach):")
            for m in blockers:
                lines.append(f"    x {m.name} ({m.sysctl_path}={m.current_value})")
                if m.blocked_techniques:
                    lines.append(f"      Blocks: {', '.join(m.blocked_techniques[:2])}")
                if m.alternatives:
                    lines.append(f"      Instead use: {', '.join(m.alternatives[:2])}")

        if primitive_reqs:
            lines.append("\n  REQUIRES PRIMITIVE FIRST (get this, then technique works):")
            for m in primitive_reqs:
                lines.append(f"    -> {m.name} ({m.sysctl_path}={m.current_value})")
                if m.required_primitive:
                    lines.append(f"      Need: {m.required_primitive}")
                elif m.bypass_requirements:
                    lines.append(f"      Need: {m.bypass_requirements[0]}")

        if complications:
            lines.append("\n  COMPLICATES (be aware, may need adjustments):")
            for m in complications:
                lines.append(f"    ~ {m.name}: {m.description}")

        if not blockers and not primitive_reqs and not complications:
            lines.append("  No significant kernel mitigations detected")

        return "\n".join(lines)
