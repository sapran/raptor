#!/usr/bin/env python3
"""
Configuration management for exploit feasibility analysis.

Provides a centralized config system with defaults, environment overrides,
and file-based configuration.
"""

import os
import json
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

from .constants import Timeout


@dataclass
class AnalysisConfig:
    """
    Configuration for feasibility analysis.

    Settings can be overridden via:
    1. Constructor arguments
    2. Config file (JSON)
    3. Environment variables (RAPTOR_* prefix)
    """

    # Tool paths (empty = use PATH)
    checksec_path: str = ""
    ropgadget_path: str = ""
    one_gadget_path: str = ""

    # Timeouts (seconds)
    timeout_fast: int = Timeout.FAST
    timeout_normal: int = Timeout.NORMAL
    timeout_medium: int = Timeout.MEDIUM
    timeout_slow: int = Timeout.SLOW
    timeout_very_slow: int = Timeout.VERY_SLOW
    timeout_max: int = Timeout.MAX

    # Cache settings
    enable_caching: bool = True
    cache_dir: str = ""  # Empty = use temp dir
    rop_cache_size: int = 32
    one_gadget_cache_size: int = 16
    libc_cache_size: int = 8

    # Analysis settings
    max_gadgets_to_analyze: int = 10000
    max_write_targets: int = 50
    verify_format_n_empirically: bool = True
    sample_address_space: bool = True

    # Output settings
    verbose: bool = False
    include_raw_gadgets: bool = False
    max_raw_gadgets_in_output: int = 100

    # Bad byte detection
    default_bad_bytes: List[int] = field(default_factory=lambda: [0x00])

    def __repr__(self) -> str:
        return (
            f"AnalysisConfig(timeout_fast={self.timeout_fast}, "
            f"timeout_slow={self.timeout_slow}, "
            f"enable_caching={self.enable_caching}, "
            f"verbose={self.verbose})"
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AnalysisConfig':
        """Create config from dictionary."""
        config = cls()
        for key, value in data.items():
            if hasattr(config, key):
                setattr(config, key, value)
        return config

    @classmethod
    def from_file(cls, path: str) -> 'AnalysisConfig':
        """Load config from JSON file."""
        with open(path, 'r') as f:
            data = json.load(f)
        return cls.from_dict(data)

    @classmethod
    def from_env(cls) -> 'AnalysisConfig':
        """
        Create config from environment variables.

        Environment variables use RAPTOR_ prefix:
        - RAPTOR_TIMEOUT_FAST
        - RAPTOR_VERBOSE
        - RAPTOR_CACHE_DIR
        etc.
        """
        config = cls()

        env_mapping = {
            'RAPTOR_CHECKSEC_PATH': ('checksec_path', str),
            'RAPTOR_ROPGADGET_PATH': ('ropgadget_path', str),
            'RAPTOR_ONE_GADGET_PATH': ('one_gadget_path', str),
            'RAPTOR_TIMEOUT_FAST': ('timeout_fast', int),
            'RAPTOR_TIMEOUT_NORMAL': ('timeout_normal', int),
            'RAPTOR_TIMEOUT_MEDIUM': ('timeout_medium', int),
            'RAPTOR_TIMEOUT_SLOW': ('timeout_slow', int),
            'RAPTOR_TIMEOUT_VERY_SLOW': ('timeout_very_slow', int),
            'RAPTOR_TIMEOUT_MAX': ('timeout_max', int),
            'RAPTOR_ENABLE_CACHING': ('enable_caching', lambda x: x.lower() == 'true'),
            'RAPTOR_CACHE_DIR': ('cache_dir', str),
            'RAPTOR_ROP_CACHE_SIZE': ('rop_cache_size', int),
            'RAPTOR_MAX_GADGETS': ('max_gadgets_to_analyze', int),
            'RAPTOR_VERIFY_FORMAT_N': ('verify_format_n_empirically', lambda x: x.lower() == 'true'),
            'RAPTOR_VERBOSE': ('verbose', lambda x: x.lower() == 'true'),
        }

        for env_var, (attr, converter) in env_mapping.items():
            value = os.environ.get(env_var)
            if value is not None:
                try:
                    setattr(config, attr, converter(value))
                except (ValueError, TypeError):
                    pass  # Ignore invalid env values

        return config

    def to_dict(self) -> Dict[str, Any]:
        """Export config to dictionary."""
        return {
            'checksec_path': self.checksec_path,
            'ropgadget_path': self.ropgadget_path,
            'one_gadget_path': self.one_gadget_path,
            'timeout_fast': self.timeout_fast,
            'timeout_normal': self.timeout_normal,
            'timeout_medium': self.timeout_medium,
            'timeout_slow': self.timeout_slow,
            'timeout_very_slow': self.timeout_very_slow,
            'timeout_max': self.timeout_max,
            'enable_caching': self.enable_caching,
            'cache_dir': self.cache_dir,
            'rop_cache_size': self.rop_cache_size,
            'one_gadget_cache_size': self.one_gadget_cache_size,
            'libc_cache_size': self.libc_cache_size,
            'max_gadgets_to_analyze': self.max_gadgets_to_analyze,
            'max_write_targets': self.max_write_targets,
            'verify_format_n_empirically': self.verify_format_n_empirically,
            'sample_address_space': self.sample_address_space,
            'verbose': self.verbose,
            'include_raw_gadgets': self.include_raw_gadgets,
            'max_raw_gadgets_in_output': self.max_raw_gadgets_in_output,
            'default_bad_bytes': self.default_bad_bytes,
        }

    def save(self, path: str) -> None:
        """Save config to JSON file."""
        with open(path, 'w') as f:
            json.dump(self.to_dict(), f, indent=2)

    def merge(self, other: 'AnalysisConfig') -> 'AnalysisConfig':
        """
        Merge with another config, preferring non-default values from other.

        Returns a new config instance.
        """
        result = AnalysisConfig()
        default = AnalysisConfig()

        for key in self.to_dict().keys():
            self_val = getattr(self, key)
            other_val = getattr(other, key)
            default_val = getattr(default, key)

            # If other has non-default value, use it
            if other_val != default_val:
                setattr(result, key, other_val)
            else:
                setattr(result, key, self_val)

        return result


# Global config instance (singleton)
_global_config: Optional[AnalysisConfig] = None


def get_config() -> AnalysisConfig:
    """Get the global config instance."""
    global _global_config
    if _global_config is None:
        _global_config = AnalysisConfig.from_env()
    return _global_config


def set_config(config: AnalysisConfig) -> None:
    """Set the global config instance."""
    global _global_config
    _global_config = config


def reset_config() -> None:
    """Reset to default config."""
    global _global_config
    _global_config = None


def load_config(path: Optional[str] = None) -> AnalysisConfig:
    """
    Load config from file and/or environment.

    Search order:
    1. Explicit path argument
    2. RAPTOR_CONFIG environment variable
    3. .raptor.json in current directory
    4. ~/.config/raptor/config.json

    Environment variables override file settings.
    """
    config = AnalysisConfig()

    # Find config file
    config_path = path
    if config_path is None:
        config_path = os.environ.get('RAPTOR_CONFIG')
    if config_path is None:
        local_config = Path('.raptor.json')
        if local_config.exists():
            config_path = str(local_config)
    if config_path is None:
        user_config = Path.home() / '.config' / 'raptor' / 'config.json'
        if user_config.exists():
            config_path = str(user_config)

    # Load from file if found
    if config_path and Path(config_path).exists():
        config = AnalysisConfig.from_file(config_path)

    # Apply environment overrides
    env_config = AnalysisConfig.from_env()
    config = config.merge(env_config)

    set_config(config)
    return config
