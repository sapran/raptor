#!/usr/bin/env python3
"""
Binary-specific exploitation targets.

This module connects abstract techniques to concrete binary targets.
The agent gets actionable output: "GOT[puts] at 0x404020 is viable for overwrite"
rather than just "Full RELRO blocks GOT overwrite"
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from .mitigations import ROPGadgetInfo


@dataclass
class BinaryTarget:
    """
    A specific exploitation target in the binary.

    This ties abstract techniques (e.g., "got_overwrite") to concrete
    addresses and feasibility assessment.

    Example:
        >>> target = BinaryTarget(
        ...     name="GOT[puts]",
        ...     address=0x404020,
        ...     target_type="got_entry",
        ...     technique="got_overwrite",
        ...     viable=True,
        ...     priority=90
        ... )
        >>> str(target)
        'GOT[puts] @ 0x404020 [VIABLE]'
    """
    name: str
    address: int
    target_type: str  # "got_entry", "fini_array", "return_address", "function_pointer", "hook"
    technique: str    # Which technique uses this target

    # Feasibility
    viable: bool = True
    blocked_by: List[str] = field(default_factory=list)
    requires: List[str] = field(default_factory=list)

    # Address quality
    has_bad_bytes: bool = False
    bad_byte_positions: List[int] = field(default_factory=list)

    # Current value analysis (for partial overwrite feasibility)
    current_value: Optional[int] = None
    current_value_type: str = ""      # "pie_addr", "libc_addr", "heap_addr", "unknown"
    target_value_type: str = ""       # What we need to write
    partial_overwrite_viable: bool = True
    partial_overwrite_bytes_needed: int = 0

    # Notes for exploit dev
    notes: str = ""
    priority: int = 0

    def __str__(self) -> str:
        status = "VIABLE" if self.viable else "BLOCKED"
        blockers = f" ({', '.join(self.blocked_by)})" if self.blocked_by else ""
        return f"{self.name} @ 0x{self.address:x} [{status}{blockers}]"


@dataclass
class GadgetQuality:
    """
    Assessment of ROP gadget availability for the binary.

    Not just "do gadgets exist" but "are they usable for the target technique"

    Example:
        >>> quality = GadgetQuality(
        ...     can_control_rdi=True,
        ...     can_control_rsi=True,
        ...     total_gadgets=500,
        ...     usable_after_bad_byte_filter=450
        ... )
        >>> quality.can_ret2libc
        True
    """
    # Essential gadgets for common techniques
    can_control_rdi: bool = False  # pop rdi; ret - needed for system("/bin/sh")
    can_control_rsi: bool = False  # pop rsi; ret - needed for read/write syscalls
    can_control_rdx: bool = False  # pop rdx; ret - often harder to find
    can_control_rax: bool = False  # pop rax; ret - needed for syscall number
    has_syscall_ret: bool = False  # syscall; ret - for execve syscall

    # Stack pivot gadgets
    has_stack_pivot: bool = False
    pivot_gadgets: List[str] = field(default_factory=list)

    # Gadget addresses (offset from binary base if PIE)
    gadget_addresses: Dict[str, int] = field(default_factory=dict)

    # Quality metrics
    total_gadgets: int = 0
    usable_after_bad_byte_filter: int = 0
    bad_bytes: List[int] = field(default_factory=list)

    # What's possible with these gadgets
    can_execve_rop: bool = False
    can_ret2libc: bool = False
    can_mprotect_shellcode: bool = False

    def __post_init__(self):
        """Calculate capabilities based on available gadgets."""
        # ret2libc: need pop rdi (for "/bin/sh") + ret (stack alignment)
        self.can_ret2libc = self.can_control_rdi and 'ret' in self.gadget_addresses

        # Full execve ROP: need pop rdi, rsi, rdx, rax + syscall
        self.can_execve_rop = (
            self.can_control_rdi and
            self.can_control_rsi and
            self.can_control_rdx and
            self.can_control_rax and
            self.has_syscall_ret
        )

        # mprotect + shellcode: same requirements as execve
        self.can_mprotect_shellcode = self.can_execve_rop

    def summary(self) -> str:
        """Human-readable summary."""
        lines = ["GADGET QUALITY:"]
        capabilities = []
        if self.can_ret2libc:
            capabilities.append("ret2libc")
        if self.can_execve_rop:
            capabilities.append("execve ROP")
        if self.can_mprotect_shellcode:
            capabilities.append("mprotect+shellcode")
        if self.has_stack_pivot:
            capabilities.append("stack pivot")

        if capabilities:
            lines.append(f"  Capable of: {', '.join(capabilities)}")
        else:
            lines.append("  [!] Limited ROP capabilities")

        lines.append(f"  Total: {self.total_gadgets}, Usable: {self.usable_after_bad_byte_filter}")

        missing = []
        if not self.can_control_rdi:
            missing.append("pop rdi")
        if not self.can_control_rsi:
            missing.append("pop rsi")
        if not self.can_control_rdx:
            missing.append("pop rdx")
        if not self.has_syscall_ret:
            missing.append("syscall; ret")
        if missing:
            lines.append(f"  Missing: {', '.join(missing)}")

        return "\n".join(lines)


@dataclass
class BinarySpecificAnalysis:
    """
    Complete binary-specific analysis tying mitigations to actual targets.

    This is what the agent uses to plan: concrete addresses, feasibility,
    and actionable recommendations.

    Example:
        >>> analysis = BinarySpecificAnalysis(
        ...     binary_path="/path/to/binary",
        ...     has_full_relro=True,
        ...     has_pie=True
        ... )
        >>> analysis.has_full_relro
        True
    """
    binary_path: str

    # Binary protections
    has_full_relro: bool = False
    has_partial_relro: bool = False
    has_pie: bool = False
    has_nx: bool = False
    has_canary: bool = False

    # Specific targets found in the binary
    targets: List[BinaryTarget] = field(default_factory=list)

    # Gadget quality assessment
    gadgets: Optional[GadgetQuality] = None

    # Categorized targets for quick lookup
    got_targets: List[BinaryTarget] = field(default_factory=list)
    fini_array_targets: List[BinaryTarget] = field(default_factory=list)
    other_targets: List[BinaryTarget] = field(default_factory=list)

    # Viable techniques based on this binary
    viable_techniques: List[str] = field(default_factory=list)
    blocked_techniques: Dict[str, str] = field(default_factory=dict)

    def get_viable_targets(self) -> List[BinaryTarget]:
        """Get all targets that aren't blocked by mitigations."""
        return [t for t in self.targets if t.viable]

    def get_targets_for_technique(self, technique: str) -> List[BinaryTarget]:
        """Get targets usable with a specific technique."""
        return [t for t in self.targets if t.technique == technique and t.viable]

    def get_best_target(self) -> Optional[BinaryTarget]:
        """Get the highest priority viable target."""
        viable = self.get_viable_targets()
        if not viable:
            return None
        return max(viable, key=lambda t: t.priority)

    def summary(self) -> str:
        """Human-readable summary."""
        lines = ["BINARY-SPECIFIC ANALYSIS:"]
        lines.append(f"  Binary: {self.binary_path}")

        # Protections summary
        prots = []
        if self.has_full_relro:
            prots.append("Full RELRO")
        elif self.has_partial_relro:
            prots.append("Partial RELRO")
        if self.has_pie:
            prots.append("PIE")
        if self.has_nx:
            prots.append("NX")
        if self.has_canary:
            prots.append("Canary")
        lines.append(f"  Protections: {', '.join(prots) if prots else 'None'}")

        # Viable targets
        viable = self.get_viable_targets()
        if viable:
            lines.append(f"  Viable targets ({len(viable)}):")
            for t in sorted(viable, key=lambda x: -x.priority)[:5]:
                req_str = f" [needs: {', '.join(t.requires)}]" if t.requires else ""
                lines.append(f"    {t.name} @ 0x{t.address:x}{req_str}")
        else:
            lines.append("  [!] No viable write targets found")

        # Blocked targets
        blocked = [t for t in self.targets if not t.viable]
        if blocked:
            lines.append(f"  Blocked targets ({len(blocked)}):")
            for t in blocked[:3]:
                lines.append(f"    {t.name}: {', '.join(t.blocked_by)}")

        # Viable techniques
        if self.viable_techniques:
            lines.append(f"  Viable techniques: {', '.join(self.viable_techniques[:5])}")
        if self.blocked_techniques:
            lines.append(f"  Blocked techniques: {', '.join(list(self.blocked_techniques.keys())[:3])}")

        return "\n".join(lines)


def analyze_gadget_quality(
    rop_info: 'ROPGadgetInfo',
    bad_bytes: Optional[List[int]] = None
) -> GadgetQuality:
    """
    Assess ROP gadget quality for technique viability.

    Transforms raw gadget list into actionable capability assessment.

    Args:
        rop_info: ROPGadgetInfo from analyzer
        bad_bytes: Bytes that cannot appear in addresses

    Returns:
        GadgetQuality assessment

    Example:
        >>> # Note: Requires actual ROPGadgetInfo from analysis
        >>> # quality = analyze_gadget_quality(rop_info, [0x00])
        >>> # quality.can_ret2libc  # True if pop rdi + ret found
    """
    bad_bytes = bad_bytes or [0x00]

    quality = GadgetQuality(
        total_gadgets=rop_info.total_gadgets,
        usable_after_bad_byte_filter=rop_info.usable_gadgets,
        bad_bytes=bad_bytes,
    )

    # Check essential gadgets
    if rop_info.pop_rdi_ret:
        quality.can_control_rdi = True
        quality.gadget_addresses['pop_rdi_ret'] = rop_info.pop_rdi_ret

    if rop_info.pop_rsi_ret:
        quality.can_control_rsi = True
        quality.gadget_addresses['pop_rsi_ret'] = rop_info.pop_rsi_ret

    if rop_info.pop_rdx_ret:
        quality.can_control_rdx = True
        quality.gadget_addresses['pop_rdx_ret'] = rop_info.pop_rdx_ret

    if rop_info.pop_rax_ret:
        quality.can_control_rax = True
        quality.gadget_addresses['pop_rax_ret'] = rop_info.pop_rax_ret

    if rop_info.syscall_ret:
        quality.has_syscall_ret = True
        quality.gadget_addresses['syscall_ret'] = rop_info.syscall_ret

    if rop_info.ret:
        quality.gadget_addresses['ret'] = rop_info.ret

    # Calculate capabilities
    quality.can_ret2libc = quality.can_control_rdi and 'ret' in quality.gadget_addresses
    quality.can_execve_rop = (
        quality.can_control_rdi and
        quality.can_control_rsi and
        quality.can_control_rdx and
        quality.can_control_rax and
        quality.has_syscall_ret
    )
    quality.can_mprotect_shellcode = quality.can_execve_rop

    # Look for stack pivot gadgets
    # Check named gadgets first
    if rop_info.leave_ret:
        quality.has_stack_pivot = True
        quality.pivot_gadgets.append(f"0x{rop_info.leave_ret:x}: leave ; ret")
    if rop_info.pop_rsp_ret:
        quality.has_stack_pivot = True
        quality.pivot_gadgets.append(f"0x{rop_info.pop_rsp_ret:x}: pop rsp ; ret")

    # Then check all_gadgets for additional pivot gadgets
    pivot_patterns = ['xchg', 'mov rsp', 'add rsp']
    for gadget_info in rop_info.all_gadgets[:100]:  # Check first 100
        if isinstance(gadget_info, dict):
            addr = gadget_info.get('address', 0)
            gadget = gadget_info.get('instruction', gadget_info.get('instructions', ''))
        else:
            # Handle legacy tuple format (addr, gadget) if present
            addr, gadget = gadget_info if isinstance(gadget_info, tuple) else (0, str(gadget_info))
        if any(p in gadget.lower() for p in pivot_patterns):
            quality.has_stack_pivot = True
            quality.pivot_gadgets.append(f"0x{addr:x}: {gadget}")

    return quality


def assess_technique_viability(analysis: BinarySpecificAnalysis) -> None:
    """
    Assess which techniques are viable for this binary.

    Modifies analysis in place to populate viable_techniques and blocked_techniques.

    Example:
        >>> analysis = BinarySpecificAnalysis(
        ...     binary_path="/path/to/binary",
        ...     has_full_relro=True
        ... )
        >>> assess_technique_viability(analysis)
        >>> "got_overwrite" in analysis.blocked_techniques
        True
    """
    # GOT overwrite
    if analysis.has_full_relro:
        analysis.blocked_techniques["got_overwrite"] = "Full RELRO makes GOT read-only"
        analysis.blocked_techniques["format_string_got_overwrite"] = "Full RELRO makes GOT read-only"
    else:
        analysis.viable_techniques.append("got_overwrite")
        analysis.viable_techniques.append("format_string_got_overwrite")

    # fini_array overwrite
    if analysis.has_full_relro:
        analysis.blocked_techniques["fini_array_overwrite"] = "Full RELRO makes .fini_array read-only"
        analysis.blocked_techniques["format_string_fini_array"] = "Full RELRO makes .fini_array read-only"
    else:
        analysis.viable_techniques.append("fini_array_overwrite")
        analysis.viable_techniques.append("format_string_fini_array")

    # Shellcode execution
    if analysis.has_nx:
        analysis.blocked_techniques["stack_buffer_overflow_shellcode"] = "NX prevents shellcode execution"
    else:
        analysis.viable_techniques.append("stack_buffer_overflow_shellcode")

    # ROP is always viable (with gadgets)
    analysis.viable_techniques.append("stack_buffer_overflow_rop")
    analysis.viable_techniques.append("stack_buffer_overflow_ret2libc")
    analysis.viable_techniques.append("stack_return_overwrite")
