#!/usr/bin/env python3
"""
Error handling for exploit feasibility analysis.

Provides structured error types and collection utilities.
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Dict, List, Optional


class ErrorSeverity(Enum):
    """Severity level for analysis errors."""
    DEBUG = auto()      # Expected failures, tool not installed
    INFO = auto()       # Informational, doesn't affect analysis
    WARNING = auto()    # May affect analysis quality
    ERROR = auto()      # Analysis component failed
    CRITICAL = auto()   # Analysis cannot continue


class ErrorCategory(Enum):
    """Category of analysis error."""
    TOOL_NOT_FOUND = "tool_not_found"
    TOOL_TIMEOUT = "tool_timeout"
    TOOL_FAILED = "tool_failed"
    BINARY_ERROR = "binary_error"
    PERMISSION_ERROR = "permission_error"
    PARSE_ERROR = "parse_error"
    SYSTEM_ERROR = "system_error"
    UNKNOWN = "unknown"


@dataclass
class AnalysisError:
    """
    A structured analysis error with context.

    Example:
        >>> err = AnalysisError(
        ...     component="rop_analysis",
        ...     message="ROPgadget not installed",
        ...     category=ErrorCategory.TOOL_NOT_FOUND,
        ...     severity=ErrorSeverity.WARNING,
        ...     suggestion="Install with: pip install ROPgadget"
        ... )
        >>> err.severity == ErrorSeverity.WARNING
        True
    """
    component: str
    message: str
    category: ErrorCategory = ErrorCategory.UNKNOWN
    severity: ErrorSeverity = ErrorSeverity.WARNING
    exception: Optional[Exception] = None
    suggestion: str = ""

    def __str__(self) -> str:
        result = f"[{self.severity.name}] {self.component}: {self.message}"
        if self.suggestion:
            result += f" (Suggestion: {self.suggestion})"
        return result


@dataclass
class AnalysisErrorCollector:
    """
    Collects and categorizes errors during analysis.

    Example:
        >>> collector = AnalysisErrorCollector()
        >>> collector.add_tool_not_found("rop_analysis", "ROPgadget")
        >>> collector.has_warnings
        True
        >>> len(collector.get_summary()) > 0
        True
    """
    errors: List[AnalysisError] = field(default_factory=list)

    def add(self, error: AnalysisError) -> None:
        """Add an error to the collection."""
        self.errors.append(error)

    def add_tool_not_found(
        self,
        component: str,
        tool_name: str,
        install_cmd: str = ""
    ) -> None:
        """Add a tool not found error."""
        suggestion = f"Install with: {install_cmd}" if install_cmd else f"Install {tool_name}"
        self.add(AnalysisError(
            component=component,
            message=f"{tool_name} not installed",
            category=ErrorCategory.TOOL_NOT_FOUND,
            severity=ErrorSeverity.WARNING,
            suggestion=suggestion
        ))

    def add_tool_timeout(
        self,
        component: str,
        tool_name: str,
        timeout: int
    ) -> None:
        """Add a tool timeout error."""
        self.add(AnalysisError(
            component=component,
            message=f"{tool_name} timed out after {timeout}s",
            category=ErrorCategory.TOOL_TIMEOUT,
            severity=ErrorSeverity.WARNING,
            suggestion="Try with a simpler binary or increase timeout"
        ))

    def add_tool_failed(
        self,
        component: str,
        tool_name: str,
        stderr: str = ""
    ) -> None:
        """Add a tool failure error."""
        msg = f"{tool_name} failed"
        if stderr:
            msg += f": {stderr[:100]}"
        self.add(AnalysisError(
            component=component,
            message=msg,
            category=ErrorCategory.TOOL_FAILED,
            severity=ErrorSeverity.WARNING
        ))

    def add_binary_error(
        self,
        component: str,
        message: str,
        exception: Optional[Exception] = None
    ) -> None:
        """Add a binary-related error."""
        self.add(AnalysisError(
            component=component,
            message=message,
            category=ErrorCategory.BINARY_ERROR,
            severity=ErrorSeverity.ERROR,
            exception=exception
        ))

    def add_permission_error(
        self,
        component: str,
        path: str
    ) -> None:
        """Add a permission error."""
        self.add(AnalysisError(
            component=component,
            message=f"Permission denied: {path}",
            category=ErrorCategory.PERMISSION_ERROR,
            severity=ErrorSeverity.ERROR,
            suggestion="Check file permissions or run with appropriate privileges"
        ))

    def add_parse_error(
        self,
        component: str,
        what: str,
        exception: Optional[Exception] = None
    ) -> None:
        """Add a parse error."""
        self.add(AnalysisError(
            component=component,
            message=f"Failed to parse {what}",
            category=ErrorCategory.PARSE_ERROR,
            severity=ErrorSeverity.WARNING,
            exception=exception
        ))

    @property
    def has_errors(self) -> bool:
        """Check if there are any ERROR or CRITICAL severity errors."""
        return any(
            e.severity in (ErrorSeverity.ERROR, ErrorSeverity.CRITICAL)
            for e in self.errors
        )

    @property
    def has_warnings(self) -> bool:
        """Check if there are any WARNING or higher severity errors."""
        return any(
            e.severity.value >= ErrorSeverity.WARNING.value
            for e in self.errors
        )

    @property
    def has_critical(self) -> bool:
        """Check if there are any CRITICAL severity errors."""
        return any(e.severity == ErrorSeverity.CRITICAL for e in self.errors)

    def get_by_severity(self, severity: ErrorSeverity) -> List[AnalysisError]:
        """Get all errors of a specific severity."""
        return [e for e in self.errors if e.severity == severity]

    def get_by_category(self, category: ErrorCategory) -> List[AnalysisError]:
        """Get all errors of a specific category."""
        return [e for e in self.errors if e.category == category]

    def get_by_component(self, component: str) -> List[AnalysisError]:
        """Get all errors from a specific component."""
        return [e for e in self.errors if e.component == component]

    def get_summary(self) -> Dict[str, int]:
        """Get error count summary by severity."""
        summary = {}
        for severity in ErrorSeverity:
            count = len(self.get_by_severity(severity))
            if count > 0:
                summary[severity.name] = count
        return summary

    def format_report(self, min_severity: ErrorSeverity = ErrorSeverity.WARNING) -> str:
        """
        Format a human-readable error report.

        Args:
            min_severity: Minimum severity to include in report

        Returns:
            Formatted error report string
        """
        filtered = [e for e in self.errors if e.severity.value >= min_severity.value]
        if not filtered:
            return "No errors to report."

        lines = [f"ANALYSIS ERRORS ({len(filtered)} issues):"]

        # Group by severity
        by_severity: Dict[ErrorSeverity, List[AnalysisError]] = {}
        for e in filtered:
            if e.severity not in by_severity:
                by_severity[e.severity] = []
            by_severity[e.severity].append(e)

        for severity in sorted(by_severity.keys(), key=lambda s: s.value, reverse=True):
            errors = by_severity[severity]
            lines.append(f"\n  {severity.name} ({len(errors)}):")
            for e in errors:
                lines.append(f"    - [{e.component}] {e.message}")
                if e.suggestion:
                    lines.append(f"      Suggestion: {e.suggestion}")

        return "\n".join(lines)

    def clear(self) -> None:
        """Clear all collected errors."""
        self.errors.clear()


# Global error collector for module-level use
_global_collector: Optional[AnalysisErrorCollector] = None


def get_error_collector() -> AnalysisErrorCollector:
    """Get or create global error collector."""
    global _global_collector
    if _global_collector is None:
        _global_collector = AnalysisErrorCollector()
    return _global_collector


def reset_error_collector() -> None:
    """Reset global error collector."""
    global _global_collector
    _global_collector = None
