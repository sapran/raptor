#!/usr/bin/env python3
"""
Caching for expensive operations.

Provides LRU caching for:
- ROP gadget analysis
- one_gadget execution
- libc info queries
"""

import hashlib
import subprocess
from dataclasses import dataclass, field
from functools import lru_cache
from typing import List, Tuple

from .constants import CacheSettings, Timeout


@dataclass
class CachedROPGadgets:
    """
    Lightweight ROP gadget cache result.

    This is a minimal data structure for caching ROPgadget output.
    For full-featured ROP info with validation, use context.ROPGadgetInfo.
    """
    total_gadgets: int = 0
    usable_gadgets: int = 0
    gadgets: List[Tuple[int, str]] = field(default_factory=list)

    # Key gadgets for common techniques
    pop_rdi_ret: int = 0
    pop_rsi_ret: int = 0
    pop_rdx_ret: int = 0
    pop_rax_ret: int = 0
    syscall_ret: int = 0
    ret: int = 0

    # Error info
    error: str = ""


@dataclass
class CachedOneGadget:
    """
    Lightweight one-gadget cache entry.

    Minimal structure for caching one_gadget tool output.
    """
    offset: int
    constraints: List[str] = field(default_factory=list)
    description: str = ""
    partial_overwrite_viable: bool = False
    bytes_from_base: int = 0


@dataclass
class CachedOneGadgetResult:
    """
    Collection of cached one-gadget results.

    Lightweight cache structure for one_gadget output.
    """
    gadgets: List[CachedOneGadget] = field(default_factory=list)
    libc_path: str = ""
    error: str = ""


@dataclass
class CachedLibcInfo:
    """
    Lightweight libc symbol cache.

    Minimal structure for caching nm/strings output.
    For full-featured libc info with validation, use context.LibcInfo.
    """
    path: str = ""
    system_offset: int = 0
    binsh_offset: int = 0
    malloc_hook_offset: int = 0
    free_hook_offset: int = 0
    exit_funcs_offset: int = 0
    io_list_all_offset: int = 0
    error: str = ""


def _get_file_hash(path: str) -> str:
    """Get hash of file for cache key."""
    try:
        with open(path, 'rb') as f:
            # Read first and last 1MB for speed
            content = f.read(1024 * 1024)
            f.seek(-min(1024 * 1024, f.tell()), 2)
            content += f.read()
        return hashlib.md5(content).hexdigest()[:16]
    except Exception:
        return path


@lru_cache(maxsize=CacheSettings.ROP_CACHE_SIZE)
def cached_rop_analysis(binary_path: str, file_hash: str) -> CachedROPGadgets:
    """
    Cached ROP gadget analysis.

    Args:
        binary_path: Path to binary
        file_hash: Hash of binary for cache invalidation

    Returns:
        CachedROPGadgets with gadget analysis

    Example:
        >>> # Note: Requires actual binary
        >>> # info = cached_rop_analysis("/bin/ls", "abc123")
        >>> # info.total_gadgets > 0
    """
    info = CachedROPGadgets()

    try:
        result = subprocess.run(
            ['ROPgadget', '--binary', binary_path],
            capture_output=True,
            text=True,
            timeout=Timeout.VERY_SLOW
        )

        if result.returncode != 0:
            info.error = f"ROPgadget failed: {result.stderr}"
            return info

        for line in result.stdout.split('\n'):
            if ' : ' in line:
                parts = line.split(' : ', 1)
                if len(parts) == 2:
                    try:
                        addr = int(parts[0].strip(), 16)
                        gadget = parts[1].strip()
                        info.gadgets.append((addr, gadget))
                        info.total_gadgets += 1

                        # Check for key gadgets
                        gadget_lower = gadget.lower()
                        if 'pop rdi' in gadget_lower and 'ret' in gadget_lower:
                            if not info.pop_rdi_ret:
                                info.pop_rdi_ret = addr
                        elif 'pop rsi' in gadget_lower and 'ret' in gadget_lower:
                            if not info.pop_rsi_ret:
                                info.pop_rsi_ret = addr
                        elif 'pop rdx' in gadget_lower and 'ret' in gadget_lower:
                            if not info.pop_rdx_ret:
                                info.pop_rdx_ret = addr
                        elif 'pop rax' in gadget_lower and 'ret' in gadget_lower:
                            if not info.pop_rax_ret:
                                info.pop_rax_ret = addr
                        elif gadget_lower == 'syscall ; ret' or gadget_lower == 'syscall; ret':
                            if not info.syscall_ret:
                                info.syscall_ret = addr
                        elif gadget_lower == 'ret':
                            if not info.ret:
                                info.ret = addr
                    except ValueError:
                        continue

        info.usable_gadgets = info.total_gadgets

    except subprocess.TimeoutExpired:
        info.error = "ROPgadget timed out"
    except FileNotFoundError:
        info.error = "ROPgadget not installed"
    except Exception as e:
        info.error = str(e)

    return info


@lru_cache(maxsize=CacheSettings.ONE_GADGET_CACHE_SIZE)
def cached_one_gadget(libc_path: str, file_hash: str) -> CachedOneGadgetResult:
    """
    Cached one_gadget analysis.

    Args:
        libc_path: Path to libc
        file_hash: Hash of libc for cache invalidation

    Returns:
        CachedOneGadgetResult with gadget list

    Example:
        >>> # Note: Requires actual libc and one_gadget installed
        >>> # info = cached_one_gadget("/lib/x86_64-linux-gnu/libc.so.6", "abc123")
        >>> # len(info.gadgets) >= 0
    """
    info = CachedOneGadgetResult(libc_path=libc_path)

    try:
        result = subprocess.run(
            ['one_gadget', libc_path],
            capture_output=True,
            text=True,
            timeout=Timeout.SLOW
        )

        if result.returncode != 0 and not result.stdout:
            info.error = f"one_gadget failed: {result.stderr}"
            return info

        # Parse output
        current_offset = None
        current_constraints = []

        for line in result.stdout.split('\n'):
            line = line.strip()
            if not line:
                continue

            # Offset line: 0x50a37 posix_spawn(rsp+0x1c, "/bin/sh", 0, rbp, rsp+0x60, environ)
            if line.startswith('0x'):
                # Save previous gadget
                if current_offset is not None:
                    gadget = CachedOneGadget(
                        offset=current_offset,
                        constraints=current_constraints.copy(),
                    )
                    # Calculate bytes from base
                    gadget.bytes_from_base = (current_offset.bit_length() + 7) // 8
                    info.gadgets.append(gadget)

                # Parse new gadget
                parts = line.split(' ', 1)
                try:
                    current_offset = int(parts[0], 16)
                    current_constraints = []
                except ValueError:
                    current_offset = None

            # Constraint line: constraints:
            elif line.startswith('constraints:'):
                continue

            # Constraint: [rsp+0x30] == NULL
            elif current_offset is not None:
                current_constraints.append(line)

        # Don't forget the last gadget
        if current_offset is not None:
            gadget = CachedOneGadget(
                offset=current_offset,
                constraints=current_constraints.copy(),
            )
            gadget.bytes_from_base = (current_offset.bit_length() + 7) // 8
            info.gadgets.append(gadget)

    except subprocess.TimeoutExpired:
        info.error = "one_gadget timed out"
    except FileNotFoundError:
        info.error = "one_gadget not installed"
    except Exception as e:
        info.error = str(e)

    return info


@lru_cache(maxsize=CacheSettings.LIBC_INFO_CACHE_SIZE)
def cached_libc_info(libc_path: str, file_hash: str) -> CachedLibcInfo:
    """
    Cached libc symbol lookup.

    Args:
        libc_path: Path to libc
        file_hash: Hash of libc for cache invalidation

    Returns:
        CachedLibcInfo with symbol offsets

    Example:
        >>> # Note: Requires actual libc
        >>> # info = cached_libc_info("/lib/x86_64-linux-gnu/libc.so.6", "abc123")
        >>> # info.system_offset > 0
    """
    info = CachedLibcInfo(path=libc_path)

    try:
        result = subprocess.run(
            ['nm', '-D', libc_path],
            capture_output=True,
            text=True,
            timeout=Timeout.NORMAL
        )

        if result.returncode != 0:
            info.error = f"nm failed: {result.stderr}"
            return info

        for line in result.stdout.split('\n'):
            parts = line.split()
            if len(parts) >= 3:
                try:
                    addr = int(parts[0], 16)
                    symbol = parts[2]

                    if symbol == 'system':
                        info.system_offset = addr
                    elif symbol == '__malloc_hook':
                        info.malloc_hook_offset = addr
                    elif symbol == '__free_hook':
                        info.free_hook_offset = addr
                    elif symbol == '__exit_funcs':
                        info.exit_funcs_offset = addr
                    elif symbol == '_IO_list_all':
                        info.io_list_all_offset = addr
                except ValueError:
                    continue

        # Find /bin/sh string
        try:
            strings_result = subprocess.run(
                ['strings', '-a', '-t', 'x', libc_path],
                capture_output=True,
                text=True,
                timeout=Timeout.MEDIUM
            )
            for line in strings_result.stdout.split('\n'):
                if '/bin/sh' in line:
                    parts = line.strip().split()
                    if parts:
                        try:
                            info.binsh_offset = int(parts[0], 16)
                            break
                        except ValueError:
                            continue
        except Exception:
            pass

    except subprocess.TimeoutExpired:
        info.error = "nm timed out"
    except Exception as e:
        info.error = str(e)

    return info


def get_rop_analysis(binary_path: str) -> CachedROPGadgets:
    """
    Get ROP analysis with caching.

    Example:
        >>> # info = get_rop_analysis("/bin/ls")
        >>> # info.total_gadgets >= 0
    """
    file_hash = _get_file_hash(binary_path)
    return cached_rop_analysis(binary_path, file_hash)


def get_one_gadgets(libc_path: str) -> CachedOneGadgetResult:
    """
    Get one_gadget analysis with caching.

    Example:
        >>> # info = get_one_gadgets("/lib/x86_64-linux-gnu/libc.so.6")
        >>> # len(info.gadgets) >= 0
    """
    file_hash = _get_file_hash(libc_path)
    return cached_one_gadget(libc_path, file_hash)


def get_libc_info(libc_path: str) -> CachedLibcInfo:
    """
    Get libc info with caching.

    Example:
        >>> # info = get_libc_info("/lib/x86_64-linux-gnu/libc.so.6")
        >>> # info.system_offset >= 0
    """
    file_hash = _get_file_hash(libc_path)
    return cached_libc_info(libc_path, file_hash)


def clear_caches():
    """Clear all analysis caches."""
    cached_rop_analysis.cache_clear()
    cached_one_gadget.cache_clear()
    cached_libc_info.cache_clear()
