#!/usr/bin/env python3
"""
Target profiling for exploitation analysis.

Tracks information about the target system/binary for exploit planning.
"""

import platform
import re
import subprocess
from dataclasses import dataclass
from enum import Enum
from typing import Optional


class TargetContext(Enum):
    """
    Where the vulnerable target runs - determines which mitigations apply.

    LOCAL_BINARY:
        Target binary runs on THIS system (same machine as analysis).
        All local mitigations apply: glibc version, kernel ASLR, binary protections.
        Use case: Local privilege escalation, CTF pwn challenges, authorized pentests.

    REMOTE_BINARY:
        Target binary runs on a DIFFERENT system (remote server).
        Local mitigations DON'T apply - need to determine remote environment.
        Analysis must be done with remote system info (leaked, guessed, or unknown).
        Use case: Network services, remote exploitation.

    WEB_APPLICATION:
        Target is a web application (SQLi, XSS, SSRF, etc.).
        Memory corruption mitigations are IRRELEVANT.
        Different defenses apply: WAF, CSP, CORS, input validation, etc.
        Use case: Web pentesting, bug bounties.

    KERNEL:
        Target is the kernel itself (privilege escalation from userland).
        Additional mitigations apply: SMEP, SMAP, KASLR, kptr_restrict.
        Use case: Kernel exploitation, LPE.

    UNKNOWN:
        Context not yet determined - agent should clarify before analysis.
    """
    LOCAL_BINARY = "local_binary"
    REMOTE_BINARY = "remote_binary"
    WEB_APPLICATION = "web_application"
    KERNEL = "kernel"
    UNKNOWN = "unknown"


@dataclass
class TargetProfile:
    """
    Profile of the target system for exploitation planning.

    For LOCAL_BINARY: populated from this system's actual values.
    For REMOTE_BINARY: populated from leaks, guesses, or challenge description.
    For WEB_APPLICATION: mostly irrelevant (different defense model).
    """
    context: TargetContext = TargetContext.UNKNOWN

    # Binary info
    binary_path: Optional[str] = None
    binary_arch: str = "x86_64"  # x86_64, i386, arm, aarch64

    # System info (for remote, these may be unknown/guessed)
    os: str = "linux"
    glibc_version: Optional[str] = None  # e.g., "2.31", "2.35"
    kernel_version: Optional[str] = None  # e.g., "5.15.0"

    # Known protections (may be partial for remote)
    has_aslr: Optional[bool] = None
    has_pie: Optional[bool] = None
    has_nx: Optional[bool] = None
    has_canary: Optional[bool] = None
    has_full_relro: Optional[bool] = None

    # Connection info (for remote)
    host: Optional[str] = None
    port: Optional[int] = None

    # Confidence in the profile (for remote targets)
    confidence: str = "high"  # high (local/verified), medium (leaked), low (guessed)
    confidence_notes: str = ""

    def __post_init__(self):
        """Validate profile properties."""
        if not isinstance(self.context, TargetContext):
            raise ValueError(f"TargetProfile.context must be TargetContext, got {type(self.context)}")
        known_archs = ['x86_64', 'i386', 'aarch64', 'arm64', 'arm', 'arm32', 'armv7', 'mips', 'mips32', 'mips64']
        if self.binary_arch not in known_archs:
            raise ValueError(f"TargetProfile.binary_arch must be one of {known_archs}, got {self.binary_arch!r}")
        if self.confidence not in ('high', 'medium', 'low'):
            raise ValueError(f"TargetProfile.confidence must be 'high', 'medium', or 'low', got {self.confidence!r}")

    def __repr__(self) -> str:
        glibc = self.glibc_version or "unknown"
        return f"TargetProfile({self.context.value}, arch={self.binary_arch!r}, glibc={glibc})"

    def is_local(self) -> bool:
        """True if target is local (this system)."""
        return self.context == TargetContext.LOCAL_BINARY

    def is_remote(self) -> bool:
        """True if target is a remote binary."""
        return self.context == TargetContext.REMOTE_BINARY

    def is_web(self) -> bool:
        """True if target is a web application."""
        return self.context == TargetContext.WEB_APPLICATION

    def is_kernel(self) -> bool:
        """True if target is kernel exploitation."""
        return self.context == TargetContext.KERNEL

    def mitigation_analysis_relevant(self) -> bool:
        """
        Check if memory corruption mitigation analysis is relevant.

        Returns False for web applications where different defenses apply.
        """
        return self.context in (
            TargetContext.LOCAL_BINARY,
            TargetContext.REMOTE_BINARY,
            TargetContext.KERNEL,
        )

    def needs_remote_enumeration(self) -> bool:
        """
        Check if we need to enumerate remote system properties.

        For remote targets with unknown glibc/kernel, we may need to:
        - Leak libc version from format string or GOT
        - Guess based on OS/distro
        - Use challenge description hints
        """
        if not self.is_remote():
            return False
        return self.glibc_version is None or self.kernel_version is None

    def summary(self) -> str:
        """Human-readable profile summary."""
        lines = [f"TARGET PROFILE: {self.context.value}"]

        if self.binary_path:
            lines.append(f"  Binary: {self.binary_path}")
        lines.append(f"  Arch: {self.binary_arch}")

        if self.is_remote():
            if self.host and self.port:
                lines.append(f"  Remote: {self.host}:{self.port}")
            lines.append(f"  Confidence: {self.confidence}")

        if self.glibc_version:
            lines.append(f"  glibc: {self.glibc_version}")
        elif self.is_remote():
            lines.append("  glibc: UNKNOWN (need to enumerate)")

        if self.is_web():
            lines.append("  [!] Web application - memory mitigations NOT relevant")
            lines.append("      Check: WAF, CSP, input validation, etc.")

        prots = []
        if self.has_aslr is not None:
            prots.append(f"ASLR={'on' if self.has_aslr else 'off'}")
        if self.has_pie is not None:
            prots.append(f"PIE={'on' if self.has_pie else 'off'}")
        if self.has_nx is not None:
            prots.append(f"NX={'on' if self.has_nx else 'off'}")
        if self.has_canary is not None:
            prots.append(f"Canary={'on' if self.has_canary else 'off'}")
        if self.has_full_relro is not None:
            prots.append(f"RELRO={'full' if self.has_full_relro else 'partial/none'}")
        if prots:
            lines.append(f"  Protections: {', '.join(prots)}")

        return "\n".join(lines)


def create_local_profile(binary_path: str = None) -> TargetProfile:
    """
    Create a target profile for local exploitation.

    Automatically populates with this system's actual values.
    """
    profile = TargetProfile(
        context=TargetContext.LOCAL_BINARY,
        binary_path=binary_path,
        binary_arch=platform.machine(),
        os="linux",
        confidence="high",
        confidence_notes="Local system - values verified",
    )

    # Get glibc version
    try:
        result = subprocess.run(['ldd', '--version'], capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            match = re.search(r'(\d+\.\d+)', result.stdout)
            if match:
                profile.glibc_version = match.group(1)
    except (subprocess.SubprocessError, OSError):
        pass

    # Get kernel version
    profile.kernel_version = platform.release()

    return profile


def create_remote_profile(
    host: str = None,
    port: int = None,
    binary_path: str = None,
    glibc_version: str = None,
    arch: str = "x86_64",
) -> TargetProfile:
    """
    Create a target profile for remote exploitation.

    Unknown values should be enumerated or guessed later.
    """
    confidence = "high" if glibc_version else "low"

    return TargetProfile(
        context=TargetContext.REMOTE_BINARY,
        binary_path=binary_path,
        binary_arch=arch,
        host=host,
        port=port,
        glibc_version=glibc_version,
        confidence=confidence,
        confidence_notes="Remote target" + (" - glibc version known" if glibc_version else " - need to enumerate"),
    )


def create_web_profile(url: str = None) -> TargetProfile:
    """
    Create a target profile for web application testing.

    Memory corruption mitigations are not relevant here.
    """
    return TargetProfile(
        context=TargetContext.WEB_APPLICATION,
        confidence="high",
        confidence_notes="Web application - memory mitigations not applicable",
    )


def create_kernel_profile(kernel_version: str = None) -> TargetProfile:
    """
    Create a target profile for kernel exploitation.

    Additional kernel mitigations apply (SMEP, SMAP, KASLR, etc.).
    """
    profile = TargetProfile(
        context=TargetContext.KERNEL,
        binary_arch=platform.machine(),
        os="linux",
        confidence="high",
        confidence_notes="Kernel exploitation target",
    )

    if kernel_version:
        profile.kernel_version = kernel_version
    else:
        profile.kernel_version = platform.release()

    return profile
