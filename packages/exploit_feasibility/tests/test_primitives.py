#!/usr/bin/env python3
"""Tests for primitives module."""

import pytest
from ..primitives import (
    Primitive,
    PrimitiveID,
    PrimitiveType,
    MitigationID,
    ConfidenceScore,
    ExploitPath,
    get_primitive_definitions,
)


class TestPrimitiveID:
    """Tests for PrimitiveID enum."""

    def test_primitive_id_values(self):
        """Verify PrimitiveID values match expected strings."""
        assert PrimitiveID.FORMAT_STRING_VULN.value == "format_string_vuln"
        assert PrimitiveID.LIBC_LEAK.value == "libc_leak"
        assert PrimitiveID.CODE_EXECUTION.value == "code_execution"

    def test_all_primitives_have_definitions(self):
        """Every PrimitiveID should have a corresponding definition."""
        primitives = get_primitive_definitions()
        for pid in PrimitiveID:
            assert pid.value in primitives, f"Missing definition for {pid.value}"


class TestMitigationID:
    """Tests for MitigationID enum."""

    def test_mitigation_id_values(self):
        """Verify MitigationID values match expected strings."""
        assert MitigationID.FULL_RELRO.value == "full_relro"
        assert MitigationID.GLIBC_N_DISABLED.value == "glibc_n_disabled"
        assert MitigationID.STACK_CANARY.value == "stack_canary"


class TestPrimitive:
    """Tests for Primitive dataclass."""

    def test_is_achievable_with_requirements(self):
        """Test is_achievable with required primitives."""
        p = Primitive(
            name="test",
            description="Test primitive",
            requires=["a", "b"],
        )
        assert p.is_achievable({"a", "b", "c"}, set())
        assert not p.is_achievable({"a"}, set())
        assert not p.is_achievable(set(), set())

    def test_is_achievable_with_requires_any(self):
        """Test is_achievable with alternative requirements."""
        p = Primitive(
            name="test",
            description="Test primitive",
            requires_any=["x", "y", "z"],
        )
        assert p.is_achievable({"x"}, set())
        assert p.is_achievable({"y"}, set())
        assert p.is_achievable({"z"}, set())
        assert not p.is_achievable({"a", "b"}, set())

    def test_is_achievable_with_blockers(self):
        """Test is_achievable with blocking mitigations."""
        p = Primitive(
            name="test",
            description="Test primitive",
            blocked_by=["full_relro"],
        )
        assert p.is_achievable(set(), set())
        assert not p.is_achievable(set(), {"full_relro"})
        assert not p.is_achievable({"a", "b"}, {"full_relro"})

    def test_is_achievable_combined(self):
        """Test is_achievable with all conditions."""
        p = Primitive(
            name="test",
            description="Test primitive",
            requires=["a"],
            requires_any=["x", "y"],
            blocked_by=["blocker"],
        )
        # All conditions met
        assert p.is_achievable({"a", "x"}, set())
        # Missing required
        assert not p.is_achievable({"x"}, set())
        # Missing requires_any
        assert not p.is_achievable({"a", "b"}, set())
        # Blocked
        assert not p.is_achievable({"a", "x"}, {"blocker"})

    def test_get_missing_requirements(self):
        """Test get_missing_requirements method."""
        p = Primitive(
            name="test",
            description="Test primitive",
            requires=["a", "b", "c"],
            requires_any=["x", "y"],
        )
        missing = p.get_missing_requirements({"a"})
        assert "b" in missing
        assert "c" in missing
        assert "a" not in missing
        assert any("one_of" in m for m in missing)

    def test_primitive_type_default(self):
        """Test default primitive type."""
        p = Primitive(name="test", description="Test")
        assert p.primitive_type == PrimitiveType.CAPABILITY


class TestConfidenceScore:
    """Tests for ConfidenceScore dataclass."""

    def test_from_reliability_high(self):
        """Test high reliability score."""
        score = ConfidenceScore.from_reliability(95)
        assert score.level == "high"
        assert score.score >= 85

    def test_from_reliability_medium(self):
        """Test medium reliability score."""
        score = ConfidenceScore.from_reliability(75)
        assert score.level == "medium"

    def test_from_reliability_low(self):
        """Test low reliability score."""
        score = ConfidenceScore.from_reliability(50)
        assert score.level == "low"

    def test_from_reliability_very_low(self):
        """Test very low reliability score."""
        score = ConfidenceScore.from_reliability(20)
        assert score.level == "very_low"

    def test_complications_reduce_score(self):
        """Test that complications reduce the score."""
        base_score = ConfidenceScore.from_reliability(90)
        complicated_score = ConfidenceScore.from_reliability(90, ["stack_canary", "aslr"])
        assert complicated_score.score < base_score.score

    def test_score_clamped_to_valid_range(self):
        """Test that score is clamped between 0 and 100."""
        # Many complications should not go below 0
        score = ConfidenceScore.from_reliability(
            30,
            ["stack_canary", "aslr", "pie", "safe_linking", "pointer_mangling"]
        )
        assert score.score >= 0
        assert score.score <= 100

    def test_summary_format(self):
        """Test summary output format."""
        score = ConfidenceScore.from_reliability(85, ["stack_canary"])
        summary = score.summary()
        assert "CONFIDENCE:" in summary
        assert "%" in summary


class TestExploitPath:
    """Tests for ExploitPath dataclass."""

    def test_basic_path(self):
        """Test basic exploit path creation."""
        path = ExploitPath(
            goal="code_execution",
            steps=["format_string_vuln", "libc_leak", "ret2libc"],
            total_reliability=80.0,
        )
        assert path.goal == "code_execution"
        assert len(path.steps) == 3

    def test_compute_confidence(self):
        """Test confidence computation."""
        path = ExploitPath(
            goal="code_execution",
            steps=["a", "b"],
            total_reliability=90.0,
            complicating_mitigations=["stack_canary"],
        )
        confidence = path.compute_confidence()
        assert confidence is not None
        assert path.confidence is not None
        assert path.confidence.score < 90  # Reduced by complication

    def test_summary_format(self):
        """Test summary output format."""
        path = ExploitPath(
            goal="code_execution",
            steps=["format_string_vuln", "ret2libc"],
            total_reliability=85.0,
        )
        summary = path.summary()
        assert "PATH TO code_execution" in summary
        assert "format_string_vuln" in summary
        assert "85" in summary


class TestGetPrimitiveDefinitions:
    """Tests for get_primitive_definitions function."""

    def test_returns_dict(self):
        """Test that function returns a dictionary."""
        primitives = get_primitive_definitions()
        assert isinstance(primitives, dict)

    def test_contains_vulnerabilities(self):
        """Test that vulnerabilities are defined."""
        primitives = get_primitive_definitions()
        assert "format_string_vuln" in primitives
        assert "stack_overflow_vuln" in primitives
        assert "heap_overflow_vuln" in primitives

    def test_contains_capabilities(self):
        """Test that capabilities are defined."""
        primitives = get_primitive_definitions()
        assert "libc_leak" in primitives
        assert "arbitrary_write" in primitives
        assert "format_string_write" in primitives

    def test_contains_goals(self):
        """Test that goals are defined."""
        primitives = get_primitive_definitions()
        assert "code_execution" in primitives
        assert "info_disclosure" in primitives

    def test_vulnerability_types_correct(self):
        """Test that vulnerability primitives have correct type."""
        primitives = get_primitive_definitions()
        vuln_names = ["format_string_vuln", "stack_overflow_vuln", "heap_overflow_vuln"]
        for name in vuln_names:
            assert primitives[name].primitive_type == PrimitiveType.VULNERABILITY

    def test_goal_types_correct(self):
        """Test that goal primitives have correct type."""
        primitives = get_primitive_definitions()
        goal_names = ["code_execution", "info_disclosure", "denial_of_service"]
        for name in goal_names:
            assert primitives[name].primitive_type == PrimitiveType.GOAL

    def test_returns_copy(self):
        """Test that function returns a fresh copy each time."""
        p1 = get_primitive_definitions()
        p2 = get_primitive_definitions()
        # Should be equal but not the same object
        assert p1.keys() == p2.keys()
        # Modifying one shouldn't affect the other
        p1["test_key"] = "test_value"
        assert "test_key" not in p2
