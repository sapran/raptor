#!/usr/bin/env python3
"""Tests for the constraints analysis module."""

import pytest
from ..constraints import (
    analyze_input_constraints,
    analyze_bad_byte_impact,
    assess_libc_fingerprinting,
    InputConstraintAnalysis,
    BadByteImpact,
    LibcFingerprintingPotential,
)


class TestInputConstraintAnalysis:
    """Tests for analyze_input_constraints function."""

    def test_strcpy_x86_64_blocks_rop(self):
        """Test that strcpy on x86_64 blocks multi-gadget ROP."""
        analysis = analyze_input_constraints("strcpy", "x86_64")

        assert analysis.handler == "strcpy"
        assert analysis.arch == "x86_64"
        assert analysis.null_byte_position == 6
        assert analysis.max_contiguous_bytes == 6

        # Check ROP is blocked
        blocked_lower = [b.lower() for b in analysis.blocked]
        assert any("rop" in b for b in blocked_lower)

    def test_strcpy_x86_64_partial_overwrite_viable(self):
        """Test that partial overwrite remains viable with strcpy."""
        analysis = analyze_input_constraints("strcpy", "x86_64")

        viable_lower = [v.lower() for v in analysis.viable]
        assert any("partial" in v for v in viable_lower)

    def test_strcpy_i386_rop_may_work(self):
        """Test that i386 with strcpy may still allow ROP."""
        analysis = analyze_input_constraints("strcpy", "i386")

        assert analysis.arch == "i386"
        assert analysis.null_byte_position == 4
        # 32-bit is more forgiving
        viable_lower = [v.lower() for v in analysis.viable]
        assert any("rop" in v for v in viable_lower)

    def test_read_no_bad_bytes(self):
        """Test that read() has no bad byte constraints."""
        analysis = analyze_input_constraints("read", "x86_64")

        assert analysis.handler == "read"
        assert 0x00 not in analysis.additional_bad_bytes

        viable_lower = [v.lower() for v in analysis.viable]
        assert any("all rop" in v or "no byte restrictions" in v for v in viable_lower)

    def test_fgets_newline_constraint(self):
        """Test that fgets adds newline to bad bytes."""
        analysis = analyze_input_constraints("fgets", "x86_64")

        assert 0x0a in analysis.additional_bad_bytes

    def test_scanf_whitespace_constraints(self):
        """Test that scanf adds whitespace to bad bytes."""
        analysis = analyze_input_constraints("scanf", "x86_64")

        # Should include whitespace characters
        assert 0x20 in analysis.additional_bad_bytes  # space
        assert 0x09 in analysis.additional_bad_bytes  # tab

    def test_full_relro_adds_got_blocked(self):
        """Test that Full RELRO adds GOT overwrite to blocked list."""
        analysis = analyze_input_constraints(
            "strcpy", "x86_64", has_full_relro=True
        )

        blocked_lower = [b.lower() for b in analysis.blocked]
        assert any("got" in b and "relro" in b for b in blocked_lower)

    def test_format_n_adds_viable(self):
        """Test that working %n adds format string to viable list."""
        analysis = analyze_input_constraints(
            "strcpy", "x86_64", format_n_works=True
        )

        viable_lower = [v.lower() for v in analysis.viable]
        assert any("format" in v for v in viable_lower)

    def test_summary_output(self):
        """Test that summary() produces readable output."""
        analysis = analyze_input_constraints("strcpy", "x86_64")
        summary = analysis.summary()

        assert "strcpy" in summary
        assert "Blocked" in summary
        assert "viable" in summary.lower()

    def test_to_dict_complete(self):
        """Test that to_dict() includes all fields."""
        analysis = analyze_input_constraints("strcpy", "x86_64")
        d = analysis.to_dict()

        assert 'handler' in d
        assert 'arch' in d
        assert 'null_byte_position' in d
        assert 'blocked' in d
        assert 'viable' in d
        assert 'conditional' in d
        assert 'notes' in d

    def test_aarch64_constraints(self):
        """Test ARM64 has similar constraints to x86_64."""
        analysis = analyze_input_constraints("strcpy", "aarch64")

        assert analysis.arch == "aarch64"
        assert analysis.null_byte_position == 6
        # Should have some blocked techniques (may differ from x86_64)
        assert len(analysis.blocked) > 0 or len(analysis.viable) > 0


class TestBadByteImpact:
    """Tests for analyze_bad_byte_impact function."""

    def test_no_bad_bytes(self):
        """Test address with no bad bytes is fully usable."""
        # Use a full 8-byte address without any null bytes
        # 0x1234567812345678 has no nulls
        impact = analyze_bad_byte_impact(
            "GOT[puts]", 0x1234567812345678, [0x00], "full_write", 8
        )

        assert not impact.bad_bytes_found
        assert not impact.fatal
        assert "no restrictions" in impact.workaround.lower()

    def test_null_at_position_6(self):
        """Test typical x86_64 address with null at byte 6."""
        # 0x00007fff12345678 - null at bytes 6 and 7
        address = 0x00007fff12345678
        impact = analyze_bad_byte_impact(
            ".fini_array", address, [0x00], "full_write", 8
        )

        assert len(impact.bad_bytes_found) > 0
        assert not impact.fatal
        assert impact.usable_via_partial
        assert impact.partial_bytes_needed == 6

    def test_null_in_low_bytes_fatal(self):
        """Test that null in low bytes is fatal."""
        # Address with null at byte 0
        address = 0x12345600
        impact = analyze_bad_byte_impact(
            "target", address, [0x00], "full_write", 8
        )

        assert impact.fatal
        assert "block" in impact.reason.lower()

    def test_partial_overwrite_technique(self):
        """Test partial overwrite technique with null at high bytes."""
        address = 0x00007fff12345678
        impact = analyze_bad_byte_impact(
            "target", address, [0x00], "partial_overwrite", 8
        )

        assert impact.usable_via_partial
        assert impact.partial_bytes_needed >= 2

    def test_format_string_technique(self):
        """Test format string can write byte-by-byte."""
        address = 0x00007fff12345678
        impact = analyze_bad_byte_impact(
            "target", address, [0x00], "format_string", 8
        )

        # Format string can work around high byte nulls
        assert impact.usable_via_partial
        assert "%hn" in impact.workaround or "2 bytes" in impact.workaround

    def test_multiple_bad_bytes(self):
        """Test address with multiple bad bytes."""
        # Address with 0x00 and 0x0a
        address = 0x0a007f12345678
        impact = analyze_bad_byte_impact(
            "target", address, [0x00, 0x0a], "full_write", 8
        )

        # Should find both bad bytes
        found_bytes = [val for _, val in impact.bad_bytes_found]
        assert 0x00 in found_bytes or 0x0a in found_bytes

    def test_summary_output(self):
        """Test that summary() produces readable output."""
        address = 0x00007fff12345678
        impact = analyze_bad_byte_impact(
            ".fini_array", address, [0x00], "full_write", 8
        )
        summary = impact.summary()

        assert ".fini_array" in summary
        assert "0x" in summary

    def test_to_dict_complete(self):
        """Test that to_dict() includes all fields."""
        address = 0x00007fff12345678
        impact = analyze_bad_byte_impact(
            "target", address, [0x00], "full_write", 8
        )
        d = impact.to_dict()

        assert 'target_name' in d
        assert 'address' in d
        assert 'address_hex' in d
        assert 'bad_bytes_found' in d
        assert 'fatal' in d
        assert 'usable_via_partial' in d

    def test_32bit_pointer_size(self):
        """Test 32-bit pointer handling."""
        address = 0x08041234
        impact = analyze_bad_byte_impact(
            "target", address, [0x00], "full_write", pointer_size=4
        )

        # Should analyze only 4 bytes
        assert not impact.bad_bytes_found  # This address has no nulls


class TestLibcFingerprinting:
    """Tests for assess_libc_fingerprinting function."""

    def test_good_fingerprinting_many_symbols(self):
        """Test good fingerprinting with many symbols."""
        symbols = ['puts', 'printf', 'read', 'write', 'malloc', 'free', 'exit']
        potential = assess_libc_fingerprinting(symbols)

        assert potential.symbol_count >= 5
        assert potential.feasibility == "good"
        assert potential.confidence == "high"

    def test_limited_fingerprinting_few_symbols(self):
        """Test limited fingerprinting with few symbols."""
        symbols = ['puts', 'printf', 'exit']
        potential = assess_libc_fingerprinting(symbols)

        assert potential.symbol_count == 3
        assert potential.feasibility == "limited"
        assert potential.confidence == "medium"

    def test_poor_fingerprinting_minimal_symbols(self):
        """Test poor fingerprinting with minimal symbols."""
        symbols = ['puts']
        potential = assess_libc_fingerprinting(symbols)

        assert potential.symbol_count == 1
        assert potential.feasibility == "poor"
        assert potential.confidence == "low"

    def test_no_fingerprinting_no_symbols(self):
        """Test no fingerprinting possible without symbols."""
        symbols = []
        potential = assess_libc_fingerprinting(symbols)

        assert potential.symbol_count == 0
        assert potential.feasibility == "none"

    def test_filters_non_fingerprint_symbols(self):
        """Test that non-libc symbols are filtered out."""
        symbols = ['puts', 'custom_func', 'my_helper', 'printf']
        potential = assess_libc_fingerprinting(symbols)

        # Only puts and printf should count
        assert potential.symbol_count == 2
        assert 'puts' in potential.unique_symbols
        assert 'printf' in potential.unique_symbols
        assert 'custom_func' not in potential.unique_symbols

    def test_combined_plt_and_got(self):
        """Test combining PLT and GOT symbols."""
        plt = ['puts', 'printf']
        got = ['malloc', 'free', 'read']
        potential = assess_libc_fingerprinting(plt, got)

        # Should count all unique symbols
        assert potential.symbol_count == 5

    def test_deduplicates_symbols(self):
        """Test that duplicate symbols are deduplicated."""
        plt = ['puts', 'printf']
        got = ['puts', 'malloc']  # puts appears in both
        potential = assess_libc_fingerprinting(plt, got)

        # puts should only be counted once
        assert potential.unique_symbols.count('puts') == 1

    def test_notes_for_leak_candidates(self):
        """Test that puts/printf get noted as leak candidates."""
        symbols = ['puts', 'printf', 'malloc']
        potential = assess_libc_fingerprinting(symbols)

        notes_str = ' '.join(potential.notes).lower()
        assert 'puts' in notes_str or 'printf' in notes_str
        assert 'leak' in notes_str

    def test_notes_for_system_in_plt(self):
        """Test that system in PLT gets special note."""
        symbols = ['puts', 'system']
        potential = assess_libc_fingerprinting(symbols)

        notes_str = ' '.join(potential.notes).lower()
        assert 'system' in notes_str

    def test_summary_output(self):
        """Test that summary() produces readable output."""
        symbols = ['puts', 'printf', 'malloc']
        potential = assess_libc_fingerprinting(symbols)
        summary = potential.summary()

        assert "fingerprinting" in summary.lower()
        assert str(potential.symbol_count) in summary

    def test_to_dict_complete(self):
        """Test that to_dict() includes all fields."""
        symbols = ['puts', 'printf']
        potential = assess_libc_fingerprinting(symbols)
        d = potential.to_dict()

        assert 'unique_symbols' in d
        assert 'symbol_count' in d
        assert 'feasibility' in d
        assert 'confidence' in d
        assert 'notes' in d


class TestDataclassIntegrity:
    """Tests for dataclass structure and serialization."""

    def test_input_constraint_analysis_fields(self):
        """Test InputConstraintAnalysis has all expected fields."""
        analysis = InputConstraintAnalysis(handler="test", arch="x86_64")

        assert hasattr(analysis, 'handler')
        assert hasattr(analysis, 'arch')
        assert hasattr(analysis, 'null_byte_position')
        assert hasattr(analysis, 'blocked')
        assert hasattr(analysis, 'viable')
        assert hasattr(analysis, 'conditional')
        assert hasattr(analysis, 'notes')

    def test_bad_byte_impact_fields(self):
        """Test BadByteImpact has all expected fields."""
        impact = BadByteImpact(
            target_name="test",
            address=0x12345678,
            bad_bytes_found=[],
        )

        assert hasattr(impact, 'target_name')
        assert hasattr(impact, 'address')
        assert hasattr(impact, 'bad_bytes_found')
        assert hasattr(impact, 'fatal')
        assert hasattr(impact, 'usable_via_partial')
        assert hasattr(impact, 'reason')
        assert hasattr(impact, 'workaround')

    def test_libc_fingerprinting_potential_fields(self):
        """Test LibcFingerprintingPotential has all expected fields."""
        potential = LibcFingerprintingPotential()

        assert hasattr(potential, 'unique_symbols')
        assert hasattr(potential, 'symbol_count')
        assert hasattr(potential, 'feasibility')
        assert hasattr(potential, 'confidence')
        assert hasattr(potential, 'notes')
