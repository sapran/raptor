#!/usr/bin/env python3
"""Integration tests for analyze_binary and related functions.

These tests require a compiled ELF binary to analyze. They use pytest fixtures
to locate or create test binaries, and skip gracefully if none are available.
"""

import os
import subprocess
import tempfile
import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock


def find_any_elf_binary():
    """Find any ELF binary on the system for testing."""
    # Try common system binaries that should exist
    candidates = [
        "/bin/ls",
        "/bin/cat",
        "/bin/echo",
        "/usr/bin/env",
        "/usr/bin/true",
    ]
    for path in candidates:
        if Path(path).exists():
            return path
    return None


def create_minimal_test_binary(tmpdir):
    """Create a minimal test binary for testing."""
    source = tmpdir / "test.c"
    binary = tmpdir / "test"

    source.write_text("""
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    char buf[64];
    if (argc > 1) {
        strcpy(buf, argv[1]);
        printf(buf);
    }
    return 0;
}
""")

    try:
        result = subprocess.run(
            ["gcc", "-o", str(binary), str(source), "-fno-stack-protector", "-no-pie"],
            capture_output=True,
            timeout=30
        )
        if result.returncode == 0 and binary.exists():
            return str(binary)
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    return None


@pytest.fixture(scope="module")
def test_binary(tmp_path_factory):
    """Fixture that provides a test binary, or skips if unavailable."""
    # First try to create a custom test binary
    tmpdir = tmp_path_factory.mktemp("binaries")
    binary = create_minimal_test_binary(tmpdir)
    if binary:
        return binary

    # Fall back to a system binary
    binary = find_any_elf_binary()
    if binary:
        return binary

    pytest.skip("No suitable test binary available")


class TestAnalyzeBinaryIntegration:
    """Integration tests for analyze_binary with a real binary."""

    def test_analyze_binary_returns_dict(self, test_binary):
        """Test that analyze_binary returns a dictionary."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        assert isinstance(result, dict)

    def test_analyze_binary_has_verdict(self, test_binary):
        """Test that result includes verdict."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        assert 'verdict' in result
        valid_verdicts = ['likely_exploitable', 'difficult', 'blocked', 'requires_environment', 'error']
        assert result['verdict'] in valid_verdicts

    def test_analyze_binary_has_protections(self, test_binary):
        """Test that result includes binary protections."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        assert 'protections' in result
        prot = result['protections']
        # Should have standard protection flags
        assert isinstance(prot, dict)

    def test_analyze_binary_has_exploitation_paths(self, test_binary):
        """Test that result includes exploitation path analysis."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        assert 'exploitation_paths' in result
        paths = result['exploitation_paths']
        # Should analyze common vulnerability types
        assert isinstance(paths, dict)

    def test_rop_gadgets_serialized_correctly(self, test_binary):
        """Test that ROP gadgets include essential fields."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        if 'rop_gadgets' in result:
            rg = result['rop_gadgets']
            # Should have gadget count fields (API uses 'total' and 'usable' as keys)
            assert 'total' in rg
            assert 'usable' in rg
            # Should have charset filtering fields
            assert 'printable_gadgets' in rg
            assert 'alphanumeric_gadgets' in rg
            assert 'filtered_by_charset' in rg

    def test_elf_structure_serialized_correctly(self, test_binary):
        """Test that ELF structure includes PLT stub size."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        if 'elf_structure' in result:
            elf = result['elf_structure']
            assert 'plt_stub_size' in elf

    def test_address_space_includes_linker_base(self, test_binary):
        """Test that address space info includes linker base sample."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        if 'address_space' in result:
            addr = result['address_space']
            assert 'ld_base_sample' in addr

    def test_payload_constraints_serialized_correctly(self, test_binary):
        """Test that payload constraints include charset fields."""
        from ..api import analyze_binary
        result = analyze_binary(test_binary)
        if 'payload_constraints' in result:
            pc = result['payload_constraints']
            assert 'must_be_printable' in pc
            assert 'allowed_charset' in pc


class TestAnalysisCachingOptimization:
    """Test that analysis caching optimization works correctly."""

    def test_analysis_runs_once_not_multiple_times(self, test_binary):
        """Test that mitigation analysis only runs once per binary."""
        from ..api import analyze_binary
        import logging

        # Capture log messages
        log_messages = []

        class LogCapture(logging.Handler):
            def emit(self, record):
                log_messages.append(record.getMessage())

        logger = logging.getLogger('packages.exploit_feasibility')
        handler = LogCapture()
        handler.setLevel(logging.INFO)
        original_level = logger.level
        logger.setLevel(logging.INFO)
        logger.addHandler(handler)

        try:
            result = analyze_binary(test_binary)
            # Count how many times full analysis ran
            analysis_count = sum(1 for msg in log_messages if "MITIGATION ANALYSIS" in msg)
            # Should only run once, not multiple times
            assert analysis_count <= 1, f"Analysis ran {analysis_count} times, expected 1"
        finally:
            logger.removeHandler(handler)
            logger.setLevel(original_level)


class TestFormatAnalysisSummaryIntegration:
    """Integration tests for format_analysis_summary."""

    def test_format_real_analysis_result(self, test_binary):
        """Test formatting of actual analysis result."""
        from ..api import analyze_binary, format_analysis_summary

        result = analyze_binary(test_binary)
        summary = format_analysis_summary(result)

        assert isinstance(summary, str)
        assert len(summary) > 0

    def test_verbose_format_includes_more_detail(self, test_binary):
        """Test that verbose mode provides more detail."""
        from ..api import analyze_binary, format_analysis_summary

        result = analyze_binary(test_binary)
        brief = format_analysis_summary(result, verbose=False)
        verbose = format_analysis_summary(result, verbose=True)

        assert isinstance(brief, str)
        assert isinstance(verbose, str)
        # Verbose should typically be longer
        assert len(verbose) >= len(brief)


class TestDataclassDefaultsValid:
    """Test that all dataclass defaults are valid and don't raise errors."""

    def test_rop_gadget_info_instantiates(self):
        """Test ROPGadgetInfo can be instantiated with defaults."""
        from ..context import ROPGadgetInfo
        info = ROPGadgetInfo()
        assert info.total_gadgets == 0
        assert info.all_gadgets == []
        assert info.filtered_by_charset == 0

    def test_elf_structure_instantiates(self):
        """Test ELFStructure can be instantiated with defaults."""
        from ..context import ELFStructure
        struct = ELFStructure()
        assert struct.plt_stub_size == 16
        assert struct.init_array_size == 0

    def test_address_space_info_instantiates(self):
        """Test AddressSpaceInfo can be instantiated with defaults."""
        from ..context import AddressSpaceInfo
        info = AddressSpaceInfo()
        assert info.ld_base_sample is None

    def test_payload_constraints_instantiates(self):
        """Test PayloadConstraints can be instantiated with defaults."""
        from ..context import PayloadConstraints
        constraints = PayloadConstraints()
        assert constraints.bad_byte_reasons == {}
        assert constraints.encoding_suggestions == []
        assert constraints.allowed_charset == ""

    def test_exploit_primitive_instantiates(self):
        """Test ExploitPrimitive can be instantiated with required name."""
        from ..context import ExploitPrimitive
        prim = ExploitPrimitive(name="test_vuln")
        assert prim.name == "test_vuln"
        assert prim.limited_write is False

    def test_write_target_instantiates(self):
        """Test WriteTarget can be instantiated with minimal args."""
        from ..context import WriteTarget
        target = WriteTarget(name="test", address=0x404000)
        assert target.is_absolute is False  # Default is False (offset)
        assert target.writable is True
