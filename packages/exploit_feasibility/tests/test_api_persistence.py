#!/usr/bin/env python3
"""Tests for API context persistence functions."""

import json
import os
import tempfile
import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock

from ..api import (
    save_exploit_context,
    load_exploit_context,
    print_exploit_context,
)


class TestSaveExploitContext:
    """Tests for save_exploit_context function."""

    @pytest.fixture
    def mock_analysis_result(self):
        """Mock result from analyze_binary."""
        return {
            'verdict': 'likely_exploitable',
            'protections': {
                'relro': True,
                'full_relro': False,
                'pie': True,
                'nx': True,
                'canary': True,
            },
            'glibc_version': '2.35',
            'glibc_n_disabled': False,
            'blockers': ['Full RELRO blocks GOT overwrites'],
            'constraints': {
                'strcpy_rop_viable': False,
                'null_byte_position': 6,
            },
            'libc': {
                'version': '2.35',
                'system_offset': 0x50d70,
                'bin_sh_offset': 0x1d8698,
                'one_gadgets_detailed': [
                    {'offset': 0xebc81, 'constraints': 'rax == NULL'},
                ],
            },
            'rop_gadgets': {
                'total': 150,
                'usable': 42,
                'pop_rdi': 0x401234,
                'ret': 0x401016,
            },
            'binary_specific': {
                'viable_targets': [
                    {'name': '.fini_array', 'address': '0x404000', 'technique': 'overwrite'},
                ],
                'blocked_techniques': {'got_overwrite': 'Full RELRO'},
                'viable_techniques': ['fini_array', 'stack_pivot'],
            },
            'exploitation_paths': {
                'format_string': {
                    'verdict': 'DIFFICULT',
                    'chain_breaks': ['GOT is read-only'],
                },
            },
        }

    def test_save_creates_file(self, mock_analysis_result):
        """Test that save_exploit_context creates a JSON file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            binary_path = Path(tmpdir) / "test_binary"
            binary_path.touch()

            with patch('packages.exploit_feasibility.api.analyze_binary', return_value=mock_analysis_result):
                ctx_file = save_exploit_context(str(binary_path), tmpdir)

            assert os.path.exists(ctx_file)
            assert ctx_file.endswith('_exploit_context.json')

    def test_save_contains_required_fields(self, mock_analysis_result):
        """Test that saved context contains all required fields."""
        with tempfile.TemporaryDirectory() as tmpdir:
            binary_path = Path(tmpdir) / "test_binary"
            binary_path.touch()

            with patch('packages.exploit_feasibility.api.analyze_binary', return_value=mock_analysis_result):
                ctx_file = save_exploit_context(str(binary_path), tmpdir)

            with open(ctx_file) as f:
                ctx = json.load(f)

            # Check required fields
            assert '_meta' in ctx
            assert 'binary' in ctx['_meta']
            assert 'created' in ctx['_meta']
            assert 'verdict' in ctx
            assert 'protections' in ctx

    def test_save_includes_libc_offsets(self, mock_analysis_result):
        """Test that saved context includes libc offsets."""
        with tempfile.TemporaryDirectory() as tmpdir:
            binary_path = Path(tmpdir) / "test_binary"
            binary_path.touch()

            with patch('packages.exploit_feasibility.api.analyze_binary', return_value=mock_analysis_result):
                ctx_file = save_exploit_context(str(binary_path), tmpdir)

            with open(ctx_file) as f:
                ctx = json.load(f)

            assert 'libc' in ctx
            assert ctx['libc']['system_offset'] == 0x50d70
            assert ctx['libc']['bin_sh_offset'] == 0x1d8698

    def test_save_includes_rop_gadgets(self, mock_analysis_result):
        """Test that saved context includes ROP gadgets."""
        with tempfile.TemporaryDirectory() as tmpdir:
            binary_path = Path(tmpdir) / "test_binary"
            binary_path.touch()

            with patch('packages.exploit_feasibility.api.analyze_binary', return_value=mock_analysis_result):
                ctx_file = save_exploit_context(str(binary_path), tmpdir)

            with open(ctx_file) as f:
                ctx = json.load(f)

            assert 'rop_gadgets' in ctx
            assert ctx['rop_gadgets']['pop_rdi'] == 0x401234

    def test_save_uses_binary_parent_dir_by_default(self, mock_analysis_result):
        """Test that save uses binary's parent directory by default."""
        with tempfile.TemporaryDirectory() as tmpdir:
            subdir = Path(tmpdir) / "subdir"
            subdir.mkdir()
            binary_path = subdir / "test_binary"
            binary_path.touch()

            with patch('packages.exploit_feasibility.api.analyze_binary', return_value=mock_analysis_result):
                ctx_file = save_exploit_context(str(binary_path))

            assert Path(ctx_file).parent == subdir


class TestLoadExploitContext:
    """Tests for load_exploit_context function."""

    def test_load_returns_dict(self):
        """Test that load_exploit_context returns a dictionary."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump({
                '_meta': {'binary': '/test', 'binary_name': 'test'},
                'verdict': 'likely_exploitable',
            }, f)
            f.flush()

            try:
                ctx = load_exploit_context(f.name)
                assert isinstance(ctx, dict)
                assert ctx['verdict'] == 'likely_exploitable'
            finally:
                os.unlink(f.name)

    def test_load_raises_on_missing_file(self):
        """Test that load_exploit_context raises FileNotFoundError for missing files."""
        with pytest.raises(FileNotFoundError):
            load_exploit_context('/nonexistent/path/context.json')

    def test_load_preserves_all_data(self):
        """Test that load preserves all data from saved context."""
        test_data = {
            '_meta': {'binary': '/test/binary', 'binary_name': 'binary', 'created': '2024-01-01'},
            'verdict': 'difficult',
            'protections': {'pie': True, 'nx': True},
            'libc': {'system_offset': 0x12345},
            'rop_gadgets': {'pop_rdi': 0x401234},
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(test_data, f)
            f.flush()

            try:
                ctx = load_exploit_context(f.name)
                assert ctx == test_data
            finally:
                os.unlink(f.name)


class TestPrintExploitContext:
    """Tests for print_exploit_context function."""

    def test_print_returns_string(self):
        """Test that print_exploit_context returns a string."""
        test_data = {
            '_meta': {'binary': '/test/binary', 'binary_name': 'binary'},
            'verdict': 'likely_exploitable',
            'protections': {'pie': True, 'nx': True, 'full_relro': False},
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(test_data, f)
            f.flush()

            try:
                output = print_exploit_context(f.name)
                assert isinstance(output, str)
                assert 'binary' in output.lower()
            finally:
                os.unlink(f.name)

    def test_print_includes_verdict(self):
        """Test that print output includes verdict in human-readable form."""
        test_data = {
            '_meta': {'binary': '/test/binary', 'binary_name': 'binary'},
            'verdict': 'likely_exploitable',
            'protections': {},
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(test_data, f)
            f.flush()

            try:
                output = print_exploit_context(f.name)
                # Should be human-readable, not LIKELY_EXPLOITABLE
                assert 'Likely exploitable' in output
            finally:
                os.unlink(f.name)

    def test_print_includes_protections(self):
        """Test that print output includes protections."""
        test_data = {
            '_meta': {'binary': '/test/binary', 'binary_name': 'binary'},
            'verdict': 'difficult',
            'protections': {'pie': True, 'nx': True, 'full_relro': True, 'canary': True},
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(test_data, f)
            f.flush()

            try:
                output = print_exploit_context(f.name)
                assert 'Full RELRO' in output
                assert 'PIE' in output
                assert 'NX' in output
                assert 'Canary' in output
            finally:
                os.unlink(f.name)

    def test_print_includes_libc_offsets(self):
        """Test that print output includes libc offsets."""
        test_data = {
            '_meta': {'binary': '/test/binary', 'binary_name': 'binary'},
            'verdict': 'difficult',
            'protections': {},
            'libc': {
                'system_offset': 0x50d70,
                'bin_sh_offset': 0x1d8698,
            },
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(test_data, f)
            f.flush()

            try:
                output = print_exploit_context(f.name)
                assert '0x50d70' in output
                assert '0x1d8698' in output
            finally:
                os.unlink(f.name)

    def test_print_includes_rop_gadgets(self):
        """Test that print output includes ROP gadgets."""
        test_data = {
            '_meta': {'binary': '/test/binary', 'binary_name': 'binary'},
            'verdict': 'difficult',
            'protections': {},
            'rop_gadgets': {
                'total': 100,
                'usable': 25,
                'pop_rdi': 0x401234,
                'ret': 0x401016,
            },
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(test_data, f)
            f.flush()

            try:
                output = print_exploit_context(f.name)
                assert 'pop_rdi' in output
                assert '0x401234' in output
            finally:
                os.unlink(f.name)


class TestRoundTrip:
    """Test save -> load -> print round trip."""

    def test_full_round_trip(self):
        """Test complete save -> load -> print cycle."""
        mock_result = {
            'verdict': 'likely_exploitable',
            'protections': {'pie': True, 'nx': True, 'full_relro': False, 'canary': True},
            'glibc_version': '2.35',
            'glibc_n_disabled': False,
            'blockers': [],
            'constraints': {},
            'libc': {'system_offset': 0x50d70, 'bin_sh_offset': 0x1d8698},
            'rop_gadgets': {'total': 100, 'usable': 25, 'pop_rdi': 0x401234},
        }

        with tempfile.TemporaryDirectory() as tmpdir:
            binary_path = Path(tmpdir) / "test_binary"
            binary_path.touch()

            # Save
            with patch('packages.exploit_feasibility.api.analyze_binary', return_value=mock_result):
                ctx_file = save_exploit_context(str(binary_path), tmpdir)

            # Load
            ctx = load_exploit_context(ctx_file)
            assert ctx['verdict'] == 'likely_exploitable'
            assert ctx['libc']['system_offset'] == 0x50d70

            # Print
            output = print_exploit_context(ctx_file)
            # Should be human-readable, not LIKELY_EXPLOITABLE
            assert 'Likely exploitable' in output
            assert '0x50d70' in output
