#!/usr/bin/env python3
"""Tests for graph module."""

import pytest
from ..graph import (
    PrimitiveDependencyGraph,
    create_dependency_graph,
)


class TestPrimitiveDependencyGraph:
    """Tests for PrimitiveDependencyGraph class."""

    def test_init_empty(self):
        """Test initialization with no mitigations."""
        graph = PrimitiveDependencyGraph()
        assert len(graph.active_mitigations) == 0
        assert len(graph.primitives) > 0

    def test_init_with_mitigations(self):
        """Test initialization with mitigations."""
        graph = PrimitiveDependencyGraph(["full_relro", "stack_canary"])
        assert "full_relro" in graph.active_mitigations
        assert "stack_canary" in graph.active_mitigations

    def test_is_blocked_without_mitigation(self):
        """Test is_blocked when mitigation not active."""
        graph = PrimitiveDependencyGraph()
        blocked, reason = graph.is_blocked("format_string_write")
        assert not blocked

    def test_is_blocked_with_mitigation(self):
        """Test is_blocked when mitigation is active."""
        graph = PrimitiveDependencyGraph(["glibc_n_disabled"])
        blocked, reason = graph.is_blocked("format_string_write")
        assert blocked
        assert reason == "glibc_n_disabled"

    def test_get_available_primitives(self):
        """Test getting available primitives from starting point."""
        graph = PrimitiveDependencyGraph()
        available = graph.get_available_primitives(["format_string_vuln"])
        # Format string vuln should provide format_string_read
        assert "format_string_read" in available or "libc_leak" in available

    def test_find_paths_to_goal_basic(self):
        """Test finding paths to code execution."""
        graph = PrimitiveDependencyGraph()
        paths = graph.find_paths_to_goal("format_string_vuln", "code_execution")
        # Note: The simplified graph module may not find all paths
        # The full path-finding is in analyzer.py
        # Just verify the function runs without error and returns a list
        assert isinstance(paths, list)
        for path in paths:
            assert path.goal == "code_execution"
            assert "format_string_vuln" in path.steps

    def test_find_paths_blocked_by_mitigation(self):
        """Test that mitigations block certain paths."""
        # Without mitigation - format_string_write paths available
        graph_no_mit = PrimitiveDependencyGraph()
        paths_no_mit = graph_no_mit.find_paths_to_goal("format_string_vuln")

        # With glibc_n_disabled - format_string_write blocked
        graph_mit = PrimitiveDependencyGraph(["glibc_n_disabled"])
        paths_mit = graph_mit.find_paths_to_goal("format_string_vuln")

        # Paths using format_string_write should be fewer/different
        # This is a structural test - exact counts may vary
        write_paths_no_mit = [p for p in paths_no_mit if "format_string_write" in p.steps]
        write_paths_mit = [p for p in paths_mit if "format_string_write" in p.steps]
        assert len(write_paths_mit) == 0  # Write paths should be blocked

    def test_get_shortest_path(self):
        """Test getting shortest path."""
        graph = PrimitiveDependencyGraph()
        path = graph.get_shortest_path("format_string_vuln")
        if path:
            assert path.goal == "code_execution"
            # Should be relatively short
            assert len(path.steps) <= 10

    def test_get_most_reliable_path(self):
        """Test getting most reliable path."""
        graph = PrimitiveDependencyGraph()
        path = graph.get_most_reliable_path("format_string_vuln")
        if path:
            assert path.goal == "code_execution"
            assert path.total_reliability > 0

    def test_get_primitive_info(self):
        """Test getting primitive info."""
        graph = PrimitiveDependencyGraph()
        info = graph.get_primitive_info("libc_leak")
        assert info is not None
        assert info.primitive.name == "libc_leak"

    def test_get_primitive_info_nonexistent(self):
        """Test getting info for non-existent primitive."""
        graph = PrimitiveDependencyGraph()
        info = graph.get_primitive_info("nonexistent_primitive")
        assert info is None

    def test_summary(self):
        """Test summary output."""
        graph = PrimitiveDependencyGraph(["full_relro"])
        summary = graph.summary()
        assert "PRIMITIVE DEPENDENCY GRAPH" in summary
        assert "full_relro" in summary


class TestCreateDependencyGraph:
    """Tests for create_dependency_graph function."""

    def test_binary_protections_relro(self):
        """Test that full RELRO is detected."""
        graph = create_dependency_graph(
            binary_protections={"full_relro": True}
        )
        assert "full_relro" in graph.active_mitigations

    def test_binary_protections_partial_relro(self):
        """Test that partial RELRO is detected."""
        graph = create_dependency_graph(
            binary_protections={"relro": True, "full_relro": False}
        )
        assert "partial_relro" in graph.active_mitigations

    def test_binary_protections_canary(self):
        """Test that canary is detected."""
        graph = create_dependency_graph(
            binary_protections={"canary": True}
        )
        assert "stack_canary" in graph.active_mitigations

    def test_binary_protections_pie(self):
        """Test that PIE is detected."""
        graph = create_dependency_graph(
            binary_protections={"pie": True}
        )
        assert "pie" in graph.active_mitigations

    def test_glibc_version_hooks_removed(self):
        """Test glibc 2.34+ hooks removed detection."""
        graph = create_dependency_graph(glibc_version="2.34")
        assert "glibc_hooks_removed" in graph.active_mitigations

    def test_glibc_version_n_disabled(self):
        """Test glibc 2.38+ %n disabled detection."""
        graph = create_dependency_graph(glibc_version="2.38")
        assert "glibc_n_disabled" in graph.active_mitigations

    def test_glibc_version_safe_linking(self):
        """Test glibc 2.32+ safe-linking detection."""
        graph = create_dependency_graph(glibc_version="2.32")
        assert "safe_linking" in graph.active_mitigations

    def test_glibc_version_tcache_key(self):
        """Test glibc 2.29+ tcache key detection."""
        graph = create_dependency_graph(glibc_version="2.29")
        assert "tcache_key" in graph.active_mitigations

    def test_glibc_version_old(self):
        """Test old glibc version has fewer mitigations."""
        graph = create_dependency_graph(glibc_version="2.25")
        assert "glibc_hooks_removed" not in graph.active_mitigations
        assert "glibc_n_disabled" not in graph.active_mitigations
        assert "safe_linking" not in graph.active_mitigations

    def test_glibc_version_parsing_full_string(self):
        """Test glibc version parsing from full ldd string."""
        graph = create_dependency_graph(glibc_version="ldd (Ubuntu GLIBC 2.38-0ubuntu3) 2.38")
        assert "glibc_n_disabled" in graph.active_mitigations

    def test_additional_mitigations(self):
        """Test additional mitigations are added."""
        graph = create_dependency_graph(
            additional_mitigations=["custom_mitigation"]
        )
        assert "custom_mitigation" in graph.active_mitigations

    def test_combined(self):
        """Test combined protections and glibc version."""
        graph = create_dependency_graph(
            binary_protections={"full_relro": True, "pie": True, "canary": True},
            glibc_version="2.38",
        )
        assert "full_relro" in graph.active_mitigations
        assert "pie" in graph.active_mitigations
        assert "stack_canary" in graph.active_mitigations
        assert "glibc_n_disabled" in graph.active_mitigations
