#!/usr/bin/env python3
"""
Tests for analysis strategies (Phase 2-4 implementation).

Tests cover:
- Strategy selection based on profile context
- Local vs remote glibc version detection
- Web application context skipping memory mitigations
- Kernel context with kernel-specific mitigations
- Confidence tracking
"""

import pytest
from unittest.mock import patch, MagicMock

from packages.exploit_feasibility.profiles import (
    TargetContext,
    TargetProfile,
    create_local_profile,
    create_remote_profile,
    create_web_profile,
    create_kernel_profile,
)
from packages.exploit_feasibility.strategies import (
    AnalysisStrategy,
    LocalBinaryStrategy,
    RemoteBinaryStrategy,
    WebApplicationStrategy,
    KernelStrategy,
    get_analysis_strategy,
)
from packages.exploit_feasibility.analyzer import FeasibilityAnalyzer, FeasibilityReport
from packages.exploit_feasibility.vuln_types import ExploitabilityVerdict


class TestStrategySelection:
    """Test that correct strategy is selected based on profile context."""

    def test_local_binary_strategy(self):
        """Local binary profile should use LocalBinaryStrategy."""
        profile = create_local_profile()
        strategy = get_analysis_strategy(profile)
        assert isinstance(strategy, LocalBinaryStrategy)

    def test_remote_binary_strategy(self):
        """Remote binary profile should use RemoteBinaryStrategy."""
        profile = create_remote_profile(glibc_version="2.31")
        strategy = get_analysis_strategy(profile)
        assert isinstance(strategy, RemoteBinaryStrategy)

    def test_web_application_strategy(self):
        """Web application profile should use WebApplicationStrategy."""
        profile = create_web_profile()
        strategy = get_analysis_strategy(profile)
        assert isinstance(strategy, WebApplicationStrategy)

    def test_kernel_strategy(self):
        """Kernel profile should use KernelStrategy."""
        profile = create_kernel_profile()
        strategy = get_analysis_strategy(profile)
        assert isinstance(strategy, KernelStrategy)

    def test_unknown_context_defaults_to_local(self):
        """Unknown context should default to LocalBinaryStrategy."""
        profile = TargetProfile(context=TargetContext.UNKNOWN)
        strategy = get_analysis_strategy(profile)
        assert isinstance(strategy, LocalBinaryStrategy)


class TestLocalBinaryStrategy:
    """Tests for LocalBinaryStrategy."""

    def test_can_detect_locally(self):
        """Local strategy can detect locally."""
        profile = create_local_profile()
        strategy = LocalBinaryStrategy(profile)
        assert strategy.can_detect_locally() is True

    def test_should_check_memory_mitigations(self):
        """Local strategy should check memory mitigations."""
        profile = create_local_profile()
        strategy = LocalBinaryStrategy(profile)
        assert strategy.should_check_memory_mitigations() is True

    def test_should_not_skip_empirical_tests(self):
        """Local strategy should not skip empirical tests."""
        profile = create_local_profile()
        strategy = LocalBinaryStrategy(profile)
        assert strategy.should_skip_empirical_tests() is False

    @patch('subprocess.run')
    def test_get_glibc_version_detected(self, mock_run):
        """Local strategy detects glibc version."""
        mock_run.return_value = MagicMock(
            returncode=0,
            stdout="ldd (Ubuntu GLIBC 2.35-0ubuntu3) 2.35\n"
        )
        profile = create_local_profile()
        strategy = LocalBinaryStrategy(profile)
        version, confidence = strategy.get_glibc_version()
        assert version == "2.35"
        assert confidence == "detected"


class TestRemoteBinaryStrategy:
    """Tests for RemoteBinaryStrategy."""

    def test_cannot_detect_locally(self):
        """Remote strategy cannot detect locally."""
        profile = create_remote_profile(glibc_version="2.31")
        strategy = RemoteBinaryStrategy(profile)
        assert strategy.can_detect_locally() is False

    def test_should_check_memory_mitigations(self):
        """Remote strategy should check memory mitigations."""
        profile = create_remote_profile(glibc_version="2.31")
        strategy = RemoteBinaryStrategy(profile)
        assert strategy.should_check_memory_mitigations() is True

    def test_should_skip_empirical_tests(self):
        """Remote strategy should skip empirical tests."""
        profile = create_remote_profile(glibc_version="2.31")
        strategy = RemoteBinaryStrategy(profile)
        assert strategy.should_skip_empirical_tests() is True

    def test_get_glibc_version_provided(self):
        """Remote strategy uses provided glibc version."""
        profile = create_remote_profile(glibc_version="2.31")
        strategy = RemoteBinaryStrategy(profile)
        version, confidence = strategy.get_glibc_version()
        assert version == "2.31"
        assert confidence == "provided"

    def test_get_glibc_version_unknown(self):
        """Remote strategy returns unknown when no version provided."""
        profile = create_remote_profile()
        strategy = RemoteBinaryStrategy(profile)
        version, confidence = strategy.get_glibc_version()
        assert version is None
        assert confidence == "unknown"

    def test_format_n_allowed_old_glibc(self):
        """Remote with old glibc allows %n."""
        profile = create_remote_profile(glibc_version="2.31")
        strategy = RemoteBinaryStrategy(profile)
        blocked, reason = strategy.get_format_n_status()
        assert blocked is False
        assert reason == "allowed_by_version"

    def test_format_n_blocked_new_glibc(self):
        """Remote with new glibc blocks %n."""
        profile = create_remote_profile(glibc_version="2.38")
        strategy = RemoteBinaryStrategy(profile)
        blocked, reason = strategy.get_format_n_status()
        assert blocked is True
        assert reason == "blocked_by_version"

    def test_format_n_assumed_blocked_unknown(self):
        """Remote with unknown glibc assumes %n blocked."""
        profile = create_remote_profile()
        strategy = RemoteBinaryStrategy(profile)
        blocked, reason = strategy.get_format_n_status()
        assert blocked is True
        assert reason == "unknown_glibc_assuming_blocked"

    def test_context_warnings_unknown_glibc(self):
        """Remote strategy warns about unknown glibc."""
        profile = create_remote_profile()
        strategy = RemoteBinaryStrategy(profile)
        warnings = strategy.get_context_warnings()
        assert len(warnings) == 1
        assert "glibc version unknown" in warnings[0]

    def test_context_warnings_known_glibc(self):
        """Remote strategy doesn't warn when glibc is known."""
        profile = create_remote_profile(glibc_version="2.31")
        strategy = RemoteBinaryStrategy(profile)
        warnings = strategy.get_context_warnings()
        assert len(warnings) == 0


class TestWebApplicationStrategy:
    """Tests for WebApplicationStrategy."""

    def test_cannot_detect_locally(self):
        """Web strategy cannot detect locally."""
        profile = create_web_profile()
        strategy = WebApplicationStrategy(profile)
        assert strategy.can_detect_locally() is False

    def test_should_not_check_memory_mitigations(self):
        """Web strategy should NOT check memory mitigations."""
        profile = create_web_profile()
        strategy = WebApplicationStrategy(profile)
        assert strategy.should_check_memory_mitigations() is False

    def test_should_skip_empirical_tests(self):
        """Web strategy should skip empirical tests."""
        profile = create_web_profile()
        strategy = WebApplicationStrategy(profile)
        assert strategy.should_skip_empirical_tests() is True

    def test_glibc_not_applicable(self):
        """Web strategy returns not_applicable for glibc."""
        profile = create_web_profile()
        strategy = WebApplicationStrategy(profile)
        version, confidence = strategy.get_glibc_version()
        assert version is None
        assert confidence == "not_applicable"

    def test_binary_protections_not_applicable(self):
        """Web strategy returns not_applicable for binary protections."""
        profile = create_web_profile()
        strategy = WebApplicationStrategy(profile)
        protections, confidence = strategy.get_binary_protections()
        assert protections == {}
        assert confidence == "not_applicable"

    def test_relevant_checks(self):
        """Web strategy has web-relevant checks."""
        profile = create_web_profile()
        strategy = WebApplicationStrategy(profile)
        checks = strategy.get_relevant_checks()
        assert "input_validation" in checks
        assert "parameterized_queries" in checks
        assert "csp_headers" in checks

    def test_context_warnings(self):
        """Web strategy has context warnings."""
        profile = create_web_profile()
        strategy = WebApplicationStrategy(profile)
        warnings = strategy.get_context_warnings()
        assert len(warnings) == 1
        assert "memory corruption mitigations not applicable" in warnings[0].lower()


class TestKernelStrategy:
    """Tests for KernelStrategy."""

    def test_can_detect_locally(self):
        """Kernel strategy can detect locally."""
        profile = create_kernel_profile()
        strategy = KernelStrategy(profile)
        assert strategy.can_detect_locally() is True

    def test_should_check_memory_mitigations(self):
        """Kernel strategy should check memory mitigations."""
        profile = create_kernel_profile()
        strategy = KernelStrategy(profile)
        assert strategy.should_check_memory_mitigations() is True

    def test_should_skip_empirical_tests(self):
        """Kernel strategy should skip glibc empirical tests."""
        profile = create_kernel_profile()
        strategy = KernelStrategy(profile)
        assert strategy.should_skip_empirical_tests() is True

    def test_glibc_not_applicable(self):
        """Kernel strategy returns not_applicable for glibc."""
        profile = create_kernel_profile()
        strategy = KernelStrategy(profile)
        version, confidence = strategy.get_glibc_version()
        assert version is None
        assert confidence == "not_applicable"

    def test_get_kernel_mitigations(self):
        """Kernel strategy detects kernel mitigations."""
        # Don't mock - let it read real system values
        profile = create_kernel_profile()
        strategy = KernelStrategy(profile)
        mitigations, confidence = strategy.get_kernel_mitigations()

        # Should have all mitigation categories
        assert 'kaslr' in mitigations
        assert 'smep' in mitigations
        assert 'smap' in mitigations
        assert 'kpti' in mitigations
        assert 'lockdown' in mitigations
        assert 'selinux' in mitigations
        assert confidence == "detected"

        # Each mitigation should have an 'enabled' key
        assert 'enabled' in mitigations['kaslr']
        assert 'enabled' in mitigations['smep']
        assert 'enabled' in mitigations['smap']
        assert 'enabled' in mitigations['kpti']


class TestAnalyzerWithStrategies:
    """Test FeasibilityAnalyzer integration with strategies."""

    def test_analyzer_with_local_profile(self):
        """Analyzer uses LocalBinaryStrategy for local profile."""
        analyzer = FeasibilityAnalyzer()
        assert isinstance(analyzer.strategy, LocalBinaryStrategy)

    def test_analyzer_with_remote_profile(self):
        """Analyzer uses RemoteBinaryStrategy for remote profile."""
        profile = create_remote_profile(glibc_version="2.31")
        analyzer = FeasibilityAnalyzer(profile=profile)
        assert isinstance(analyzer.strategy, RemoteBinaryStrategy)

    def test_analyzer_with_web_profile(self):
        """Analyzer uses WebApplicationStrategy for web profile."""
        profile = create_web_profile()
        analyzer = FeasibilityAnalyzer(profile=profile)
        assert isinstance(analyzer.strategy, WebApplicationStrategy)

    def test_analyzer_with_kernel_profile(self):
        """Analyzer uses KernelStrategy for kernel profile."""
        profile = create_kernel_profile()
        analyzer = FeasibilityAnalyzer(profile=profile)
        assert isinstance(analyzer.strategy, KernelStrategy)

    def test_web_analysis_skips_memory_checks(self):
        """Web profile analysis skips memory mitigation checks."""
        profile = create_web_profile()
        analyzer = FeasibilityAnalyzer(profile=profile)
        report = analyzer.full_analysis()

        assert report.verdict == ExploitabilityVerdict.UNKNOWN
        assert len(report.context_notes) > 0
        assert any("memory corruption" in note.lower() for note in report.context_notes)

    def test_remote_analysis_uses_provided_glibc(self):
        """Remote profile uses provided glibc version."""
        profile = create_remote_profile(glibc_version="2.31")
        analyzer = FeasibilityAnalyzer(profile=profile)
        report = analyzer.full_analysis()

        # Should not be blocked by %n (2.31 < 2.38)
        assert report.glibc_major_minor == 2.31
        assert report.confidence.get('glibc_version') == 'provided'

    def test_remote_analysis_unknown_glibc_warns(self):
        """Remote profile with unknown glibc generates warning."""
        profile = create_remote_profile()
        analyzer = FeasibilityAnalyzer(profile=profile)
        report = analyzer.full_analysis()

        # Should have warning about unknown glibc
        assert any("unknown" in w.lower() for w in report.warnings)


class TestConfidenceTracking:
    """Test confidence tracking in FeasibilityReport."""

    def test_add_finding(self):
        """Test add_finding method."""
        report = FeasibilityReport()
        report.add_finding('test_key', 'test_value', 'detected')

        assert report.test_key == 'test_value'
        assert report.confidence['test_key'] == 'detected'

    def test_local_confidence_is_detected(self):
        """Local analysis has detected confidence."""
        analyzer = FeasibilityAnalyzer()
        report = analyzer.full_analysis()

        # glibc should be detected for local
        assert report.confidence.get('glibc_version') in ('detected', None)

    def test_remote_confidence_is_provided(self):
        """Remote analysis with provided values has provided confidence."""
        profile = create_remote_profile(glibc_version="2.31")
        analyzer = FeasibilityAnalyzer(profile=profile)
        report = analyzer.full_analysis()

        assert report.confidence.get('glibc_version') == 'provided'


class TestKernelPrimitives:
    """Test kernel primitives are defined correctly."""

    def test_kernel_primitives_exist(self):
        """Kernel primitives are in the primitive definitions."""
        from packages.exploit_feasibility.primitives import get_primitive_definitions, PrimitiveID

        primitives = get_primitive_definitions()

        assert PrimitiveID.KERNEL_ARBITRARY_READ.value in primitives
        assert PrimitiveID.KERNEL_ARBITRARY_WRITE.value in primitives
        assert PrimitiveID.KERNEL_ADDR_LEAK.value in primitives
        assert PrimitiveID.KERNEL_ROP.value in primitives
        assert PrimitiveID.RET2USR.value in primitives
        assert PrimitiveID.MODPROBE_PATH_OVERWRITE.value in primitives
        assert PrimitiveID.CRED_OVERWRITE.value in primitives
        assert PrimitiveID.ROOT_PRIVILEGES.value in primitives

    def test_kernel_mitigations_exist(self):
        """Kernel mitigations are in the mitigation definitions."""
        from packages.exploit_feasibility.primitives import MitigationID

        assert hasattr(MitigationID, 'KASLR')
        assert hasattr(MitigationID, 'SMEP')
        assert hasattr(MitigationID, 'SMAP')
        assert hasattr(MitigationID, 'KPTI')

    def test_ret2usr_blocked_by_smep(self):
        """ret2usr is blocked by SMEP."""
        from packages.exploit_feasibility.primitives import get_primitive_definitions, PrimitiveID, MitigationID

        primitives = get_primitive_definitions()
        ret2usr = primitives[PrimitiveID.RET2USR.value]

        assert MitigationID.SMEP.value in ret2usr.blocked_by
