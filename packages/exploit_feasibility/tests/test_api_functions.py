#!/usr/bin/env python3
"""Tests for API functions that were previously untested."""

import pytest
from unittest.mock import patch, MagicMock
from ..api import (
    find_exploit_paths,
    format_analysis_summary,
    check_exploit_viability,
    get_exploit_constraints,
    list_primitives,
    get_primitive_requirements,
)


class TestFindExploitPaths:
    """Tests for find_exploit_paths function."""

    def test_returns_dict(self):
        """Test that find_exploit_paths returns a dictionary."""
        result = find_exploit_paths("format_string_vuln")
        assert isinstance(result, dict)
        assert 'paths' in result or 'verdict' in result

    def test_format_string_vuln_paths(self):
        """Test path finding for format string vulnerability."""
        result = find_exploit_paths(
            "format_string_vuln",
            binary_protections={'full_relro': False},
            glibc_version='2.30'
        )
        assert isinstance(result, dict)

    def test_stack_overflow_vuln_paths(self):
        """Test path finding for stack overflow vulnerability."""
        result = find_exploit_paths(
            "stack_overflow_vuln",
            binary_protections={'canary': False, 'nx': True},
        )
        assert isinstance(result, dict)

    def test_heap_overflow_vuln_paths(self):
        """Test path finding for heap overflow vulnerability."""
        result = find_exploit_paths(
            "heap_overflow_vuln",
            binary_protections={'full_relro': True},
            glibc_version='2.35'
        )
        assert isinstance(result, dict)

    def test_caches_protections(self):
        """Test that passing binary_protections avoids redundant analysis."""
        # When binary_protections is passed, should NOT run full_analysis
        result = find_exploit_paths(
            "format_string_vuln",
            binary_protections={'full_relro': True, 'pie': True},
            glibc_version='2.35'
        )
        assert isinstance(result, dict)

    def test_glibc_n_verified_override(self):
        """Test that glibc_n_verified_working overrides version-based detection."""
        # Even with glibc 2.42, if empirically verified working, should not block
        result = find_exploit_paths(
            "format_string_vuln",
            glibc_n_verified_working=True,
            binary_protections={'full_relro': False},
            glibc_version='2.42'
        )
        # format_string_write should not be blocked
        blocked = result.get('blocked_primitives', [])
        assert 'format_string_write' not in blocked or result.get('verdict') != 'NOT_EXPLOITABLE'

    def test_input_constraints_passed(self):
        """Test that input constraints affect path analysis."""
        result = find_exploit_paths(
            "stack_overflow_vuln",
            input_constraints={
                'input_handler': 'strcpy',
                'null_byte_position': 6,
                'blocked_techniques': ['multi_gadget_rop'],
            },
            binary_protections={'nx': True},
        )
        assert isinstance(result, dict)


class TestFormatAnalysisSummary:
    """Tests for format_analysis_summary function."""

    def test_returns_string(self):
        """Test that format_analysis_summary returns a string."""
        result = {
            'verdict': 'difficult',
            'protections': {'pie': True, 'nx': True},
            'blockers': ['Full RELRO'],
        }
        summary = format_analysis_summary(result)
        assert isinstance(summary, str)

    def test_includes_verdict(self):
        """Test that summary includes verdict."""
        result = {
            'verdict': 'likely_exploitable',
            'protections': {},
        }
        summary = format_analysis_summary(result)
        assert 'likely' in summary.lower() or 'exploitable' in summary.lower()

    def test_verbose_mode_more_detail(self):
        """Test that verbose mode includes more detail."""
        result = {
            'verdict': 'difficult',
            'protections': {'pie': True, 'nx': True, 'full_relro': True},
            'blockers': ['Full RELRO blocks GOT overwrites'],
            'warnings': ['No stack canary'],
            'exploitation_paths': {
                'format_string_vuln': {'verdict': 'DIFFICULT'}
            }
        }
        brief = format_analysis_summary(result, verbose=False)
        verbose = format_analysis_summary(result, verbose=True)
        # Verbose should be longer or equal
        assert len(verbose) >= len(brief)

    def test_handles_empty_result(self):
        """Test handling of minimal result."""
        result = {'verdict': 'unknown'}
        summary = format_analysis_summary(result)
        assert isinstance(summary, str)


class TestCheckExploitViability:
    """Tests for check_exploit_viability function."""

    def test_returns_tuple(self):
        """Test that check_exploit_viability returns a tuple of (bool, str)."""
        from ..vuln_types import ExploitabilityVerdict
        from ..analyzer import FeasibilityAnalyzer
        with patch.object(FeasibilityAnalyzer, 'full_analysis') as mock_analysis:
            mock_report = MagicMock()
            mock_report.verdict = ExploitabilityVerdict.LIKELY_EXPLOITABLE
            mock_report.blockers = []
            mock_report.warnings = []
            mock_analysis.return_value = mock_report

            result = check_exploit_viability(vuln_type="format_string")
            assert isinstance(result, tuple)
            assert len(result) == 2
            is_viable, reason = result
            assert isinstance(is_viable, bool)
            assert isinstance(reason, str)

    def test_likely_exploitable_returns_true(self):
        """Test that LIKELY_EXPLOITABLE verdict returns True."""
        from ..vuln_types import ExploitabilityVerdict
        from ..analyzer import FeasibilityAnalyzer
        with patch.object(FeasibilityAnalyzer, 'full_analysis') as mock_analysis:
            mock_report = MagicMock()
            mock_report.verdict = ExploitabilityVerdict.LIKELY_EXPLOITABLE
            mock_report.blockers = []
            mock_report.warnings = ['Some warning']
            mock_analysis.return_value = mock_report

            is_viable, reason = check_exploit_viability(vuln_type="format_string")
            assert is_viable is True
            assert 'exploitable' in reason.lower() or 'warning' in reason.lower()

    def test_unlikely_returns_false(self):
        """Test that UNLIKELY verdict returns False."""
        from ..vuln_types import ExploitabilityVerdict
        from ..analyzer import FeasibilityAnalyzer
        with patch.object(FeasibilityAnalyzer, 'full_analysis') as mock_analysis:
            mock_report = MagicMock()
            mock_report.verdict = ExploitabilityVerdict.UNLIKELY
            mock_report.blockers = ['No viable path']
            mock_report.warnings = []
            mock_analysis.return_value = mock_report

            is_viable, reason = check_exploit_viability(vuln_type="format_string")
            assert is_viable is False
            assert 'unlikely' in reason.lower()

    def test_difficult_returns_true(self):
        """Test that DIFFICULT verdict returns True (still possible)."""
        from ..vuln_types import ExploitabilityVerdict
        from ..analyzer import FeasibilityAnalyzer
        with patch.object(FeasibilityAnalyzer, 'full_analysis') as mock_analysis:
            mock_report = MagicMock()
            mock_report.verdict = ExploitabilityVerdict.DIFFICULT
            mock_report.blockers = ['Full RELRO']
            mock_report.warnings = []
            mock_analysis.return_value = mock_report

            is_viable, reason = check_exploit_viability(vuln_type="format_string")
            assert is_viable is True
            assert 'difficult' in reason.lower()


class TestGetExploitConstraints:
    """Tests for get_exploit_constraints function."""

    def test_returns_dict(self):
        """Test that get_exploit_constraints returns a dictionary."""
        constraints = get_exploit_constraints(arch="x86_64")
        assert isinstance(constraints, dict)
        assert 'arch' in constraints
        assert 'null_byte_position' in constraints

    def test_x86_64_arch(self):
        """Test x86_64 architecture constraints."""
        constraints = get_exploit_constraints(arch="x86_64")
        assert constraints['arch'] == 'x86_64'
        assert constraints['null_byte_position'] == 6
        assert constraints['max_strcpy_bytes'] == 6

    def test_i386_arch(self):
        """Test i386 architecture constraints."""
        constraints = get_exploit_constraints(arch="i386")
        assert constraints['arch'] == 'i386'
        # i386 can have null-free addresses
        assert constraints['strcpy_rop_viable'] is True

    def test_with_input_handler(self):
        """Test constraints with input handler specified."""
        constraints = get_exploit_constraints(arch="x86_64", input_handler="strcpy")
        # strcpy on x86_64 should block ROP
        assert constraints['strcpy_rop_viable'] is False
        assert len(constraints['blocked_techniques']) > 0

    def test_viable_techniques_present(self):
        """Test that viable techniques are returned."""
        constraints = get_exploit_constraints(arch="x86_64", input_handler="strcpy")
        # Should still have some viable techniques
        assert 'viable_techniques' in constraints
        assert isinstance(constraints['viable_techniques'], list)


class TestListPrimitives:
    """Tests for list_primitives function."""

    def test_returns_dict(self):
        """Test that list_primitives returns a dictionary."""
        result = list_primitives()
        assert isinstance(result, dict)

    def test_contains_primitives(self):
        """Test that result contains primitive definitions."""
        result = list_primitives()
        # Should have vulnerabilities, capabilities, and goals
        assert 'vulnerabilities' in result
        assert 'capabilities' in result
        assert 'goals' in result
        # Should have some content
        total = len(result['vulnerabilities']) + len(result['capabilities']) + len(result['goals'])
        assert total > 0

    def test_filter_by_type_vulnerability(self):
        """Test filtering by vulnerability type."""
        result = list_primitives(primitive_type="vulnerability")
        assert 'vulnerabilities' in result
        assert isinstance(result['vulnerabilities'], list)

    def test_filter_by_type_capability(self):
        """Test filtering by capability type."""
        result = list_primitives(primitive_type="capability")
        assert 'capabilities' in result
        assert isinstance(result['capabilities'], list)


class TestGetPrimitiveRequirements:
    """Tests for get_primitive_requirements function."""

    def test_returns_dict(self):
        """Test that get_primitive_requirements returns a dictionary."""
        result = get_primitive_requirements("libc_leak")
        assert isinstance(result, dict)
        # Should have primitive info or error
        assert 'name' in result or 'error' in result

    def test_format_string_write(self):
        """Test requirements for format_string_write."""
        result = get_primitive_requirements("format_string_write")
        assert isinstance(result, dict)
        if 'name' in result:
            assert result['name'] == 'format_string_write'
            assert 'requires' in result
            assert 'blocked_by' in result

    def test_code_execution(self):
        """Test requirements for code_execution goal."""
        result = get_primitive_requirements("code_execution")
        assert isinstance(result, dict)
        if 'name' in result:
            assert result['name'] == 'code_execution'

    def test_nonexistent_primitive(self):
        """Test handling of non-existent primitive."""
        result = get_primitive_requirements("nonexistent_primitive_xyz")
        # Should return error info with available primitives
        assert isinstance(result, dict)
        assert 'error' in result
        assert 'available' in result


class TestFindExploitPathsCaching:
    """Tests for the optimization that caches binary_protections."""

    def test_no_analyzer_when_protections_provided(self):
        """Test that FeasibilityAnalyzer is not instantiated when protections are cached."""
        from ..analyzer import FeasibilityAnalyzer
        with patch.object(FeasibilityAnalyzer, '__init__', return_value=None) as mock_init:
            # Provide cached protections - analyzer should NOT be created
            result = find_exploit_paths(
                "format_string_vuln",
                binary_protections={'full_relro': True, 'pie': True},
                glibc_version='2.35'
            )
            # FeasibilityAnalyzer should not be instantiated
            mock_init.assert_not_called()

    def test_paths_returned_with_cached_protections(self):
        """Test that paths are returned when using cached protections."""
        result = find_exploit_paths(
            "format_string_vuln",
            binary_protections={'full_relro': False, 'pie': True, 'nx': True},
            glibc_version='2.30'
        )
        assert isinstance(result, dict)

    def test_analysis_without_binary_path(self):
        """Test that analysis handles no binary_path gracefully."""
        # Without protections AND without binary_path, should not crash
        result = find_exploit_paths("format_string_vuln")
        assert isinstance(result, dict)


class TestAutoProfileSelection:
    """Tests for automatic profile selection based on vulnerability type."""

    def test_auto_selects_web_profile_for_sql_injection(self):
        """SQL injection should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('sql_injection')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_web_profile_for_sqli_alias(self):
        """'sqli' alias should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('sqli')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_web_profile_for_xss(self):
        """XSS should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('xss')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_web_profile_for_ssrf(self):
        """SSRF should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('ssrf')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_web_profile_for_path_traversal(self):
        """Path traversal should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('path_traversal')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_web_profile_for_lfi(self):
        """LFI (alias) should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('lfi')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_web_profile_for_command_injection(self):
        """Command injection should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('command_injection')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_web_profile_for_ssti(self):
        """SSTI should use WebApplicationStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('ssti')
        assert profile.context == TargetContext.WEB_APPLICATION

    def test_auto_selects_local_profile_for_format_string(self):
        """Format string (memory corruption) should use LocalBinaryStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('format_string_write')
        assert profile.context == TargetContext.LOCAL_BINARY

    def test_auto_selects_local_profile_for_buffer_overflow(self):
        """Buffer overflow should use LocalBinaryStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('stack_buffer_overflow')
        assert profile.context == TargetContext.LOCAL_BINARY

    def test_auto_selects_local_profile_for_heap_overflow(self):
        """Heap overflow should use LocalBinaryStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type('heap_buffer_overflow')
        assert profile.context == TargetContext.LOCAL_BINARY

    def test_auto_selects_local_profile_when_no_vuln_type(self):
        """No vuln_type should default to LocalBinaryStrategy."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile = _get_profile_for_vuln_type(None)
        assert profile.context == TargetContext.LOCAL_BINARY

    def test_case_insensitive_vuln_type(self):
        """Vuln type matching should be case-insensitive."""
        from ..api import _get_profile_for_vuln_type
        from ..profiles import TargetContext

        profile1 = _get_profile_for_vuln_type('SQL_INJECTION')
        profile2 = _get_profile_for_vuln_type('Sql_Injection')
        profile3 = _get_profile_for_vuln_type('sql_injection')

        assert profile1.context == TargetContext.WEB_APPLICATION
        assert profile2.context == TargetContext.WEB_APPLICATION
        assert profile3.context == TargetContext.WEB_APPLICATION

    def test_check_exploit_viability_uses_web_profile(self):
        """check_exploit_viability should auto-use web profile for web vulns."""
        # SQL injection should return True (viable) because memory mitigations don't apply
        viable, reason = check_exploit_viability(vuln_type='sql_injection')
        assert viable is True
        # Reason should indicate it's a web context or manual analysis
        assert 'unknown' in reason.lower() or 'manual' in reason.lower()
