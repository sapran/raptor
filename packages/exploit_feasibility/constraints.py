#!/usr/bin/env python3
"""
Exploitation Constraints Analysis.

This module provides detailed analysis of what blocks vs enables exploitation,
giving actionable guidance rather than just listing blockers.

The key insight is that constraints don't always completely block a technique -
they may just require a different approach (e.g., partial overwrite instead
of full address write).

Public API:
    from packages.exploit_feasibility.constraints import (
        analyze_input_constraints,
        analyze_bad_byte_impact,
        assess_libc_fingerprinting,
    )
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Any


# =============================================================================
# Input Handler Constraint Analysis
# =============================================================================

@dataclass
class InputConstraintAnalysis:
    """
    Detailed analysis of how an input handler affects exploitation.

    Rather than just saying "strcpy blocks ROP", this explains:
    - WHY it's blocked (null byte at position X)
    - What IS still viable
    - Specific workarounds to consider
    """
    handler: str
    arch: str = "x86_64"

    # Core constraint
    null_byte_position: int = 6  # Position in 8-byte address where null appears
    max_contiguous_bytes: int = 6  # Max bytes writable before null termination

    # Categorized techniques
    blocked: List[str] = field(default_factory=list)
    viable: List[str] = field(default_factory=list)
    conditional: List[str] = field(default_factory=list)  # Viable under certain conditions

    # Specific notes for exploit developer
    notes: List[str] = field(default_factory=list)

    # Additional bad bytes beyond null
    additional_bad_bytes: List[int] = field(default_factory=list)

    def summary(self) -> str:
        """Generate human-readable summary."""
        lines = [f"Input constraints ({self.handler}):"]
        lines.append(f"  Null byte position: {self.null_byte_position} (in {self.arch} addresses)")
        lines.append(f"  Max writable bytes: {self.max_contiguous_bytes}")

        if self.blocked:
            lines.append("")
            lines.append("  Blocked:")
            for b in self.blocked:
                lines.append(f"    - {b}")

        if self.viable:
            lines.append("")
            lines.append("  Still viable:")
            for v in self.viable:
                lines.append(f"    + {v}")

        if self.conditional:
            lines.append("")
            lines.append("  Conditionally viable:")
            for c in self.conditional:
                lines.append(f"    ~ {c}")

        if self.notes:
            lines.append("")
            lines.append("  Notes:")
            for n in self.notes:
                lines.append(f"    * {n}")

        return "\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'handler': self.handler,
            'arch': self.arch,
            'null_byte_position': self.null_byte_position,
            'max_contiguous_bytes': self.max_contiguous_bytes,
            'blocked': self.blocked,
            'viable': self.viable,
            'conditional': self.conditional,
            'notes': self.notes,
            'additional_bad_bytes': self.additional_bad_bytes,
        }


def analyze_input_constraints(
    handler: str,
    arch: str = "x86_64",
    has_pie: bool = True,
    has_full_relro: bool = True,
    format_n_works: bool = False,
) -> InputConstraintAnalysis:
    """
    Analyze how an input handler constrains exploitation techniques.

    This provides actionable guidance by categorizing techniques as:
    - Blocked: fundamentally won't work with this handler
    - Viable: should work despite the handler
    - Conditional: may work depending on specific circumstances

    Args:
        handler: Input function name (strcpy, fgets, read, etc.)
        arch: Target architecture (x86_64, i386, etc.)
        has_pie: Whether binary has PIE enabled
        has_full_relro: Whether binary has Full RELRO
        format_n_works: Whether %n format specifier works

    Returns:
        InputConstraintAnalysis with categorized techniques

    Example:
        >>> analysis = analyze_input_constraints("strcpy", "x86_64")
        >>> print(analysis.summary())
        Input constraints (strcpy):
          Null byte position: 6 (in x86_64 addresses)
          ...
    """
    handler_lower = handler.lower()
    analysis = InputConstraintAnalysis(handler=handler, arch=arch)

    # Set architecture-specific constraints
    if arch == "x86_64":
        analysis.null_byte_position = 6
        analysis.max_contiguous_bytes = 6
    elif arch in ("i386", "arm", "arm32"):
        analysis.null_byte_position = 4  # 32-bit may not have null issue
        analysis.max_contiguous_bytes = 4
    elif arch in ("aarch64", "arm64"):
        analysis.null_byte_position = 6
        analysis.max_contiguous_bytes = 6

    # Null-terminating handlers (strcpy family)
    if handler_lower in ('strcpy', 'strcat', 'sprintf', 'gets', 'vsprintf'):
        analysis.additional_bad_bytes = [0x00]

        if arch == "x86_64":
            # BLOCKED: Techniques requiring multiple full addresses
            analysis.blocked = [
                "Multi-gadget ROP chain (each address truncated at null)",
                "ret2libc chain: pop rdi + /bin/sh + system (3 addresses needed)",
                "Stack pivot to controlled buffer (pivot address has null)",
                "Full address overwrites via strcpy",
            ]

            # VIABLE: Techniques that work despite null constraint
            analysis.viable = [
                "Partial overwrite (2 bytes) - change low bytes of existing pointer",
                "Single one_gadget (if constraints satisfied)",
                "Format string writes (if printf vuln exists and %n works)",
                "Return to PLT (addresses may be null-free in small PIE binaries)",
            ]

            # CONDITIONAL: Depends on specific binary/circumstances
            analysis.conditional = [
                "ret2csu - if binary has __libc_csu_init with usable gadgets",
                "Stack addresses - offset from known value may be null-free",
                "Heap addresses - low entropy may allow null-free addresses",
            ]

            analysis.notes = [
                f"x86_64 userland addresses are 0x00007FFF... with null at byte {analysis.null_byte_position}",
                "strcpy stops at first null, so only 6 bytes of each address are written",
                "Consider leaking stack/heap addresses which may have more controllable low bytes",
            ]

        elif arch in ("i386", "arm", "arm32"):
            # 32-bit is more forgiving
            analysis.blocked = [
                "Addresses containing 0x00 byte (check specific addresses)",
            ]
            analysis.viable = [
                "ROP chains (32-bit addresses often null-free)",
                "ret2libc (if addresses don't contain null)",
                "Full address overwrites (if target addresses null-free)",
            ]
            analysis.notes = [
                "32-bit addresses CAN be null-free depending on ASLR",
                "Check specific gadget/target addresses for null bytes",
            ]

    # Line-terminating handlers (fgets family)
    elif handler_lower in ('fgets', 'getline'):
        analysis.additional_bad_bytes = [0x00, 0x0a]  # null and newline

        analysis.blocked = [
            "Payloads containing newline (0x0a) - terminates input",
        ]
        analysis.viable = [
            "ROP chains (if gadget addresses don't contain 0x0a)",
            "Most exploitation techniques (newline is less constraining than null)",
        ]
        analysis.notes = [
            "Newline (0x0a) terminates fgets, but most addresses don't contain it",
            "Check gadget addresses for 0x0a byte before using",
        ]

    # Whitespace-terminating handlers (scanf %s)
    elif handler_lower in ('scanf', 'fscanf', 'sscanf'):
        whitespace = [0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20]
        analysis.additional_bad_bytes = [0x00] + whitespace

        analysis.blocked = [
            "Addresses containing whitespace bytes (0x09-0x0d, 0x20)",
        ]
        analysis.viable = [
            "ROP chains (if addresses avoid whitespace - most do)",
            "Most techniques (whitespace in addresses is uncommon)",
        ]
        analysis.notes = [
            "scanf %s stops at any whitespace character",
            "Most code addresses don't contain whitespace bytes",
        ]

    # Binary-safe handlers (read, recv)
    elif handler_lower in ('read', 'fread', 'recv', 'recvfrom', 'memcpy', 'memmove'):
        # No byte restrictions
        analysis.viable = [
            "All ROP techniques",
            "All address overwrites",
            "Shellcode (if NX disabled)",
            "No byte restrictions from input handler",
        ]
        analysis.notes = [
            f"{handler} is binary-safe - no bad byte constraints from input",
            "Check other constraints (NX, RELRO, ASLR) separately",
        ]

    # Add RELRO-related constraints
    if has_full_relro:
        if "GOT overwrite" not in analysis.blocked:
            analysis.blocked.append("GOT overwrite (Full RELRO)")
        if ".fini_array overwrite" not in analysis.blocked:
            analysis.blocked.append(".fini_array overwrite (Full RELRO)")

    # Add format string option if available
    if format_n_works and "Format string writes" not in analysis.viable:
        analysis.viable.append("Format string %n writes (bypasses null byte limitations)")

    return analysis


# =============================================================================
# Bad Byte Impact Analysis
# =============================================================================

@dataclass
class BadByteImpact:
    """
    Analysis of how bad bytes affect a specific target address.

    Goes beyond "has bad bytes" to explain whether the target is
    still usable via alternative approaches.
    """
    target_name: str
    address: int
    bad_bytes_found: List[Tuple[int, int]]  # (position, byte_value)

    # Impact assessment
    fatal: bool = False  # Completely unusable
    usable_via_partial: bool = False  # Can use partial overwrite
    partial_bytes_needed: int = 0  # How many bytes for partial overwrite

    # Specific guidance
    reason: str = ""
    workaround: str = ""

    def summary(self) -> str:
        """Generate human-readable summary."""
        addr_str = f"0x{self.address:x}"
        if not self.bad_bytes_found:
            return f"{self.target_name} @ {addr_str}: No bad bytes - fully usable"

        positions = [f"byte {pos}=0x{val:02x}" for pos, val in self.bad_bytes_found]
        status = "FATAL" if self.fatal else "WORKABLE"

        lines = [f"{self.target_name} @ {addr_str}: {status}"]
        lines.append(f"  Bad bytes at: {', '.join(positions)}")

        if self.fatal:
            lines.append(f"  Reason: {self.reason}")
        elif self.usable_via_partial:
            lines.append(f"  Workaround: {self.workaround}")
            lines.append(f"  Partial overwrite needs: {self.partial_bytes_needed} bytes")

        return "\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'target_name': self.target_name,
            'address': self.address,
            'address_hex': f"0x{self.address:x}",
            'bad_bytes_found': [{'position': p, 'value': v} for p, v in self.bad_bytes_found],
            'fatal': self.fatal,
            'usable_via_partial': self.usable_via_partial,
            'partial_bytes_needed': self.partial_bytes_needed,
            'reason': self.reason,
            'workaround': self.workaround,
        }


def analyze_bad_byte_impact(
    target_name: str,
    address: int,
    bad_bytes: List[int],
    technique: str = "full_write",
    pointer_size: int = 8,
) -> BadByteImpact:
    """
    Analyze how bad bytes in an address affect its usability.

    This determines whether bad bytes are fatal or can be worked around,
    providing specific guidance for each case.

    Args:
        target_name: Human-readable name of target (e.g., "GOT[puts]")
        address: Target address to analyze
        bad_bytes: List of bytes that cannot appear in payload
        technique: Intended technique (full_write, partial_overwrite, format_string)
        pointer_size: Size of pointer in bytes (8 for x86_64, 4 for i386)

    Returns:
        BadByteImpact with usability assessment

    Example:
        >>> impact = analyze_bad_byte_impact("GOT[puts]", 0x404018, [0x00])
        >>> print(impact.summary())
        GOT[puts] @ 0x404018: WORKABLE
          Bad bytes at: byte 3=0x00
          Workaround: Use partial overwrite (2 bytes) to modify low bytes only
    """
    # Find bad bytes in address
    addr_bytes = address.to_bytes(pointer_size, 'little')
    found_bad = []
    for pos, byte_val in enumerate(addr_bytes):
        if byte_val in bad_bytes:
            found_bad.append((pos, byte_val))

    impact = BadByteImpact(
        target_name=target_name,
        address=address,
        bad_bytes_found=found_bad,
    )

    if not found_bad:
        # No bad bytes - fully usable
        impact.workaround = "No restrictions - full address can be written"
        return impact

    # Determine impact based on technique and bad byte positions
    lowest_bad_pos = min(pos for pos, _ in found_bad)

    if technique == "partial_overwrite":
        # Partial overwrite only needs low bytes
        if lowest_bad_pos >= 2:
            impact.usable_via_partial = True
            impact.partial_bytes_needed = lowest_bad_pos
            impact.workaround = f"Partial overwrite ({lowest_bad_pos} bytes) avoids bad bytes"
        else:
            impact.fatal = True
            impact.reason = f"Bad byte at position {lowest_bad_pos} blocks even 2-byte partial overwrite"

    elif technique == "format_string":
        # Format string can write byte-by-byte, avoiding bad bytes in ADDRESS
        # But the VALUE being written still matters
        if lowest_bad_pos >= 2:
            impact.usable_via_partial = True
            impact.partial_bytes_needed = 2
            impact.workaround = "Format string %hn can write 2 bytes at a time, avoiding null in address"
        else:
            # Address itself has bad bytes in low positions
            impact.fatal = True
            impact.reason = f"Target address has bad byte at position {lowest_bad_pos}, cannot be used with null-terminated format string"

    else:  # full_write
        # Full write needs entire address
        if lowest_bad_pos >= 6 and pointer_size == 8:
            # Bad bytes only in high positions (common for x86_64)
            # Can still work if using partial overwrite instead
            impact.usable_via_partial = True
            impact.partial_bytes_needed = lowest_bad_pos
            impact.workaround = f"Use partial overwrite ({lowest_bad_pos} bytes) instead of full address"
        elif lowest_bad_pos >= 2:
            # Some room for partial overwrite
            impact.usable_via_partial = True
            impact.partial_bytes_needed = lowest_bad_pos
            impact.workaround = f"Partial overwrite possible ({lowest_bad_pos} bytes), but limited"
        else:
            impact.fatal = True
            impact.reason = f"Bad byte at position {lowest_bad_pos} blocks all write approaches"

    return impact


# =============================================================================
# Libc Fingerprinting Potential
# =============================================================================

@dataclass
class LibcFingerprintingPotential:
    """
    Assessment of whether libc can be identified from leaked addresses.

    This helps determine if pursuing a libc leak is worthwhile before
    actually doing the exploit development work.
    """
    # Symbols available for fingerprinting
    unique_symbols: List[str] = field(default_factory=list)
    symbol_count: int = 0

    # Feasibility assessment
    feasibility: str = ""  # "good", "limited", "poor"
    confidence: str = ""  # "high", "medium", "low"

    # Guidance
    notes: List[str] = field(default_factory=list)

    def summary(self) -> str:
        """Generate human-readable summary."""
        lines = ["Libc fingerprinting potential:"]
        lines.append(f"  Unique callable symbols: {self.symbol_count}")
        if self.unique_symbols:
            shown = self.unique_symbols[:8]
            if len(self.unique_symbols) > 8:
                shown_str = ", ".join(shown) + f"... (+{len(self.unique_symbols) - 8} more)"
            else:
                shown_str = ", ".join(shown)
            lines.append(f"  Symbols: {shown_str}")

        lines.append(f"  Feasibility: {self.feasibility.title()}")
        lines.append(f"  Confidence: {self.confidence}")

        if self.notes:
            for note in self.notes:
                lines.append(f"  Note: {note}")

        return "\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'unique_symbols': self.unique_symbols,
            'symbol_count': self.symbol_count,
            'feasibility': self.feasibility,
            'confidence': self.confidence,
            'notes': self.notes,
        }


# Common libc symbols that are good for fingerprinting
# These have varying offsets across libc versions
GOOD_FINGERPRINT_SYMBOLS = {
    'puts', 'printf', 'read', 'write', 'malloc', 'free', 'exit',
    'open', 'close', 'mmap', 'mprotect', 'execve', 'system',
    'getenv', 'setenv', 'atoi', 'atol', 'strlen', 'strcpy',
    'memcpy', 'memset', 'fopen', 'fclose', 'fread', 'fwrite',
    'socket', 'connect', 'bind', 'listen', 'accept',
}


def assess_libc_fingerprinting(
    plt_symbols: List[str],
    got_symbols: Optional[List[str]] = None,
) -> LibcFingerprintingPotential:
    """
    Assess whether libc can be reliably identified from available symbols.

    This helps determine if a libc leak is worth pursuing. With too few
    unique symbols, the leak may match multiple libc versions.

    Args:
        plt_symbols: Symbols in the PLT (callable from binary)
        got_symbols: Symbols in the GOT (if different from PLT)

    Returns:
        LibcFingerprintingPotential assessment

    Example:
        >>> potential = assess_libc_fingerprinting(['puts', 'printf', 'malloc'])
        >>> print(potential.summary())
        Libc fingerprinting potential:
          Unique callable symbols: 3
          Feasibility: Limited
    """
    # Combine and deduplicate symbols
    all_symbols = set(plt_symbols)
    if got_symbols:
        all_symbols.update(got_symbols)

    # Filter to symbols good for fingerprinting
    useful_symbols = [s for s in all_symbols if s in GOOD_FINGERPRINT_SYMBOLS]

    result = LibcFingerprintingPotential(
        unique_symbols=sorted(useful_symbols),
        symbol_count=len(useful_symbols),
    )

    # Assess feasibility based on symbol count
    if len(useful_symbols) >= 5:
        result.feasibility = "good"
        result.confidence = "high"
        result.notes.append("5+ symbols typically sufficient for unique identification")
    elif len(useful_symbols) >= 3:
        result.feasibility = "limited"
        result.confidence = "medium"
        result.notes.append("May match multiple libc versions, but usually narrowable")
    elif len(useful_symbols) >= 1:
        result.feasibility = "poor"
        result.confidence = "low"
        result.notes.append("Few symbols available - leak may match many libc versions")
    else:
        result.feasibility = "none"
        result.confidence = "none"
        result.notes.append("No useful symbols for fingerprinting - libc identification not possible via leak")

    # Add guidance based on specific symbols
    if 'puts' in useful_symbols or 'printf' in useful_symbols:
        result.notes.append("puts/printf available - good candidates for leak primitive")
    if 'system' in useful_symbols:
        result.notes.append("system in PLT - may not need full libc base if ret2plt viable")

    return result
