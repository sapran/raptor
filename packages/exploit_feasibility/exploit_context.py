#!/usr/bin/env python3
"""
ExploitContext - Flexible exploitation context data storage.

Provides schema-flexible storage for binary analysis data that can be:
- Collected incrementally during mitigation analysis
- Serialized to JSON for caching
- Queried by exploit development workflows
- Source-tracked to prevent redundant commands

This replaces ad-hoc data collection during exploit development. All data
collected during mitigation analysis is available here - DO NOT re-run
commands like `nm`, `checksec`, `ROPgadget`, etc.

Usage:
    # Collection phase (in analyzer)
    ctx = ExploitContext()
    ctx.set('libc.version', '2.42', source='libc.so.6 --version')
    ctx.set('libc.system_offset', 0x5c4c0, source='nm -D libc.so.6')
    ctx.set('binary.protections.full_relro', True, source='readelf -d')

    # Save for later use
    ctx.save('/path/to/context.json')

    # Exploit dev phase - load and query
    ctx = ExploitContext.load('/path/to/context.json')
    if ctx.get('libc.version_float') >= 2.34:
        print("Hooks won't work")
    system = ctx.get('libc.system_offset')
"""

import json
from pathlib import Path
from typing import Any, Optional, List, Dict
from datetime import datetime

try:
    from ..logging import get_logger
    logger = get_logger(__name__)
except ImportError:
    import logging
    logger = logging.getLogger(__name__)


class ExploitContext:
    """
    Flexible exploitation context store with dot-notation access.

    Data is stored with optional source tracking to:
    - Document where each piece of data came from
    - Prevent redundant command execution
    - Enable debugging of incorrect values
    """

    def __init__(self, binary_path: str = None):
        self._data: Dict[str, Any] = {}
        self._metadata = {
            'binary_path': binary_path,
            'created': datetime.now().isoformat(),
            'version': '1.0',
        }

    # =========================================================================
    # Core Access Methods
    # =========================================================================

    def set(self, key: str, value: Any, source: str = None, notes: str = None):
        """
        Store recon data with optional source tracking.

        Args:
            key: Dot-separated path like 'libc.system_offset' or 'binary.protections.full_relro'
            value: The data to store (any JSON-serializable type)
            source: Command/tool that produced this data (e.g., 'nm -D libc.so.6')
            notes: Additional context about the value

        Example:
            recon.set('libc.system_offset', 0x5c4c0, source='nm -D libc.so.6')
            recon.set('binary.protections.full_relro', True, source='readelf -d')
        """
        parts = key.split('.')
        d = self._data

        # Navigate/create nested structure
        for p in parts[:-1]:
            if p not in d:
                d[p] = {}
            elif not isinstance(d[p], dict):
                # Convert leaf to dict if needed
                d[p] = {'_value': d[p]}
            d = d[p]

        # Store value with metadata
        entry = {'value': value}
        if source:
            entry['source'] = source
        if notes:
            entry['notes'] = notes
        entry['timestamp'] = datetime.now().isoformat()

        d[parts[-1]] = entry

    def get(self, key: str, default: Any = None) -> Any:
        """
        Retrieve value by dot-path.

        Args:
            key: Dot-separated path like 'libc.system_offset'
            default: Value to return if key not found

        Returns:
            The stored value (unwrapped from metadata)

        Example:
            offset = recon.get('libc.system_offset')
            version = recon.get('libc.version', default='unknown')
        """
        parts = key.split('.')
        d = self._data

        try:
            for p in parts:
                d = d[p]

            # Unwrap value from metadata dict
            if isinstance(d, dict) and 'value' in d:
                return d['value']
            return d
        except (KeyError, TypeError):
            return default

    def has(self, key: str) -> bool:
        """Check if a key exists in the store."""
        return self.get(key) is not None

    def get_source(self, key: str) -> Optional[str]:
        """Get the source command that produced a value."""
        parts = key.split('.')
        d = self._data

        try:
            for p in parts:
                d = d[p]
            if isinstance(d, dict):
                return d.get('source')
        except (KeyError, TypeError):
            pass
        return None

    def get_with_meta(self, key: str) -> Optional[Dict]:
        """Get value with full metadata (source, timestamp, notes)."""
        parts = key.split('.')
        d = self._data

        try:
            for p in parts:
                d = d[p]
            if isinstance(d, dict) and 'value' in d:
                return d
        except (KeyError, TypeError):
            pass
        return None

    # =========================================================================
    # Batch Operations
    # =========================================================================

    def set_many(self, data: Dict[str, Any], source: str = None):
        """
        Set multiple values at once.

        Args:
            data: Dict of key -> value pairs (keys can be dot-paths)
            source: Common source for all values

        Example:
            recon.set_many({
                'libc.system_offset': 0x5c4c0,
                'libc.bin_sh_offset': 0x1dc4c3,
            }, source='nm -D libc.so.6')
        """
        for key, value in data.items():
            self.set(key, value, source=source)

    def get_section(self, prefix: str) -> Dict[str, Any]:
        """
        Get all values under a prefix as a flat dict.

        Args:
            prefix: Key prefix like 'libc' or 'binary.protections'

        Returns:
            Dict of relative_key -> value

        Example:
            libc_data = recon.get_section('libc')
            # {'version': '2.42', 'system_offset': 0x5c4c0, ...}
        """
        parts = prefix.split('.')
        d = self._data

        try:
            for p in parts:
                d = d[p]
        except (KeyError, TypeError):
            return {}

        result = {}
        self._flatten(d, '', result)
        return result

    def _flatten(self, d: Dict, prefix: str, result: Dict):
        """Recursively flatten nested dict, extracting values."""
        if not isinstance(d, dict):
            return

        for k, v in d.items():
            key = f"{prefix}.{k}" if prefix else k
            if isinstance(v, dict):
                if 'value' in v:
                    result[key] = v['value']
                else:
                    self._flatten(v, key, result)
            else:
                result[key] = v

    def keys(self, prefix: str = None) -> List[str]:
        """
        List all keys, optionally filtered by prefix.

        Example:
            all_keys = recon.keys()
            libc_keys = recon.keys('libc')
        """
        result = []
        self._collect_keys(self._data, '', result)

        if prefix:
            result = [k for k in result if k.startswith(prefix)]

        return sorted(result)

    def _collect_keys(self, d: Dict, prefix: str, result: List[str]):
        """Recursively collect all leaf keys."""
        if not isinstance(d, dict):
            return

        for k, v in d.items():
            key = f"{prefix}.{k}" if prefix else k
            if isinstance(v, dict):
                if 'value' in v:
                    result.append(key)
                else:
                    self._collect_keys(v, key, result)

    # =========================================================================
    # Convenience Accessors (common patterns)
    # =========================================================================

    @property
    def binary_path(self) -> Optional[str]:
        return self._metadata.get('binary_path')

    @property
    def libc(self) -> 'ContextSection':
        """Access libc data with attribute syntax."""
        return ContextSection(self, 'libc')

    @property
    def binary(self) -> 'ContextSection':
        """Access binary data with attribute syntax."""
        return ContextSection(self, 'binary')

    @property
    def rop(self) -> 'ContextSection':
        """Access ROP gadget data with attribute syntax."""
        return ContextSection(self, 'rop')

    @property
    def kernel(self) -> 'ContextSection':
        """Access kernel mitigation data."""
        return ContextSection(self, 'kernel')

    # =========================================================================
    # Serialization
    # =========================================================================

    def to_dict(self) -> Dict:
        """Convert store to dictionary for serialization."""
        return {
            'metadata': self._metadata,
            'data': self._data,
        }

    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)

    def save(self, path: str):
        """Save store to JSON file."""
        path = Path(path)
        path.parent.mkdir(parents=True, exist_ok=True)

        with open(path, 'w') as f:
            f.write(self.to_json())

        logger.info(f"ExploitContext saved to {path}")

    @classmethod
    def from_dict(cls, data: Dict) -> 'ExploitContext':
        """Create store from dictionary."""
        store = cls()
        store._metadata = data.get('metadata', {})
        store._data = data.get('data', {})
        return store

    @classmethod
    def from_json(cls, json_str: str) -> 'ExploitContext':
        """Create store from JSON string."""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def load(cls, path: str) -> 'ExploitContext':
        """Load store from JSON file."""
        with open(path, 'r') as f:
            data = json.load(f)

        store = cls.from_dict(data)
        logger.info(f"ExploitContext loaded from {path}")
        return store

    # =========================================================================
    # Utility Methods
    # =========================================================================

    def summary(self) -> str:
        """Generate human-readable summary of stored data."""
        lines = [
            "=" * 60,
            "EXPLOITATION CONTEXT",
            "=" * 60,
        ]

        if self.binary_path:
            lines.append(f"Binary: {self.binary_path}")

        # Group by top-level section
        sections = {}
        for key in self.keys():
            section = key.split('.')[0]
            if section not in sections:
                sections[section] = []
            sections[section].append(key)

        for section, keys in sorted(sections.items()):
            lines.append(f"\n### {section.upper()} ###")
            for key in sorted(keys):
                value = self.get(key)
                source = self.get_source(key)

                # Format value
                if isinstance(value, int) and value > 255:
                    val_str = f"0x{value:x}"
                elif isinstance(value, bool):
                    val_str = "yes" if value else "no"
                elif isinstance(value, list):
                    val_str = f"[{len(value)} items]"
                else:
                    val_str = str(value)[:50]

                # Relative key (without section prefix)
                rel_key = key[len(section)+1:] if key.startswith(section + '.') else key

                line = f"  {rel_key}: {val_str}"
                if source:
                    line += f"  (from: {source})"
                lines.append(line)

        lines.append("=" * 60)
        return "\n".join(lines)

    def __repr__(self):
        return f"ExploitContext(keys={len(self.keys())}, binary={self.binary_path})"


class ContextSection:
    """
    Helper for attribute-style access to a section of ExploitContext.

    Allows: recon.libc.system_offset instead of recon.get('libc.system_offset')
    """

    def __init__(self, store: ExploitContext, prefix: str):
        self._store = store
        self._prefix = prefix

    def __getattr__(self, name: str) -> Any:
        if name.startswith('_'):
            raise AttributeError(name)

        key = f"{self._prefix}.{name}"
        value = self._store.get(key)

        # If value is None, check if it's a subsection
        if value is None:
            subsection_keys = self._store.keys(key)
            if subsection_keys:
                return ContextSection(self._store, key)

        return value

    def __setattr__(self, name: str, value: Any):
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            key = f"{self._prefix}.{name}"
            self._store.set(key, value)

    def get(self, name: str, default: Any = None) -> Any:
        """Get with default value support."""
        key = f"{self._prefix}.{name}"
        return self._store.get(key, default)

    def all(self) -> Dict[str, Any]:
        """Get all values in this section."""
        return self._store.get_section(self._prefix)

    def __repr__(self):
        return f"ContextSection({self._prefix})"


# =============================================================================
# Standard Key Definitions (for documentation/IDE support)
# =============================================================================

STANDARD_KEYS = """
Standard ExploitContext keys used by raptor:

libc.path               - Path to libc.so
libc.version            - Full version string
libc.version_float      - Numeric version (e.g., 2.42)
libc.system_offset      - system() offset from base
libc.execve_offset      - execve() offset
libc.bin_sh_offset      - "/bin/sh" string offset
libc.environ_offset     - environ pointer offset
libc.malloc_hook_offset - __malloc_hook offset (deprecated in 2.34+)
libc.free_hook_offset   - __free_hook offset (deprecated in 2.34+)
libc.one_gadgets        - List of one_gadget offsets

binary.path             - Path to target binary
binary.arch             - Architecture (x86_64, i386, arm, etc.)
binary.protections.relro        - RELRO enabled
binary.protections.full_relro   - Full RELRO (GOT read-only)
binary.protections.pie          - Position Independent Executable
binary.protections.nx           - Non-executable stack
binary.protections.canary       - Stack canary present
binary.protections.fortify      - FORTIFY_SOURCE enabled

binary.sections.got_plt_addr    - .got.plt address
binary.sections.fini_array_addr - .fini_array address
binary.sections.bss_addr        - .bss address

binary.input_handlers   - List of input functions (strcpy, fgets, etc.)

rop.total_gadgets       - Total gadgets found
rop.usable_gadgets      - Gadgets without bad bytes
rop.filtered_count      - Gadgets filtered by bad bytes
rop.pop_rdi_ret         - pop rdi; ret gadget offset
rop.pop_rsi_ret         - pop rsi; ret gadget offset
rop.pop_rdx_ret         - pop rdx; ret gadget offset
rop.pop_rax_ret         - pop rax; ret gadget offset
rop.ret                 - ret gadget offset (stack alignment)
rop.leave_ret           - leave; ret gadget offset
rop.syscall_ret         - syscall; ret gadget offset

kernel.aslr_level       - ASLR level (0, 1, or 2)
kernel.version          - Kernel version string

payload.bad_bytes       - List of bytes that can't appear in payload
payload.max_length      - Maximum payload length
payload.input_handler   - Primary input function

address_space.binary_base   - Sampled binary base address
address_space.libc_base     - Sampled libc base address
address_space.stack_base    - Sampled stack address

write_targets           - List of {name, address, has_bad_bytes, notes}
"""
