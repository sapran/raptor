#!/usr/bin/env python3
"""
Exploit Validator - Autonomous Exploit Testing and Refinement

This module enables RAPTOR to:
- Compile generated exploits
- Test them safely
- Identify errors
- Iteratively refine with LLM
"""

import re
import subprocess
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple

from core.logging import get_logger

logger = get_logger()


@dataclass
class ValidationResult:
    """Result of exploit validation."""
    success: bool
    compilation_errors: List[str]
    runtime_errors: List[str]
    warnings: List[str]
    exploit_path: Optional[Path] = None


class ExploitValidator:
    """
    Validates and refines generated exploits.

    Instead of accepting the first exploit the LLM generates, this:
    0. Check mitigations first (avoid wasted effort)
    1. Attempts to compile it
    2. Identifies compilation errors
    3. Uses MultiTurnAnalyser to fix errors
    4. Iteratively refines until it compiles
    5. Optionally tests execution (in safe environment)
    """

    def __init__(self, work_dir: Path):
        """
        Initialise exploit validator.

        Args:
            work_dir: Working directory for temporary files
        """
        self.work_dir = Path(work_dir)
        self.work_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"Exploit validator initialized: {self.work_dir}")

    def check_mitigations(self, binary_path: Path = None,
                         vuln_type: str = None) -> Tuple[bool, str]:
        """
        Check if exploitation is viable given system/binary mitigations.

        Args:
            binary_path: Path to target binary (optional)
            vuln_type: Vulnerability type (e.g., "format_string")

        Returns:
            Tuple of (is_viable, reason)
        """
        try:
            from packages.exploit_feasibility import check_exploit_viability
            return check_exploit_viability(str(binary_path) if binary_path else None, vuln_type)
        except ImportError:
            logger.debug("Exploit feasibility analysis not available")
            return True, "Exploit feasibility analysis not available"

    def validate_exploit(self, exploit_code: str, exploit_name: str) -> ValidationResult:
        """
        Validate an exploit by attempting to compile it.

        Args:
            exploit_code: C source code of exploit
            exploit_name: Name for the exploit

        Returns:
            ValidationResult with compilation status
        """
        logger.info(f"Validating exploit: {exploit_name}")

        # Write exploit to temporary file
        exploit_source = self.work_dir / f"{exploit_name}.c"
        exploit_binary = self.work_dir / exploit_name

        try:
            with open(exploit_source, 'w') as f:
                f.write(exploit_code)

            # Attempt compilation
            compile_cmd = [
                "gcc",
                "-o", str(exploit_binary),
                str(exploit_source),
                "-w",  # Suppress warnings for now
            ]

            result = subprocess.run(
                compile_cmd,
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                logger.info(f"✓ Exploit compiled successfully: {exploit_binary}")
                return ValidationResult(
                    success=True,
                    compilation_errors=[],
                    runtime_errors=[],
                    warnings=[],
                    exploit_path=exploit_binary
                )
            else:
                # Parse compilation errors
                errors = self._parse_gcc_errors(result.stderr)
                logger.warning(f"✗ Compilation failed with {len(errors)} errors")
                return ValidationResult(
                    success=False,
                    compilation_errors=errors,
                    runtime_errors=[],
                    warnings=[]
                )

        except subprocess.TimeoutExpired:
            return ValidationResult(
                success=False,
                compilation_errors=["Compilation timeout (30s)"],
                runtime_errors=[],
                warnings=[]
            )
        except Exception as e:
            return ValidationResult(
                success=False,
                compilation_errors=[f"Validation error: {str(e)}"],
                runtime_errors=[],
                warnings=[]
            )

    def validate_and_refine(self, exploit_code: str, exploit_name: str,
                          crash_context, multi_turn_analyser,
                          max_iterations: int = 3) -> Tuple[bool, Optional[str], Optional[Path]]:
        """
        Validate exploit and iteratively refine it if needed.

        Args:
            exploit_code: Initial exploit code
            exploit_name: Name for the exploit
            crash_context: Crash context for refinement
            multi_turn_analyser: MultiTurnAnalyser for iterative refinement
            max_iterations: Maximum refinement iterations

        Returns:
            Tuple of (success, final_code, binary_path)
        """
        logger.info("=" * 70)
        logger.info("AUTONOMOUS EXPLOIT VALIDATION & REFINEMENT")
        logger.info("=" * 70)

        current_code = exploit_code
        iteration = 0

        while iteration < max_iterations:
            iteration += 1
            logger.info(f"Iteration {iteration}/{max_iterations}")

            # Validate current code
            validation = self.validate_exploit(current_code, f"{exploit_name}_iter{iteration}")

            if validation.success:
                logger.info(f"✓ Exploit validated successfully after {iteration} iteration(s)")
                return True, current_code, validation.exploit_path

            # Log errors
            logger.info(f"Compilation errors ({len(validation.compilation_errors)}):")
            for error in validation.compilation_errors[:5]:  # First 5
                logger.info(f"  - {error}")

            # Use multi-turn analyser to refine
            if multi_turn_analyser:
                logger.info("Requesting LLM refinement...")
                refined_code = multi_turn_analyser.refine_exploit_iteratively(
                    exploit_code=current_code,
                    crash_context=crash_context,
                    validation_errors=validation.compilation_errors,
                    max_iterations=1  # One LLM iteration per validation iteration
                )

                if refined_code and refined_code != current_code:
                    current_code = refined_code
                    logger.info("Code refined, retrying validation...")
                else:
                    logger.warning("LLM refinement produced no changes")
                    break
            else:
                logger.warning("No multi-turn analyser available for refinement")
                break

        logger.warning(f"✗ Failed to validate exploit after {iteration} iterations")
        return False, current_code, None

    def _parse_gcc_errors(self, stderr: str) -> List[str]:
        """
        Parse GCC error messages.

        Args:
            stderr: GCC stderr output

        Returns:
            List of error messages
        """
        errors = []

        for line in stderr.split('\n'):
            # Look for error lines
            if ': error:' in line:
                # Extract error message
                match = re.search(r': error: (.+)$', line)
                if match:
                    errors.append(match.group(1).strip())
            # Also capture fatal errors
            elif ': fatal error:' in line:
                match = re.search(r': fatal error: (.+)$', line)
                if match:
                    errors.append(match.group(1).strip())

        # If no specific errors found, include full stderr
        if not errors and stderr.strip():
            errors.append(stderr.strip()[:200])  # First 200 chars

        return errors

    def safe_test_exploit(self, exploit_path: Path, target_binary: Path,
                         timeout: int = 5) -> Tuple[bool, str]:
        """
        Safely test an exploit against the target.

        WARNING: This should only be run in isolated/sandboxed environments.

        Args:
            exploit_path: Path to compiled exploit
            target_binary: Target binary to exploit
            timeout: Timeout in seconds

        Returns:
            Tuple of (success, output)
        """
        logger.warning("Testing exploit (ensure you're in a safe environment!)")

        try:
            result = subprocess.run(
                [str(exploit_path)],
                capture_output=True,
                text=True,
                timeout=timeout,
                env={"TARGET": str(target_binary)}
            )

            output = result.stdout + result.stderr

            # Check for success indicators
            success_indicators = [
                "exploit successful",
                "shell spawned",
                "code execution achieved",
                "$",  # Shell prompt
            ]

            success = any(indicator in output.lower() for indicator in success_indicators)

            if success:
                logger.info("✓ Exploit test appears successful")
            else:
                logger.info("Exploit ran but no success indicators found")

            return success, output

        except subprocess.TimeoutExpired:
            logger.warning("Exploit test timed out")
            return False, "Timeout"
        except Exception as e:
            logger.error(f"Exploit test error: {e}")
            return False, str(e)

    def quick_syntax_check(self, code: str) -> List[str]:
        """
        Quick syntax check without compilation.

        Args:
            code: C source code

        Returns:
            List of syntax issues found
        """
        issues = []

        # Basic syntax checks
        if code.count('{') != code.count('}'):
            issues.append("Mismatched braces")

        if code.count('(') != code.count(')'):
            issues.append("Mismatched parentheses")

        if code.count('[') != code.count(']'):
            issues.append("Mismatched square brackets")

        # Check for common issues from local models
        if '#ifdef "__' in code or '#ifndef "__' in code:
            issues.append("Invalid preprocessor directive (likely contains non-ASCII)")

        if '\\T' in code or '\\0x' in code:
            issues.append("Invalid escape sequence")

        # Check for basic includes
        if '#include' not in code:
            issues.append("No include statements found")

        # Check for main function
        if 'int main' not in code and 'void main' not in code:
            issues.append("No main function found")

        return issues
