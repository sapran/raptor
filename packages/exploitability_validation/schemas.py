"""
JSON Schemas for Exploitability Validation Pipeline

Validates outputs from each stage to catch malformed LLM outputs early.
"""

from typing import Any
import json
from datetime import datetime

# Stage 0: Inventory - checklist.json
CHECKLIST_SCHEMA = {
    "type": "object",
    "required": ["generated_at", "total_files", "total_functions", "files"],
    "properties": {
        "generated_at": {"type": "string", "format": "date-time"},
        "total_files": {"type": "integer", "minimum": 0},
        "total_functions": {"type": "integer", "minimum": 0},
        "excluded_patterns": {
            "type": "array",
            "items": {"type": "string"}
        },
        "files": {
            "type": "array",
            "items": {
                "type": "object",
                "required": ["path", "language", "functions"],
                "properties": {
                    "path": {"type": "string"},
                    "language": {"type": "string"},
                    "lines": {"type": "integer"},
                    "functions": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "required": ["name", "line_start"],
                            "properties": {
                                "name": {"type": "string"},
                                "line_start": {"type": "integer", "minimum": 1},
                                "line_end": {"type": "integer", "minimum": 1},
                                "checked": {"type": "boolean", "default": False},
                                "signature": {"type": "string"}
                            }
                        }
                    }
                }
            }
        }
    }
}

# Stage A/B/C/D: findings.json
FINDING_SCHEMA = {
    "type": "object",
    "required": ["id", "file", "function", "line", "vuln_type", "status"],
    "properties": {
        "id": {"type": "string", "pattern": "^(FIND|SARIF)-[0-9]+$"},
        "file": {"type": "string"},
        "function": {"type": "string"},
        "line": {"type": "integer", "minimum": 1},
        "vuln_type": {
            "type": "string",
            "enum": [
                "command_injection", "sql_injection", "xss", "path_traversal",
                "ssrf", "deserialization", "buffer_overflow", "heap_overflow",
                "stack_overflow", "format_string", "use_after_free", "double_free",
                "integer_overflow", "out_of_bounds_read", "out_of_bounds_write",
                "hardcoded_secret", "weak_crypto", "other"
            ]
        },
        "status": {
            "type": "string",
            "enum": [
                "pending", "poc_success", "not_disproven", "disproven",
                "confirmed", "ruled_out",
                "EXPLOITABLE", "CONFIRMED_CONSTRAINED", "CONFIRMED_BLOCKED",
                "CONFIRMED", "CONFIRMED_UNVERIFIED"
            ]
        },
        "poc": {
            "type": "object",
            "properties": {
                "description": {"type": "string"},
                "payload": {"type": "string"},
                "result": {"type": "string"},
                "harmless": {"type": "boolean"}
            }
        },
        "proof": {
            "type": "object",
            "required": ["vulnerable_code"],
            "properties": {
                "vulnerable_code": {"type": "string"},
                "source": {"type": "string"},
                "sink": {"type": "string"},
                "flow": {"type": "array", "items": {"type": "string"}}
            }
        },
        "sanity_check": {
            "type": "object",
            "properties": {
                "passed": {"type": "boolean"},
                "file_exists": {"type": "boolean"},
                "path_correct": {"type": "boolean"},
                "code_verbatim": {"type": "boolean"},
                "flow_real": {"type": "boolean"},
                "code_reachable": {"type": "boolean"},
                "issues": {"type": "array", "items": {"type": "string"}},
                "verified_code": {"type": "string"}
            }
        },
        "ruling": {
            "type": "object",
            "properties": {
                "status": {"type": "string", "enum": ["CONFIRMED", "RULED_OUT"]},
                "disqualifier": {"type": ["string", "null"]},
                "reason": {"type": ["string", "null"]},
                "checks": {
                    "type": "object",
                    "properties": {
                        "code_context": {"type": "string"},
                        "preconditions": {"type": "array", "items": {"type": "string"}},
                        "hedging_detected": {"type": "array", "items": {"type": "string"}}
                    }
                }
            }
        },
        "feasibility": {
            "type": "object",
            "properties": {
                "status": {"type": "string", "enum": ["analyzed", "skipped", "error", "not_applicable"]},
                "binary_path": {"type": "string"},
                "context_file": {"type": "string"},
                "verdict": {"type": "string", "enum": ["Exploitable", "Likely exploitable", "Difficult", "Unlikely", "Unknown"]},
                "protections": {"type": "object"},
                "glibc": {"type": "object"},
                "chain_breaks": {"type": "array", "items": {"type": "string"}},
                "what_would_help": {"type": "array", "items": {"type": "string"}},
                "viable_techniques": {"type": "array", "items": {"type": "string"}}
            }
        },
        "disproved_because": {
            "type": "object",
            "description": "Required when status is 'disproven' - enforces GATE-1 (ASSUME-EXPLOIT)",
            "properties": {
                "investigated": {"type": "string", "description": "What was checked/tested"},
                "conclusion": {"type": "string", "description": "Why it's definitively not exploitable"},
                "would_reconsider_if": {"type": "string", "description": "What evidence would change this verdict"}
            }
        },
        "candidate_reasoning": {
            "type": "string",
            "description": "Why this function was selected as a candidate for analysis"
        },
        "final_status": {
            "type": "string",
            "enum": ["EXPLOITABLE", "CONFIRMED_CONSTRAINED", "CONFIRMED_BLOCKED",
                     "CONFIRMED", "CONFIRMED_UNVERIFIED"]
        }
    }
}

FINDINGS_SCHEMA = {
    "type": "object",
    "required": ["stage", "timestamp", "findings"],
    "properties": {
        "stage": {"type": "string"},
        "timestamp": {"type": "string", "format": "date-time"},
        "target_path": {"type": "string"},
        "vuln_type_focus": {"type": ["string", "null"]},
        "findings": {
            "type": "array",
            "items": FINDING_SCHEMA
        },
        "summary": {
            "type": "object",
            "properties": {
                "total_input": {"type": "integer"},
                "confirmed": {"type": "integer"},
                "ruled_out": {"type": "integer"},
                "exploitable": {"type": "integer"},
                "constrained": {"type": "integer"},
                "blocked": {"type": "integer"}
            }
        }
    }
}

# Stage B: Working documents
ATTACK_TREE_SCHEMA = {
    "type": "object",
    "required": ["root", "nodes"],
    "properties": {
        "root": {"type": "string"},
        "updated_at": {"type": "string"},
        "nodes": {
            "type": "array",
            "items": {
                "type": "object",
                "required": ["id", "type", "description"],
                "properties": {
                    "id": {"type": "string"},
                    "type": {"type": "string", "enum": ["goal", "subgoal", "attack", "condition"]},
                    "description": {"type": "string"},
                    "parent": {"type": ["string", "null"]},
                    "children": {"type": "array", "items": {"type": "string"}},
                    "status": {"type": "string", "enum": ["unexplored", "exploring", "confirmed", "disproven"]},
                    "evidence": {"type": "string"}
                }
            }
        }
    }
}

HYPOTHESIS_SCHEMA = {
    "type": "object",
    "required": ["id", "hypothesis", "status"],
    "properties": {
        "id": {"type": "string"},
        "hypothesis": {"type": "string"},
        "status": {"type": "string", "enum": ["testing", "confirmed", "disproven"]},
        "evidence_for": {"type": "array", "items": {"type": "string"}},
        "evidence_against": {"type": "array", "items": {"type": "string"}},
        "tested_at": {"type": "string"}
    }
}

ATTACK_PATH_SCHEMA = {
    "type": "object",
    "required": ["id", "path", "proximity"],
    "properties": {
        "id": {"type": "string"},
        "finding_id": {"type": "string"},
        "path": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "step": {"type": "integer"},
                    "action": {"type": "string"},
                    "result": {"type": "string"}
                }
            }
        },
        "proximity": {
            "type": "integer",
            "minimum": 0,
            "maximum": 5,
            "description": "0=not started, 5=PoC executes"
        },
        "proximity_description": {"type": "string"},
        "blockers": {"type": "array", "items": {"type": "string"}},
        "poc_attempted": {"type": "boolean"},
        "poc_result": {"type": "string"},
        "attempted_at": {"type": "string"}
    }
}

ATTACK_SURFACE_SCHEMA = {
    "type": "object",
    "required": ["sources", "sinks"],
    "properties": {
        "sources": {
            "type": "array",
            "items": {
                "type": "object",
                "required": ["type", "location"],
                "properties": {
                    "type": {"type": "string"},
                    "location": {"type": "string"},
                    "description": {"type": "string"},
                    "trust_level": {"type": "string", "enum": ["untrusted", "semi-trusted", "trusted"]}
                }
            }
        },
        "sinks": {
            "type": "array",
            "items": {
                "type": "object",
                "required": ["type", "location"],
                "properties": {
                    "type": {"type": "string"},
                    "location": {"type": "string"},
                    "description": {"type": "string"},
                    "danger_level": {"type": "string", "enum": ["critical", "high", "medium", "low"]}
                }
            }
        },
        "trust_boundaries": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "name": {"type": "string"},
                    "from": {"type": "string"},
                    "to": {"type": "string"}
                }
            }
        }
    }
}


class ValidationError(Exception):
    """Raised when JSON validation fails."""
    def __init__(self, message: str, path: str = "", errors: list = None):
        self.message = message
        self.path = path
        self.errors = errors or []
        super().__init__(self.message)


def validate_type(value: Any, schema: dict, path: str = "") -> list:
    """Validate a value against a type schema. Returns list of errors."""
    errors = []

    expected_type = schema.get("type")
    if expected_type is None:
        return errors

    # Handle union types like ["string", "null"]
    if isinstance(expected_type, list):
        type_matches = False
        for t in expected_type:
            if t == "null" and value is None:
                type_matches = True
                break
            elif t == "string" and isinstance(value, str):
                type_matches = True
                break
            elif t == "integer" and isinstance(value, int) and not isinstance(value, bool):
                type_matches = True
                break
            elif t == "number" and isinstance(value, (int, float)) and not isinstance(value, bool):
                type_matches = True
                break
            elif t == "boolean" and isinstance(value, bool):
                type_matches = True
                break
            elif t == "array" and isinstance(value, list):
                type_matches = True
                break
            elif t == "object" and isinstance(value, dict):
                type_matches = True
                break
        if not type_matches:
            errors.append(f"{path}: expected one of {expected_type}, got {type(value).__name__}")
            return errors
    else:
        # Single type
        type_map = {
            "string": str,
            "integer": int,
            "number": (int, float),
            "boolean": bool,
            "array": list,
            "object": dict,
            "null": type(None)
        }

        if expected_type == "integer" and isinstance(value, bool):
            errors.append(f"{path}: expected integer, got boolean")
            return errors

        if expected_type in type_map:
            if not isinstance(value, type_map[expected_type]):
                if not (expected_type == "number" and isinstance(value, (int, float)) and not isinstance(value, bool)):
                    errors.append(f"{path}: expected {expected_type}, got {type(value).__name__}")
                    return errors

    # Additional validations
    if expected_type == "string" or (isinstance(expected_type, list) and "string" in expected_type):
        if isinstance(value, str):
            if "enum" in schema and value not in schema["enum"]:
                errors.append(f"{path}: value '{value}' not in enum {schema['enum']}")
            if "pattern" in schema:
                import re
                if not re.match(schema["pattern"], value):
                    errors.append(f"{path}: value '{value}' does not match pattern {schema['pattern']}")

    if expected_type in ("integer", "number") or (isinstance(expected_type, list) and ("integer" in expected_type or "number" in expected_type)):
        if isinstance(value, (int, float)) and not isinstance(value, bool):
            if "minimum" in schema and value < schema["minimum"]:
                errors.append(f"{path}: value {value} less than minimum {schema['minimum']}")
            if "maximum" in schema and value > schema["maximum"]:
                errors.append(f"{path}: value {value} greater than maximum {schema['maximum']}")

    if expected_type == "array" or (isinstance(expected_type, list) and "array" in expected_type):
        if isinstance(value, list) and "items" in schema:
            for i, item in enumerate(value):
                errors.extend(validate_type(item, schema["items"], f"{path}[{i}]"))

    if expected_type == "object" or (isinstance(expected_type, list) and "object" in expected_type):
        if isinstance(value, dict):
            errors.extend(validate_object(value, schema, path))

    return errors


def validate_object(obj: dict, schema: dict, path: str = "") -> list:
    """Validate an object against a schema. Returns list of errors."""
    errors = []

    # Check required fields
    required = schema.get("required", [])
    for field in required:
        if field not in obj:
            errors.append(f"{path}.{field}: required field missing")

    # Validate properties
    properties = schema.get("properties", {})
    for key, value in obj.items():
        if key in properties:
            field_path = f"{path}.{key}" if path else key
            errors.extend(validate_type(value, properties[key], field_path))

    return errors


def validate_json(data: Any, schema: dict, name: str = "data") -> tuple[bool, list]:
    """
    Validate JSON data against a schema.

    Returns:
        (is_valid, errors) tuple
    """
    errors = validate_type(data, schema, name)
    return len(errors) == 0, errors


def validate_checklist(data: dict) -> tuple[bool, list]:
    """Validate checklist.json"""
    return validate_json(data, CHECKLIST_SCHEMA, "checklist")


def validate_findings(data: dict) -> tuple[bool, list]:
    """Validate findings.json"""
    return validate_json(data, FINDINGS_SCHEMA, "findings")


def validate_attack_tree(data: dict) -> tuple[bool, list]:
    """Validate attack-tree.json"""
    return validate_json(data, ATTACK_TREE_SCHEMA, "attack_tree")


def validate_attack_paths(data: list) -> tuple[bool, list]:
    """Validate attack-paths.json (array of paths)"""
    all_errors = []
    for i, path in enumerate(data):
        errors = validate_type(path, ATTACK_PATH_SCHEMA, f"attack_paths[{i}]")
        all_errors.extend(errors)
    return len(all_errors) == 0, all_errors


def validate_attack_surface(data: dict) -> tuple[bool, list]:
    """Validate attack-surface.json"""
    return validate_json(data, ATTACK_SURFACE_SCHEMA, "attack_surface")


# Convenience function for creating valid structures
def create_empty_checklist(target_path: str) -> dict:
    """Create an empty but valid checklist structure."""
    return {
        "generated_at": datetime.now().isoformat(),
        "total_files": 0,
        "total_functions": 0,
        "target_path": target_path,
        "excluded_patterns": ["*_test.*", "test_*", "*_mock.*", "mock_*", "__tests__/", "tests/"],
        "files": []
    }


def create_empty_findings(stage: str, target_path: str = None, vuln_type: str = None) -> dict:
    """Create an empty but valid findings structure."""
    return {
        "stage": stage,
        "timestamp": datetime.now().isoformat(),
        "target_path": target_path,
        "vuln_type_focus": vuln_type,
        "findings": [],
        "summary": {
            "total_input": 0,
            "confirmed": 0,
            "ruled_out": 0
        }
    }


def create_finding(
    finding_id: str,
    file: str,
    function: str,
    line: int,
    vuln_type: str,
    status: str = "not_disproven"
) -> dict:
    """Create a valid finding structure."""
    return {
        "id": finding_id,
        "file": file,
        "function": function,
        "line": line,
        "vuln_type": vuln_type,
        "status": status,
        "poc": None,
        "proof": None,
        "sanity_check": None,
        "ruling": None,
        "feasibility": None,
        "disproved_because": None,
        "candidate_reasoning": None,
        "final_status": None
    }
