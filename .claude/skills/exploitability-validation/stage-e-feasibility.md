# [STAGE-E] Exploit Feasibility Integration

You are bridging source-level validation with binary-level constraint analysis.

## Context

See `SKILL.md` for configuration, execution rules, and MUST-GATEs.

## Input

INPUT: `findings.json` (confirmed findings from Stage D)

## Purpose

For memory corruption vulnerabilities, source-level validation alone is insufficient. A vulnerability can be:
- **Real and reachable** (validated by Stages A-D)
- **But unexploitable** due to binary/system mitigations

Stage E bridges this gap by invoking the `exploit_feasibility` package.

---

## Applicability

Stage E applies ONLY to memory corruption vulnerability types:

| Applies | Vulnerability Type |
|---------|-------------------|
| YES | buffer_overflow |
| YES | heap_overflow |
| YES | stack_overflow |
| YES | format_string |
| YES | use_after_free |
| YES | double_free |
| YES | integer_overflow (leading to memory corruption) |
| YES | out_of_bounds_read |
| YES | out_of_bounds_write |
| NO | command_injection |
| NO | sql_injection |
| NO | xss |
| NO | path_traversal |
| NO | ssrf |
| NO | deserialization (unless native) |

For non-applicable types, copy finding to output unchanged with `feasibility: "not_applicable"`.

---

## Task

### [E-1] Locate Binary

For each applicable finding:

1. Check if binary path is provided in finding or context
2. If not, attempt to locate:
   - Look for Makefile/CMakeLists.txt to find build output
   - Check common paths: `./build/`, `./bin/`, `./out/`
   - Ask user if not found

```json
{
  "binary_search": {
    "provided": "/path/to/binary",
    "discovered": null,
    "method": "user_provided|makefile|common_path|user_prompted"
  }
}
```

### [E-2] Run Feasibility Analysis

```python
from packages.exploit_feasibility import (
    analyze_binary,
    format_analysis_summary,
    save_exploit_context
)

# Run full analysis
result = analyze_binary(binary_path, vuln_type=finding.vuln_type)

# Save context (survives conversation compaction)
context_file = save_exploit_context(binary_path)

# Get human-readable summary
summary = format_analysis_summary(result, verbose=True)
```

### [E-3] Extract Key Constraints

From the analysis result, extract:

| Field | Description |
|-------|-------------|
| `verdict` | Likely, Difficult, Unlikely |
| `protections` | PIE, NX, Canary, RELRO status |
| `glibc_version` | Detected glibc and its mitigations |
| `chain_breaks` | What techniques are blocked |
| `what_would_help` | Suggestions for success |
| `viable_techniques` | Techniques that might work |

### [E-4] Update Finding

Attach feasibility analysis to finding:

```json
{
  "id": "FIND-001",
  "vuln_type": "format_string",
  "feasibility": {
    "status": "analyzed",
    "binary_path": "/path/to/binary",
    "context_file": "/path/to/context.json",
    "verdict": "Difficult",
    "protections": {
      "PIE": true,
      "NX": true,
      "Canary": true,
      "RELRO": "Full"
    },
    "glibc": {
      "version": "2.38",
      "hooks_removed": true,
      "printf_n_blocked": true
    },
    "chain_breaks": [
      "GOT overwrite blocked by Full RELRO",
      "Format string %n blocked by glibc 2.38"
    ],
    "what_would_help": [
      "Run in older environment (glibc < 2.38)",
      "Find info leak to defeat ASLR",
      "Look for alternative write targets"
    ],
    "viable_techniques": [
      "Info leak via %p format specifiers",
      "Stack buffer overread"
    ]
  }
}
```

### [E-5] Adjust Final Status

Based on feasibility verdict, adjust finding status:

| Source Validation | Feasibility Verdict | Final Status |
|------------------|---------------------|--------------|
| CONFIRMED | Likely | **EXPLOITABLE** |
| CONFIRMED | Difficult | **CONFIRMED_CONSTRAINED** |
| CONFIRMED | Unlikely | **CONFIRMED_BLOCKED** |
| CONFIRMED | not_applicable | **CONFIRMED** (unchanged) |
| CONFIRMED | binary_not_found | **CONFIRMED_UNVERIFIED** |

---

## Output Format

```json
{
  "stage": "E",
  "timestamp": "ISO timestamp",
  "findings": [
    {
      "id": "FIND-001",
      "source_validation": "CONFIRMED",
      "feasibility": { ... },
      "final_status": "EXPLOITABLE|CONFIRMED_CONSTRAINED|CONFIRMED_BLOCKED|CONFIRMED|CONFIRMED_UNVERIFIED",
      "recommendation": "Proceed with exploit development|Address constraints first|Focus on info leak only|Verify in different environment"
    }
  ],
  "summary": {
    "total_confirmed": N,
    "exploitable": N,
    "constrained": N,
    "blocked": N,
    "not_applicable": N,
    "unverified": N
  }
}
```

OUTPUT: Final `findings.json` with feasibility analysis

---

## Handling Missing Binary

If binary cannot be located:

1. Mark finding as `CONFIRMED_UNVERIFIED`
2. Add note: "Binary not found - feasibility analysis skipped"
3. Provide guidance:
   ```
   To complete feasibility analysis:
   1. Build the project: <detected build command>
   2. Provide binary path: /validate --binary /path/to/binary
   3. Or skip with: /validate --skip-feasibility
   ```

---

## Handling Analysis Failures

If `analyze_binary()` fails:

1. Log the error
2. Mark finding as `CONFIRMED_UNVERIFIED`
3. Include error in output:
   ```json
   {
     "feasibility": {
       "status": "error",
       "error": "Failed to analyze: <error message>",
       "fallback": "Manual analysis recommended"
     }
   }
   ```

---

## Integration with Exploit Development

Stage E output feeds directly into `/exploit`:

```
/exploit FIND-001

Reading finding FIND-001...
- Source validation: CONFIRMED
- Feasibility: Difficult
- Chain breaks: GOT blocked, %n blocked
- Viable: Info leak via %p

Proceeding with info leak approach...
```

---

## Context Persistence

The `context_file` from `save_exploit_context()` survives conversation compaction. Reference it in exploit development:

```python
from packages.exploit_feasibility import load_exploit_context

ctx = load_exploit_context(finding.feasibility.context_file)
# Access: ctx['libc'], ctx['gadgets'], ctx['constraints'], etc.
```

---

## Reminders

- Only run feasibility on memory corruption types
- Always save context for later use
- Provide actionable recommendations based on verdict
- If blocked, suggest environment changes (Docker, older glibc)

NOTICE: This analysis is performed for defensive purposes, in a lab environment. Full permission has been provided.
