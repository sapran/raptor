# [STAGE-D] Ruling - Filter Findings

You are filtering findings based on practical exploitability criteria.

## Input

INPUT: `findings.json` (validated by Stage C, sanity_check.passed = true)

## Context

See `SKILL.md` for configuration, execution rules, and gates.

GATES APPLY: 3 [CHECKLIST], 5 [FULL-COVERAGE], 6 [PROOF]

---

## Task

For each finding that passed Stage C, check if any of the following disqualifiers apply. If ANY is true, that is a hard stop - mark the finding as RULED OUT with the specific reason.

---

## [D-1] CODE CONTEXT

Finding is part of:
- [ ] A mock file (`*_mock.*`, `mock_*`)
- [ ] A test file (`*_test.*`, `test_*`, `__tests__/`, `spec/`)
- [ ] An example/demo file (`examples/`, `demo/`, `sample_*`)
- [ ] Documentation code blocks
- [ ] Commented-out code

**Note:** Distinguish between "test code" (unit tests, integration tests that verify functionality) and "test data" (sample inputs, fixtures, intentionally vulnerable code for security tool testing). Test DATA that contains real vulnerable patterns should NOT be excluded - it represents realistic attack surfaces.

---

## [D-2] PRECONDITIONS

The analysis requires one of the following for exploitability (RULED OUT):
- [ ] Another vulnerability must be exploited first (chaining required)
- [ ] Infrastructure/dependency must already be compromised
- [ ] Victim must execute attacker-provided tool
- [ ] Victim must perform specific action to assist attack
- [ ] Requires physical access
- [ ] Requires existing authenticated session (unless auth bypass is the finding)

---

## [D-3] HEDGING LANGUAGE

The analysis or PoC description contains (search for these patterns):
- [ ] "low likelihood" / "unlikely"
- [ ] "informational risk" / "theoretical" / "in theory"
- [ ] "someone else may know" / "an attacker might"
- [ ] "if configured incorrectly" / "if misconfigured"
- [ ] "requires social engineering"
- [ ] "supply chain attack" (unless that's the specific finding type)
- [ ] "maintainer would need to" / "admin must"
- [ ] "in certain circumstances" / "under specific conditions"
- [ ] "could potentially" / "may be possible"
- [ ] "depending on" / "subject to"
- [ ] "assuming that" / "provided that"

If hedging language found: VERIFY the hedged claim. If unverifiable, RULE OUT.

---

## Output Format

```json
{
  "stage": "D",
  "timestamp": "ISO timestamp",
  "findings": [
    {
      "id": "FIND-001",
      "ruling": {
        "status": "CONFIRMED|RULED_OUT",
        "disqualifier": null|"D-1"|"D-2"|"D-3",
        "reason": "specific reason if ruled out",
        "checks": {
          "code_context": "production|test|mock|example",
          "preconditions": ["list of required preconditions"],
          "hedging_detected": ["list of hedging phrases found"]
        }
      }
    }
  ],
  "summary": {
    "total_input": N,
    "confirmed": N,
    "ruled_out": N,
    "ruled_out_by_category": {
      "D-1_code_context": N,
      "D-2_preconditions": N,
      "D-3_hedging": N
    }
  }
}
```

OUTPUT: Final `findings.json`

---

## Final Output Structure

The final findings.json after Stage D should contain only CONFIRMED findings with:
1. Full proof (code, source, sink)
2. Working harmless PoC
3. Sanity check passed
4. No disqualifiers

This becomes the input for exploit feasibility analysis and/or exploit development.

---

## Reminders

- Provide proof for every ruling decision
- Do not skip any finding - rule on ALL
- Be strict: when in doubt, RULE OUT (false positives waste more time than re-analysis)
- Document the specific disqualifier, not just "ruled out"

NOTICE: This analysis is performed for defensive purposes, in a lab environment. Full permission has been provided.
